# RiverWare_Ruleset 8.2
# Created 07:16 April 5, 2021
# 
RULESET
NAME "CRMMS Ruleset";
AGENDA_ORDER ASCENDING;
DESCRIPTION "";
PRECISION   8;
VIEW_DOC_INFO
  DOC_INFO_LOC_PART2 "MTOM_Rules_2013-DocTemplate.html";
  DOC_INFO_FORMAT "Auto";
NOTES "";
BEGIN

  POLICY_GROUP   "Calculate Final State Use and Overruns";
  DESCRIPTION    "This policy group contains rules that compute the projected annual water use for the Lower Division States and large junior priority users in each state (i.e. MWD, CAP, and SNWA). It also computes any projected over- or under-runs after all water schedule adjustments have been made. <br><br>The slots containing the state adjusted apportionments do not get changed when shortage or surplus is declared. They also do not get changed for Lower Basin demand variability. So, the difference in the schedules will appear as an overrun or underrun.";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Final SNWP Diversion";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for SNWA after all schedule adjustments. Adjustments may be made to get Nevada to their projected annual apportionment, lower basin demand variability, shortage, or surplus.<br><br>EXECUTION CONSTRAINT: This rule fires in run cycles 3 and 4. <br><br>SLOTS SET: ForecastUse.SNWPAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: Integration effort. This rule is the same in MTOM and 24MS. No changes needed";
    BEGIN

      $ "ForecastUse.SNWPAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" );

    END
    UUID "{0bfe40d2-1379-42c8-a6d3-db88d4d2719e}";;

    RULE                 "Final CAP Diversion";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for CAP after all schedule adjustments. Adjustments may be made to get Arizona to their projected annual apportionment, lower basin demand variability, shortage, or surplus.<br><br>EXECUTION CONSTRAINT: This rule fires in run cycles 3 and 4. <br><br>SLOTS SET: Forecast.CAPAnnualFC<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br><br>A.Pivarnik, 20200715: Integration effort. This rule is the same in MTOM and 24MS. No changes needed";
    BEGIN

      $ "ForecastUse.CAPAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "CAPDiversion.Total Diversion Requested" );

    END
    UUID "{260969b9-b5a6-4017-8c83-cf6454da6fbe}";;

    RULE                 "Final MWD Diversion";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for MWD after all schedule adjustments. Adjustments may be made to get California to their projected annual apportionment, lower basin demand variability, shortage, or surplus.<br><br>EXECUTION CONSTRAINT: This rule fires in run cycles 3 and 4. <br><br>SLOTS SET: ForecastUse.MWDDiversionAnnualFC; ForecastUse.MWDAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: Integration effort. This rule is written slightly differently in MTOM vs the 24 MS but it accomplishes the same goal. 24 MS reference depletion by subtracting the returns from the diversion, while the MTOM rule references the depletion slot directly";
    BEGIN

      $ "ForecastUse.MWDDiversionAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "MWDDiversion:MWD.Diversion Requested" );

      $ "ForecastUse.MWDAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
 THEN
  "SumSlot"( $ "California_CU_Actual.MWD", @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" ) + "SumFlowsToVolume"( $ "MWDDiversion:MWD.Depletion Requested", @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" )
 ELSE
  FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
   "FlowToVolume"( $ "MWDDiversion:MWD.Depletion Requested" [date], date )
  ENDFOR
 ENDIF;

    END
    UUID "{0feb2abf-ab3a-4ef2-9441-a6c6975c1a78}";;

    RULE                 "Final CA Overrun - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected overrun or underrun for California after all schedule adjustments by calculating the difference between the total annual diversion request and the annual apportionment for the current calendar year.<br><br>EXECUTION CONSTRAINT: This rule fires in run cycles 3 and 4. <br><br>SLOTS SET: AnnualWaterUse.CaOverrun";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: Integration effort.  The MTOM rule has to differentiate between slots for an MRM vs deterministic run. Since the determinsitc run uses the same slot as the 24 MS and is not an MRM, this rule will evaluate correctly in 24MS mode";
    BEGIN

      $ "AnnualWaterUse.CaOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.CaTotalAnnual" [@"24:00:00 December 31, Current Year"] - IF ( "IsMRM"(  ) )
 THEN
  $ "AnnualWaterUse.California_FinalAdjustedApportionment" [@"24:00:00 December 31, Current Year"]
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF;

    END
    UUID "{59a6b371-5c3d-4bda-a304-c88c26e0273c}";;

    RULE                 "Final CA Annual Use - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for California after all schedule adjustments by summing the non-MWD diversion requests and the MWD depletion request for the current calendar year.  This rule also calculates the value of the California Final Adjusted Apportionment.<br><br>EXECUTION CONSTRAINT: This rule fires in run cycles 3 and 4 and if the timestep is December or the finish timestep.<br><br>SLOTS SET: AnnualWaterUse.CaTotalAnnual; AnnualWaterUse.California_FinalAdjustedApportionment";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND ( @"t" == @"24:00:00 December 31, Current Year" OR @"t" == @"Finish Timestep" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: Integration effort. The CATotalAnnual slot assignment is the same as the 24 MS.The FinalAdjustedApportionment slot assignment is not used in the 24 MS and it does not make a difference if the slot is left enabled in 24 MS mode (it is left enabled in determinsitic mode and is used for the MRM in the next rule). No changes";
    BEGIN

      $ "AnnualWaterUse.CaTotalAnnual" [@"24:00:00 December 31, Current Year"] := FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  FOR ( OBJECT diversionSite IN "ListSubbasin"( "California nonMWD WaterUsers" ) ) STAT_SUM
   IF ( diversionSite == % "PaloVerde" )
   THEN
    "FlowToVolume"( diversionSite & "Total Diversion Requested" [date], date )
   ELSE
    "FlowToVolume"( diversionSite & "Diversion Requested" [date], date )
   ENDIF
  ENDFOR + "FlowToVolume"( $ "MWDDiversion:MWD.Depletion Requested" [date], date )
 ENDFOR COMMENTED_BY "This assignment now calculates the Total Diversion by California by Adding all non MWD <br>user Diversion requests to the MWD diversion request less the return flow from MWD. <br>TP 7/13/2015";

      $ "AnnualWaterUse.California_FinalAdjustedApportionment" [@"24:00:00 December 31, Current Year"] := IF ( "IsMRM"(  ) )
 THEN
  IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" AND "GetMonth"( @"Start Timestep" ) >= 4.00000000 )
  THEN
   $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
  ELSE
   ( $ "AnnualWaterUse.California_PreliminaryAdjustedApportionment" [@"24:00:00 December 31, Current Year"] - ( NaNToZero ( $ "ICS Credits.AnnualCreationEC_MWD" ["Dec31ofYear"( @"t" )] ) + NaNToZero ( ( $ "ICS Credits.AnnualSimultaneousCreationDCPICS_MWD" ["Dec31ofYear"( @"t" )] ) / "SystemTaxAdjustment_DCP"(  ) ) ) + ( ( NaNToZero ( $ "ICS Credits.AnnualDeliveryBiNat_CA" ["Dec31ofYear"( @"t" )] ) + NaNToZero ( $ "ICS Credits.AnnualDeliveryEC_MWD" ["Dec31ofYear"( @"t" )] ) + NaNToZero ( $ "ICS Credits.AnnualDeliverySysEff_CA" ["Dec31ofYear"( @"t" )] ) ) + NaNToZero ( $ "ICS Credits.AnnualDeliveryDCP_CA" ["Dec31ofYear"( @"t" )] ) ) ) COMMENTED_BY "removed Tijuana and MWD returns because they are now accounted for in the ICS accounting <br>and Releases Policy group<br>"
  ENDIF
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF;

    END
    UUID "{cb5bece1-347d-415f-b3ce-25fedd882e47}";;

    RULE                 "Final AZ Overrun - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected overrun or underrun for Arizona after all schedule adjustments by calculating the difference between the total diversion request and the annual apportionment for the current calendar year. <br><br>EXECUTION CONSTRAINT: This rule fires in run cycles 3 and 4. <br><br>SLOTS SET: AnnualWaterUse.AzOverrun<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: Integration effort. This rule is the same in MTOM and 24MS. No changes needed";
    BEGIN

      $ "AnnualWaterUse.AzOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.AzTotalAnnual" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.Arizona_Apportionment" [@"24:00:00 December 31, Current Year"];

    END
    UUID "{51c1f814-afca-4ce1-ae9a-42e6c1a8a216}";;

    RULE                 "Final AZ Annual Use - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for Arizona after all schedule adjustments by summing the CAP and non-CAP annual diversion requests for the current calendar year. <br><br>EXECUTION CONSTRAINT: This rule fires in run cycles 3 and 4. <br><br>SLOTS SET: AnnualWaterUse.AzTotalAnnual";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A. Pivarnik, 20200814: Integration effort. Changed slot refernce from the AZTotalWaterUseNonCAP slot to a for statement summing non CAP water use using a subbasin (matches logic previously found in model)";
    BEGIN

      $ "AnnualWaterUse.AzTotalAnnual" [@"24:00:00 December 31, Current Year"] := "SumAnnualCAPDivRequest"(  ) + FOR ( DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year" ) STAT_SUM
  FOR ( OBJECT nonCAPUser IN "ListSubbasin"( "ArizonaNonCAPWaterUsers" ) ) STAT_SUM
   "FlowToVolume"( nonCAPUser & "Diversion Requested" [date], date )
  ENDFOR
 ENDFOR COMMENTED_BY "Sum all Non CAP Diversion Requests";

    END
    UUID "{3181491d-33cb-496a-8c83-de6f7c0e3c69}";;

    RULE                 "Final NV Overrun - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected overrun or underrun for Nevada after all schedule adjustments by calculating the difference between the total diversion requests and the annual apportionment for the current calendar year. <br><br>EXECUTION CONSTRAINT: This rule fires in run cycles 3 and 4. <br><br>SLOTS SET: AnnualWaterUse.NVOverrun<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: Integration effort. This rule is the same in both the 24MS and MTOM ruleset. No changes needed";
    BEGIN

      $ "AnnualWaterUse.NVOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.NvTotalAnnual" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"];

    END
    UUID "{572e18ce-04c0-4998-86a9-dc6292768c02}";;

    RULE                 "Final NV Annual Use - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for Nevada after all schedule adjustments by summing the diversion requests of Nevada water users for the current calendar year. <br><br>EXECUTION CONSTRAINT: This rule fires in run cycles 3 and 4. <br><br>SLOTS SET: AnnualWaterUse.NvTotalAnnual";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: ";
    BEGIN

      $ "AnnualWaterUse.NvTotalAnnual" [@"24:00:00 December 31, Current Year"] := FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  FOR ( OBJECT diversionSite IN "ListSubbasin"( "NevadaWaterUsers" ) ) STAT_SUM
   IF ( diversionSite == % "NvDvsToPkr" )
   THEN
    "FlowToVolume"( diversionSite & "Total Diversion Requested" [date], date )
   ELSE
    "FlowToVolume"( diversionSite & "Diversion Requested" [date], date )
   ENDIF
  ENDFOR
 ENDFOR;

    END
    UUID "{3ce4aca2-e79b-4b7a-b7e7-7d0031d658f2}";;

    RULE                 "Compute Lower Basin Energy";
    DESCRIPTION          "DESCRIPTION: The rule calculates Lower Basin energy. This rule must fire after all schedule adjustments have been made, which is why it is in the highest priority policy group. <br><br>EXECUTION CONSTRAINT: This rule fires in run cycles 3 and 4. <br><br>SLOTS SET: Lower Basin Energy.Computed Davis Energy Using Input Eff; Lower Basin Energy.Computed Davis Head using Turbine Release; Lower Basin Energy.Davis KWH per AF; Lower Basin Energy.Computed Parker Energy Using Input Eff; Lower Basin Energy.Computed PD Project Energy Using Peak Base Power Calc; Lower Basin Energy.Computed PD Project Energy Using Input Eff";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: Integration effort. The MTOM rule is the same as 24 MS. No changes needed";
    BEGIN

      $ "Lower Basin Energy.Computed Davis Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] ) * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" );

      $ "Lower Basin Energy.Computed Davis Head using Turbine Release" [] := "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] );

      $ "Lower Basin Energy.Davis KWH per AF" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] ) * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) / "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * 1.00000000 "ft" * 1.00000000 "ft";

      $ "Lower Basin Energy.Computed Parker Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Parker Efficiency" [] * "FlowToVolume"( $ "Havasu.Turbine Release" [], @"t" ) * $ "Havasu.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" );

      $ "Lower Basin Energy.Computed PD Project Energy Using Peak Base Power Calc" [] := $ "Mohave.Energy" [] + $ "Havasu.Energy" [] / 2.00000000;

      $ "Lower Basin Energy.Computed PD Project Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * $ "Mohave.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) + $ "Lower Basin Energy.Input Parker Efficiency" [] * "FlowToVolume"( $ "Havasu.Turbine Release" [], @"t" ) * $ "Havasu.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) / 2.00000000;

    END
    UUID "{075cf9e5-f328-413c-96b9-81a8d5ddb9d8}";;

  END
  UUID "{0e00c279-f30a-4ce4-8855-d1bab141d5de}";;

  POLICY_GROUP   "AugEOYProjections";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "AugEOYPEProjections";
    DESCRIPTION          "DEVELOPMENT NOTES<br>AUTHOR: ST<br>DESCRIPTION: In the August 24-month study, this rule saves the projected end of calendar year elevations for Powell and Mead. These  values are then transfered to MTOM so MTOM knows how to operate Powell and Mead for the year even if the actual January 1 elevation is not where the August study projected it.<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonth"( "RunStartDate"(  ) ) == 8.00000000 AND "Is24MonthStudy"(  );
    NOTES                "A.Pivarnik, 20200715: Integration effort. This policy group and rule were brought into the integrated ruleset from the 24 MS. This rule only fires in 24 MS mode";
    BEGIN

      $ "PowellToMeadData.AugEOYMeadPEProjection" [@"24:00:00 December 31, Current Year"] := $ "Mead.Pool Elevation" [@"24:00:00 December 31, Current Year"];

      $ "PowellToMeadData.AugEOYPowellPEProjection" [@"24:00:00 December 31, Current Year"] := $ "Powell.Pool Elevation" [@"24:00:00 December 31, Current Year"];

    END
    UUID "{03f55ef1-ed0d-436b-84aa-ece27393ae51}";;

  END
  UUID "{671bbe2d-ec44-4748-b5e5-436bc3cf56cf}";;

  POLICY_GROUP   "FloodControl";
  DESCRIPTION    "This policy group contains all the rules required to simulate Lake Mead/Hoover Dam flood control operations. Flood control operations are based on the USACE Water Control Manual for Flood Control: Hoover Dam and Lake Mead Colorado River, December 1982 (Flood Control Manual)";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Compute LC Dam Capacity";
    DESCRIPTION          "DESCRIPTION: This rule sets the power slots for the LC dams based on their power capacity values and power plant capacity fractions<br><br>EXECUTION CONSTRAINT: This rule fires in run cycle 4. <br><br>SLOTS SET: Mead.Power; Mohave.Power; Havasu.Power";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 4.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200807: Integration effort. Changed slot from Mohave.Power Plant Cap Fraction to LowerBasin Energy. Davis Plant Cap fraction to match the 24 MS. The Mohave Plant Cap Fraction is not used in the new power method for the Mohave reservoir";
    BEGIN

      $ "Mead.Power" [] := $ "EnergyInfo.EffectiveHooverCapacity" [] * $ "Mead.Power Plant Cap Fraction" [];

      $ "Mohave.Power" [] := $ "Lower Basin Energy.Davis_Power_Capacity" [] * $ "Lower Basin Energy.Davis Plant Cap Fraction" [];

      $ "Havasu.Power" [] := $ "Lower Basin Energy.Parker_Power_Capacity" [] * $ "Havasu.Power Plant Cap Fraction" [];

    END
    UUID "{80739e6a-3af3-40a2-ba58-cd1b99e9d8d0}";;

    RULE                 "FC Surplus Schedules Data Volume to Simulation Flow";
    DESCRIPTION          "DESCRIPTION: In the event of Flood Control the Diversion Schedules are set to the Monthly Surplus Schedules for Flood Control. <br><br>EXECUTION CONTRAINT: This rule fires in run cycle 3 or 4 if the Flood Control or Exlusive Space Flags are greater than zero and the Flood Control Surplus Flag is NaN.<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Flood Control Surplus Flag; OthersBlwImp.AzPumpersBlwImp.Diversion Requested; AzPkrToImp:CibolaValleyIID.Diversion Requested; AzPkrToImp:Parker.Diversion Requested; GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested; CAPDiversion.Total Diversion Requested; MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; AAC:Coachella.Diversion Requested; AAC:IID.Diversion Requested; CaPkrToImp:CaPumpersAbvImp.Diversion Requested; CaDvsToPkr:Needles.Diversion Requested; MexicanTreatyDelivery:MexicoSched.Diversion Requested; PumpingFromLakeMead:SNWP.Diversion Requested; PumpingFromLakeMead:SNWP.Depletion Requested<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015<br>MC, 20170920: Changed beginning datetime in FOR loop from @&quot;24:00:00 January 31, Current Year&quot; to @&quot;t&quot; per Sep 19 email from Shana T. and Corinne H.<br>A.Pivarnik, 20180921: Disabled statement setting LowerBasinDemandVariability.AbvHooverTriggerSet. Was causing MTOM to fail in August run when trying to set Mead operations. <br>A.Pivarnik, 20200416: Per group discussion, removed if statement preventing reset of SNWP diversion if the FC Surplus Schedule was less than the sum of SNWA schedules.  Causing issue if FC Surplus Schedule was changed between RC 3 and 4. Changed run control constraint to remove Surplus.Surplus is Nan requirement (prevented rule from firing in RC 4).<br>A. Pivarnik, 20200511: Added MX TJ div to MWD depletion calculation<br>A.Pivarnik, 20200715: Integration effort. Disabled deleted slot assignments. Added CAP Depletion assignment to match the 24 MS. Left out if statement from 24 MS rule which check Pumping from mead Surplus total annual schedules vs forecast use ";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 3.00000000;

            $ "Surplus.Flood Control Surplus Flag" [date] := 1.00000000;

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "AzPumpersBlwImp" ), date );

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CibolaValleyIID" ), date );

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "City of Parker" ), date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Gila Monster Farms" ), date );

            $ "CAPDiversion.Total Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CAP" ), date );

            $ "CAPDiversion.Total Depletion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CAP" ), date );

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "MWD" ), date );

            $ "MWDDiversion:MWD.Depletion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "MWD" ), date ) - "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date ) - "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoTJ" [date], date );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Coachella" ), date );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "IID" ), date );

            $ "CaPkrToImp:CaPumpersAbvImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CaPumpersAbvImp" ), date );

            $ "CaDvsToPkr:Needles.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Needles" ), date );

            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Mexico" ), date );

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date );

            $ "PumpingFromLakeMead:SNWP.Depletion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date );

      ENDFOREACH;

    END
    UUID "{41783893-2316-4c95-a94e-326bbc88b50f}";;

    RULE                 "Compute Effective Hoover Capacity Regression";
    DESCRIPTION          "DESCRIPTION: This Rule is used to set the EnergyInfo.EffectiveHooverCapacity so that it can go out to 60 weeks.  The regression equation provided is from the LC BoR office and can be adjusted using this rule. <br><br>EXECUTION CONSTRAINT: This rule fires in run cycle 3 or 4. <br><br>SLOTS SET: EnergyInfo.EffectiveHooverCapacity; Mead.Power Plant Cap Fraction";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: Integration effort. This logic is structured differently than the 24 MS but solves for the same thing. Add Is24MS to the top if statement which runs the portion of the ruleset which is meant for the MTOM determinstic run (equivalent rule in the 24MS). The second part of the else statement is for MTOM's MRM mode";
    BEGIN

      IF_STATEMENT (( NOT "IsMRM"(  ) OR "Is24MonthStudy"(  ) ) COMMENTED_BY "This check determines if a run is a deterministic run or an MRM run and the data comes<br>out of the Ensemble Forecast Sheet. TP 3/28/2013") THEN
            IF_STATEMENT ("IsInput"( $ "EnergyInfo.EffectiveHooverCapacityInput", @"t" )) THEN
          DESCRIPTION          "Use input value";
      $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := $ "EnergyInfo.EffectiveHooverCapacityInput" [@"t"];

      ELSE
          DESCRIPTION          "Calculate based on Mead pool elevation";
      WITH_STATEMENT (NUMERIC elevMead = $ "Mead.Pool Elevation" [@"t"]) DO
            $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := IF ( elevMead >= 1170.00000000 "feet" )
 THEN
  2074.00000000 "MW"
 ELSE
  ( ( elevMead * ( 5.64540000 "MW" / 1.00000000 "foot" ) - 4530.50000000 "MW" ) COMMENTED_BY "Regression values provided by BOR LC on 3/8/2013 <br>" )
 ENDIF;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC elevMead = $ "Mead.Pool Elevation" [@"t"]) DO
            $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := IF ( elevMead >= 1170.00000000 "feet" )
 THEN
  2074.00000000 "MW"
 ELSE
  ( elevMead * ( 5.64540000 "MW" / 1.00000000 "foot" ) - 4530.50000000 "MW" )
 ENDIF;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Set Mead power plant capacity fraction if necessary";
      IF_STATEMENT (NOT "IsInput"( $ "Mead.Power Plant Cap Fraction", @"t" )) THEN
            $ "Mead.Power Plant Cap Fraction" [@"t"] := $ "Mead.Power Plant Cap Fraction" [@"t - 12"];

      END_IF_STATEMENT;

    END
    UUID "{cf065236-de42-46bf-938f-26b4734bd23e}";;

    RULE                 "Mead Space Building";
    DESCRIPTION          "DESCRIPTION: If the storage in Mead is greater than the target storage (based on the minimum system space that must be available), this rule resets the outflow to achieve the target storage during space building months (August 1 - December 31); if the Flood Control Flag is not already set, this rule also sets it based on whether the outflow was reset by the rule<br><br>EXECUTION CONSTRAINT: This rule fires in run cycle 3 or 4 from Aug-Dec if Mead.Outflow contains a value and the FloodControlOutput.Flood Control Flag is NaN. <br><br>SLOTS SET: Mead.Outflow; FloodControlOutput.Flood Control Flag";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND NOT IsNaN $ "Mead.Storage" [] AND @"t" > @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Flood Control Flag" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>CH, 4/18/18: Added execution constraint: AND IsNaN FloodControlOutput.Flood Control Flag to so that in the case the Flood Control Flag is set in run cycle 3, it is not reset in run cycle 4. Once a flood control flag is set, it should not be reset (even in run cycle 4).<br>A.Pivarnik, 20200715: Integration effort. This rule is the same as the equivalent rule in the 24 MS";
    BEGIN

      IF_STATEMENT ($ "Mead.Storage" [] > "ComputeTargetStorage"(  )) THEN
            $ "Mead.Outflow" [] := "Max"( "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeTargetStorage"(  ) ), $ "Mead.Outflow" [] );

      END_IF_STATEMENT;

      $ "FloodControlOutput.Flood Control Flag" [] := IF ( IsNaN $ "FloodControlOutput.Flood Control Flag" [] )
 THEN
  IF ( $ "Mead.Storage" [] > "ComputeTargetStorage"(  ) )
  THEN
   1.00000000
  ELSE
   0.00000000
  ENDIF
 ENDIF;

    END
    UUID "{845d936f-f1ea-45e0-a351-84b1ad57cd3f}";;

    RULE                 "Mead Flood Control Release";
    DESCRIPTION          "DESCRIPTION: This rule checks that the release from Mead computed for downstream demands is large enough to satisfy flood control during the runoff season. If not, Mead Outflow is reset to the required flood control release which was previously calculated in the <Set Flood Control Release> rule and stored as FloodControlOutput.FCrelease. The flood control flag is also set to 1, which will cause the system to solve downstream and eventually force more water out of Havasu and Mohave.<br><br>EXECUTION CONSTRAINT: This rule fires in run cycle 3 or 4 from Jan-July if Mead.Outflow and the FloodControlOutput.Flood Control Flag contain values. <br><br>SLOTS SET: Mead.Outflow; FloodControlOutput.Flood Control Flag";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND NOT IsNaN $ "Mead.Outflow" [] AND "GetRunCycleIndex"(  ) >= 3.00000000 AND IsNaN $ "FloodControlOutput.Flood Control Flag" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170518: Rule modified to only use 1 IF statement <br>CH, 4/18/18: Added execution constraint: AND IsNaN FloodControlOutput.Flood Control Flag to so that in the case the Flood Control Flag is set in run cycle 3, it is not reset in run cycle 4. Once a flood control flag is set, it should not be reset (even in run cycle 4).<br>A.Pivarnik, 20200715: Integration effort. This rule is the same as the rule in the 24 MS";
    BEGIN

      IF_STATEMENT ($ "Mead.Outflow" [] < $ "FloodControlOutput.FCrelease" []) THEN
            $ "Mead.Outflow" [] := $ "FloodControlOutput.FCrelease" [];

            $ "FloodControlOutput.Flood Control Flag" [] := 1.00000000;

      ELSE
            $ "FloodControlOutput.Flood Control Flag" [] := 0.00000000;

      END_IF_STATEMENT;

    END
    UUID "{04734c58-ee44-4bdb-b2a8-bb807c84a081}";;

    RULE                 "Mead Exclusive Flood Control Space";
    DESCRIPTION          "DESCRIPTION: This rule ensures that Mead does not violate the 1.5 maf space requirement (on MeadFloodControlData.MinSpace slot) at any time of the year. Although this is the highest priority rule, we don't want it to fire until the other flood control procedures have potentially executed. The rule checks the storage in Mead, and if it does not provide the minimum space, the outflow is recalculated so that the minimum space is achieved. If the outflow is recalculated, the FloodControlOutput.Exclusive Space Flag is set to 1; otherwise it is set to 0.<br><br>EXECUTION CONSTRAINT: This rule fires if the FloodControlOutput.Exclusive Space Flag is not NaN (set in this rule) and Mead.Storage is not NaN.<br><br>SLOTS SET: Mead.Outflow; FloodControlOutput.Exclusive Space Flag";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "FloodControlOutput.Flood Control Flag" [] AND NOT IsNaN $ "Mead.Storage" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>SB, 201907011: Edited execution constraint to check if FC slot was greater than 0 (not just Not NaN). This rule was setting Mead outflow during very low scenarios in which flood control rules should not be executing.<br>MC, 20170518: Modified rule to use only 1 IF statement instead of 2, and only print statement in the case the IF statement is TRUE<br>MC, 20170920: Modified calculation of Mead.Outflow to take the larger of outflow to reach min space requirement or outflow to meet downstream requirement per Sep 19 email from Shana T. and Corinne H. (previously did not consider downstream requirement)<br>A.Pivarnik, 20200715: Integration effort. This rule is the same as the rule in the 24 MS. No changes needed";
    BEGIN

    DESCRIPTION          "If Mead storage exceeds what provides the minimum space requirement, <br>recalculate outflow so the storage provides the minimum space.";
      IF_STATEMENT ($ "Mead.Storage" [] >= "ComputeMinimumSpace"( % "Mead" ) COMMENTED_BY "Storage with min space requirement") THEN
            $ "Mead.Outflow" [] := "Max"( "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeMinimumSpace"( % "Mead" ) ), "VolumeToFlow"( $ "Lower Basin Output.DownstreamReq" [], @"t" ) ) COMMENTED_BY "Calculate outflow to reach storage with min space requirement or meet <br>downstream requirement, whichever volume is larger<br>(This will be constrained to MaxSpaceBuildingRelease outflow) <br>";

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "FloodControlOutput.Exclusive Space Flag" []) THEN
            $ "FloodControlOutput.Exclusive Space Flag" [] := IF ( $ "Mead.Storage" [] >= "ComputeMinimumSpace"( % "Mead" ) )
 THEN
  1.00000000
 ELSE
  0.00000000
 ENDIF;

      END_IF_STATEMENT;

      PRINT "Flood Control due to violating Exclusive Flood Control Space: Mead Storage reset";

    END
    UUID "{b584d84f-954a-4de0-a90e-9ff926312f05}";;

    RULE                 "Set Flood Control Release";
    DESCRIPTION          "DESCRIPTION: This rule sets the Mead flood control release according to Table 1 in Exhibit A of the Flood Control Manual, which dictates release steps given inflow and available storage, during flood control months (January 1 - July 31) or as the minimum of either releases needed to achieve target storage or the maximum space building release (28,000 cfs) during space building months (August 1 - December 31).<br><br>EXECUTION CONSTRAINT: This rule fires in run cycle 3 and 4 if this rule has not effectively set the FloodControlOutput.FCrelease rule for the current timestep yet. <br><br>SLOTS SET: FloodControlOutput.FCrelease";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.FCrelease" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: Integration effort. This rule is the same as in the 24 MS. No changes needed";
    BEGIN

      $ "FloodControlOutput.FCrelease" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  GET @INDEX 0.00000000 FROM "ForecastRunoffSeason "(  )
 ELSE
  "ComputeTargetStorageRelease"(  )
 ENDIF;

      PRINT IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "entering Runoff Forecast Season routine for" CONCAT "GetMonthAsString"( @"t" )
 ELSE
  "Mead Flood Control Release is not computed in" CONCAT "GetMonthAsString"( @"t" )
 ENDIF;

    END
    UUID "{9e309501-08e3-4740-be14-4e5b097ffc6a}";;

    RULE                 "Set Without Release";
    DESCRIPTION          "DESCRIPTION: This rule calculates the forecasted Mead inflow and the Mead inflow volume in excess of the available space in Mead and Powell.<br><br>EXECUTION CONSTRAINT: This rule fires in run cycle 3 or 4 if it is Jan-July and FloodControlOutput.Withoutrel is NaN, which is set in this rule. <br><br>SLOTS SET: FloodControlOutput.Forecas; FloodControlOutput.Withoutrel";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Withoutrel" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: The AvailableSpace, DeltaBankStorage, and FloodControlEvap values were previously calculated in Set Forecast Data. Can those slot values be used here instead of recalculating those values? Also, replace call to ForecastMeadInflow with appropriate call to SumFlowsToVolume<br>A.Pivarnik, 20200715: Integration effort. This rule is the same as in the 24 MS. No changes needed";
    BEGIN

      $ "FloodControlOutput.Forecas" [] := "ForecastMeadInflow"(  );

    DESCRIPTION          "Calculate the Mead inflow volume in excess of available space";
      $ "FloodControlOutput.Withoutrel" [] := "ForecastMeadInflow"(  ) - "AvailableSpace"( % "Mead" ) - "AvailableSpace"( % "Powell" ) + $ "MeadFloodControlData.MinSpace" [0.00000000, 0.00000000] - "DeltaBankStorage"(  ) - "FloodControlEvap"( % "Mead" ) - "FloodControlEvap"( % "Powell" ) - $ "FloodControlOutput.Consnev" [];

    END
    UUID "{233d9dc6-c094-473e-9541-54d87a8038f7}";;

    RULE                 "Set Effective Space";
    DESCRIPTION          "DESCRIPTION: This rule calculates the total effective space available in Flaming Gorge (incl. Fontenelle), Blue Mesa, and Navajo until the end of July of the current year by choosing, for each individual reservoir, the minimum of the total available space remaining (*use) or the difference between the Inflow and Outflow (*pred) for the period and summing those values. Used in ForecastMeadInflow function to calculate Mead inflow forecast for calculation of flood control releases according to the Flood Control Algorithm in Exhibit One of the Flood Control Manual.<br><br>EXECUTION CONSTRAINT: This rule fires if slot in the rule has not been set before (FloodControlOutput.UBEffective)<br><br>SLOTS SET: FloodControlOutput.UBEffective";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.UBEffective" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200715: Integration effort. This rule is the same as the 24 MS. No changes needed";
    BEGIN

      $ "FloodControlOutput.UBEffective" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "Min"( $ "FloodControlOutput.FGuse" [], $ "FloodControlOutput.FGpred" [] ) + "Min"( $ "FloodControlOutput.BMuse" [], $ "FloodControlOutput.BMpred" [] ) + "Min"( $ "FloodControlOutput.NAVuse" [], $ "FloodControlOutput.NAVpred" [] )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

    END
    UUID "{ffd0a61e-94c5-4661-9b00-3a8d117f12ea}";;

    RULE                 "Set Consnev";
    DESCRIPTION          "DESCRIPTION: This rule calculates the total diversion volume requested by SNWP from the current timestep to the end of July of the current year.<br><br>EXECUTION CONSTRAINT: This rule executes in Jan-July if FloodControlOutput.Withoutrel is NaN.<br><br>SLOTS SET: FloodControlOutput.Consnev";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Withoutrel" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: The function call in this rule can be replaced by a call to the predefined function SumFlowsToVolume <br>MC, 20180312: The above replacement was made sometime between these two comments. The MTOM changelog may have the specific month that the change was made.<br>APivarnik, 20200715: Integration effort. This rule is the same as the 24 MS. No changes needed";
    BEGIN

      $ "FloodControlOutput.Consnev" [] := "SumFlowsToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", @"t", @"24:00:00 July Max DayOfMonth, Current Year" );

    END
    UUID "{9820997f-5922-492e-801d-37a351282497}";;

    RULE                 "Set Forecast Data";
    DESCRIPTION          "DESCRIPTION: This rule calculates and stores the current available storage and expected net change in storage between the current timestep and the end of July of the current year for Flaming Gorge, Blue Mesa, Navajo, Powell and Mead. The change in bank storage and the evaporation are also calculated and stored. These storage calculations are used to determine effective upstream reservoir storage in the Mead Space Building rule. Effective UB storage is used to calculate Mead inflow forecast in the ForecastMeadInflow function for determination of flood control releases using the Flood Control Algorithmin Exhibit One of the Flood Control Manual.<br><br>EXECUTION CONSTRAINT: The FloodControlOutput.Withoutrel is NaN. <br><br>SLOTS SET: <br>FloodControlOutput.FGuse;  FloodControlOutput.FGpred<br>FloodControlOutput.BMuse;  FloodControlOutput.BMpred<br>FloodControlOutput.NAVuse;  FloodControlOutput.NAVpred <br>FloodControlOutput.PowellPred;  FloodControlOutput.PowellCredEff<br>FloodControlOutput.MeadPred;  FloodControlOutput.MeadCredEff<br>FloodControlOutput.Evapow;  FloodControlOutput.Evapmd;  FloodControlOutput.Deltabs";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.Withoutrel" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170717: Replaced explicit calculations for UC reservoirs with calls to AvailableSpace function<br>MC, 20170531 - the GetLiveCapacity(reservoir) - reservoir.Storage[@&quot;t-1&quot;] calculation is codified in the function AvailableSpace; call that function here?<br>A.Pivarnik, 20200715: Integration effort. This rule is the same as the rule in the 24 MS. No changes needed";
    BEGIN

      WITH_STATEMENT (LIST MonthlyDatelist = "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" )) DO
          DESCRIPTION          "(Inflow - Outflow) between current timestep and end of July of current year";
      $ "FloodControlOutput.FGuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "SumSlotVolume"( $ "FlamingGorgeInflow.Unregulated", MonthlyDatelist ) - "SumSlotVolume"( $ "FlamingGorge.Outflow", MonthlyDatelist )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

          DESCRIPTION          "Calculate additional available storage in Flaming Gorge";
      $ "FloodControlOutput.FGpred" [] := "AvailableSpace"( % "FlamingGorge" ) + "AvailableSpace"( % "Fontenelle" );

          DESCRIPTION          "(Inflow - Outflow) between current timestep and end of July of current year";
      $ "FloodControlOutput.BMuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "SumSlotVolume"( $ "BlueMesaInflow.Unregulated", MonthlyDatelist ) - "SumSlotVolume"( $ "BlueMesa.Outflow", MonthlyDatelist )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

          DESCRIPTION          "Calculate additional available storage in Blue Mesa";
      $ "FloodControlOutput.BMpred" [] := "AvailableSpace"( % "BlueMesa" );

          DESCRIPTION          "(Inflow - Outflow) between current timestep and end of July of current year";
      $ "FloodControlOutput.NAVuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "SumSlotVolume"( $ "Navajo.Inflow", MonthlyDatelist ) - "SumSlotVolume"( $ "Navajo.Outflow", MonthlyDatelist )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

          DESCRIPTION          "Calculate additional available storage in Navajo";
      $ "FloodControlOutput.NAVpred" [] := "AvailableSpace"( % "Navajo" );

          DESCRIPTION          "Calculate additional available storage in Mead";
      $ "FloodControlOutput.MeadPred" [] := "AvailableSpace"( % "Mead" );

            $ "FloodControlOutput.MeadCredEff" [] := "AvailableSpace"( % "Mead" );

          DESCRIPTION          "Calculate additional available storage in Powell";
      $ "FloodControlOutput.PowellPred" [] := "AvailableSpace"( % "Powell" );

            $ "FloodControlOutput.PowellCredEff" [] := "AvailableSpace"( % "Powell" );

          DESCRIPTION          "Calculate change in bank storage with available space";
      $ "FloodControlOutput.Deltabs" [] := "DeltaBankStorage"(  );

          DESCRIPTION          "Calculate evaporation between current timestep and end of July of current year";
      $ "FloodControlOutput.Evapmd" [] := "FloodControlEvap"( % "Mead" );

            $ "FloodControlOutput.Evapow" [] := "FloodControlEvap"( % "Powell" );

      END_WITH_STATEMENT;

    END
    UUID "{3aa54334-7508-4ad3-9e14-4ee1e37d0180}";;

    RULE                 "Set Schedule Release";
    DESCRIPTION          "DESCRIPTION: This rule copies the initial Mead release needed to meet downstream demands to the FloodControlOutput data object in slot MeadSchedRel. The value should only be reported the first time Mead calculates its outflow based on downstream demands.<br><br>EXECUTION CONSTRAINTS: This rule executes in run cycle 3 when the slot set in this rule (Lower Basin Output.MeadSchedRel) is NaN and Mead Outflow is not NaN. <br><br>SLOTS SET: Lower Basin Output.MeadSchedRel";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Lower Basin Output.MeadSchedRel" [] AND NOT IsNaN $ "Mead.Outflow" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>A.Pivarnik, 20200714: Integration effort. This rule matches the 24 MS rule. Changed run constraint to be RC >= 3";
    BEGIN

      $ "Lower Basin Output.MeadSchedRel" [] := $ "Mead.Outflow" [];

    END
    UUID "{2d2f0f91-da59-4386-8aaa-9d9d4270a686}";;

  END
  UUID "{9605f34a-8ce0-4545-8453-6df3df83363a}";;

  POLICY_GROUP   "Lower Basin Diversion Adjustments";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "MX Diversion Adjustment";
    DESCRIPTION          "DESCRIPTION: This rule adjusts Mexico's diversion. The diversion requested is calculated as an annual value based on the diversion requested and Mexico Recoverable Water Savings contribution. The annual volume is split to monthly values using the monthly percentage currently in the diversion requested slot. <br><br>EXECUTION CONSTRAINTS: This rule fires if not a hindcast run and not Domestic Surplus, Quantified Surplus, and Flood Control. In run cycle 3, this rule executes in January or the start timestep and if the rule has not fired successfully yet. In run cycle 4, the rule executes in January and if the LB or DCP condition has changed since run cycle 3. <br><br>SLOTS SET: <br>MexicoTreatyDelivery:MexicoSched.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "IsJANofOutyear"(  ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "IsLBorDCPconditionChanged"(  ) ) AND NOT "IsFloodControl"(  ) ) COMMENTED_BY "This rule does not need to fire in the start year because MX does not have demand variability in <br>the first year. All adjustments are assumed to be included in the start year schedule.  <br>";
    NOTES                "GCAA, 20200330: Updated rule to include SetOutYearSchedules logic and to only fire in outyears.<br>S. Baker, 20200311: Add description. Add function IsDomesticOrQuantifiedOrFloodControl() & IsLBorDCPconditionChanged() to replace Or statement to improve readability. <br>A. Pivarnik, 20200506: Added temporary variable for surplus volume to be used in calculation of MX diversion. Refernced Annual Shortage volume slot instead of calculating shortage via table<br>A.Pivarnik, 20200715: Integration effort. This rule is written differently than the 24 MS equaivalent but accomplishes the same thing within the MTOM/Integration ruleset framework. Changed MXdivrequested to use CU_Forecast values and the month percent to calculate using the CU_schedules ";
    BEGIN

      WITH_STATEMENT (NUMERIC MXSurplusVol = NaNToZero ( $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December Max DayOfMonth, Current Year"] )) DO
            WITH_STATEMENT (NUMERIC MxShortageVolume = $ "Mexico Shortage and Surplus.Mexico Annual Shortage" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            WITH_STATEMENT (NUMERIC BNWSCPreduction = $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings_AnnualContribution" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            WITH_STATEMENT (NUMERIC MXdivRequested = $ "Mexico_CU_Forecast1.MexicoSched" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC MonthPercent = ( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date] ) / MXdivRequested) DO
            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( ( MXdivRequested + MXSurplusVol - BNWSCPreduction - MxShortageVolume ) * MonthPercent, date );

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{c0ad0cb4-4363-4f0d-9b4a-f149af07515a}";;

    RULE                 "NV Diversion Adjustment";
    DESCRIPTION          "DESCRIPTION: This rule adjusts Nevada's diversion for SNWP. The diversion requested is calculated as an annual value based on the diversion requested, shortage volume, DCP contribution, and ICS delivey. The annual volume is split to monthly values using the monthly percentage currently in the diversion requested slot. <br><br>EXECUTION CONSTRAINTS: This rule fires if not a hindcast run and not Domestic Surplus, Quantified Surplus, and Flood Control. In run cycle 3, this rule executes in January if not the start timestep and if the rule has not fired successfully yet. In run cycle 4, the rule executes in January and if the LB or DCP condition has changed since run cycle 3. <br><br>SLOTS SET: <br>PumpingFromLakeMead:SNWP.Diversion Requested; PumpingFromLakeMead:SNWP.Depletion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( IF ( "Is24MonthStudy"(  ) )
 THEN
  "IsJANofOutyear"(  )
 ELSE
  @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year"
 ENDIF AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) COMMENTED_BY "This rule needs to run in the start year in order to apply SNWA demand variability in MTOM mode <br>" ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "IsLBorDCPconditionChanged"(  ) ) AND NOT "IsFloodControl"(  );
    NOTES                "S. Baker, 20200311: Add description. Add function IsDomesticOrQuantifiedOrFloodControl() & IsLBorDCPconditionChanged() to replace Or statement to improve readability. <br>A. Pivarnik, 20200501: Replaced non SNWP water users individually listed with function call. Changed the month percent calculation to be based off volume and not flow. Adjusted logic and run constraint to allow rule to adjust for domestic surplus<br>A. Pivarnik, 20200505: Reorded delivery logic and added notes. Rule now solves for quantified surplus scenarios. Changed run constraint to allow rule to fire in quantified surplus. Refernced Annual Shortage volume slot instead of calculating shortage via table<br>A. PIvarnik, 20200714: Integration effort. Added execution constraint to not fire in start timestep of RC3 in 24MS mode. This rule is different than the 24 MS rule due to MTOM's ruleset structure but accomplishes that same thing. Besides the execution constraint this rule is unchanged<br>";
    BEGIN

      WITH_STATEMENT (NUMERIC NVoffstream = $ "ICS Credits.AnnualNevadaStoredOffstream" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            WITH_STATEMENT (NUMERIC NVICSDelivery = $ "ICS Credits.AnnualICSDelivery_NV" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
          DESCRIPTION          "SNWADivVol = total yearly volume of diversion for SNWA <br>";
      WITH_STATEMENT (NUMERIC SNWADivVol = IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
 THEN
  $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] * "MeadPumpingDemandVariabilityFactor"( @"24:00:00 December Max DayOfMonth, Current Year" )
 ELSE
  IF ( "IsDomesticOrQuantified"(  ) )
  THEN
   ( "Max"( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December Max DayOfMonth, Current Year"], $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] ) + NVoffstream + IF ( "IsQuantifiedSurplus"(  ) )
   THEN
    0.00000000 "acre-ft"
   ELSE
    NVICSDelivery
   ENDIF COMMENTED_BY "Potential delivery of Trib/Imp/DCP ICS is already included in the surplus total annual schedule <br>when in QS so it does not need to be taken into account a second time. <br>" ) COMMENTED_BY "SNWA diversion volume in surplus condition. ICS delivery is taken into consideration in the <br>calculation of the total annual schedule slot. SNWA demand variability does not occur in a surplus <br>scenario <br>"
  ELSE
   WITH NUMERIC AdditionalDCPReductionNV = ( $ "ICS Credits.AnnualSimultaneousCreationDCPICS_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] / "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.AnnualSysWaterforDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
    WITH NUMERIC shortageVolume = $ "Shortage.SNWP Annual Shortage Volume" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
     WITH NUMERIC NonSNWANevadaDivReqs = FOR ( DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year" ) STAT_SUM
      "Monthly Sum Non SNWP Nevada Users"( date )
     ENDFOR DO
      ( ( "Min"( $ "AnnualWaterUse.NV_BasicApportionment" [] - shortageVolume, $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )] ) - NonSNWANevadaDivReqs ) * "MeadPumpingDemandVariabilityFactor"( @"24:00:00 December Max DayOfMonth, Current Year" ) - AdditionalDCPReductionNV + NVICSDelivery + NVoffstream ) COMMENTED_BY "Annual SNWP volume = (NV annual allotment - Priority users diversions + ICS delivery - DCP <br>reduction - Shortage volume)  <br>"
     ENDWITH
    ENDWITH
   ENDWITH COMMENTED_BY "SNWA diversion volume in non surplus condition. This calculation takes into account any ICS <br>delivery, DCP reductions, shortage reductions or demand variability.  <br>"
  ENDIF
 ENDIF COMMENTED_BY "Only adjust SNWA's diversion by demand variability when in the start year. It is assumed that all <br>other diversion adjustments have been included in the start year schedule <br>") DO
          DESCRIPTION          "Adjust SNWA delivery <br>";
      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC MonthPercent = "FlowToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date], date ) / "SumFlowsToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" )) DO
            FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" }) DO
            slot [date] := "VolumeToFlow"( SNWADivVol * MonthPercent, date );

      ENDFOREACH;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{bde8a45f-6afe-4ca8-bb72-e79b4a6c743a}";;

    RULE                 "CA Diversion Adjustment";
    DESCRIPTION          "DESCRIPTION: This rule adjusts California's diversion for MWD, Coachella, and IID. For Coachella and IID, the diversion requested is reduced by the DCP contribution and by a LBDV factor if it is January (allow LBDV in Jan of start year if side inflows below Parker are above 90%). The MWD adjusted diversion requested is based on the deliveries and creation of ICS and is constrained by the states apportionment. The adjusted annual diversion is spread to monthly values based on the current proportion diversion each month.<br><br>EXECUTION CONSTRAINTS: This rule fires if not a hindcast run and not Domestic Surplus, Quantified Surplus, and Flood Control. In run cycle 3, this rule executes at the start timestep if before April in MRM or in January and if the rule has not fired successfully yet. In run cycle 4, the rule executes in January and if the LB or DCP condition has changed since run cycle 3 and the rule has not yet fired successfully. <br><br>SLOTS SET: <br>AAC:Coachella.Diversion Requested<br>AAC:IID.Diversion Requested<br>MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( IF ( "Is24MonthStudy"(  ) OR NOT "IsMRM"(  ) )
 THEN
  "IsJANofOutyear"(  )
 ELSE
  ( ( NOT "IsAPRtoDECofStartYear"(  ) AND @"t" == @"Start Timestep" ) OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" )
 ENDIF AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "IsLBorDCPconditionChanged"(  ) ) AND NOT "IsFloodControl"(  ) ) COMMENTED_BY "This rule needs to run in months prior to April in the start year to apply demand variability to <br>MWD <br>";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: unknown<br><br>TP, 20171222 : Increase the MWD depletion amount by the total delivery less any over delivery that might be occuring in a given scenario, or decrease the delivery if any creation of water for a given scenario. <br>GCAA, 20181030: Replaced references to ICMA slots to Mexico Water Reserve slots<br>AP, 20191130: Updated for DCP.<br>GCAA, 20200330: Updated rule so that PreviousMonthlySublistforAdditionalWaterDelivered does not evaluate to negative and fail in January.<br>S. Baker, 20200311: Updated description. Add function IsDomesticOrQuantifiedOrFloodControl() & IsLBorDCPconditionChanged() to replace Or statement to improve readability. <br>A. Pivarnik, 20200501: Updated the month percent calculation to be based off volume and not flow. Made refernce to monthly percents table the same for IID and CVWD. Changed IID for statement time contraints to match CVWD. Added if statement to not include DCP in first year of run for CVWD since it will be incorporated into the schedules. Moved MWD logic under CVWD temp variable and used temp variable within MWD DCP calculation. Added If statment to MWDDivRequested to set domestic surplus schedules within this rule. Changed run constraint to fire if we are in domestic surplus scenario<br>A. Pivarnik, 20200505: Adjusted logic and run constriant to allow for rule to solve in quantified surplus scenario<br>A. Pivarnik, 20200511: removed references to TJ diversion in rule to prevent double counting <br>A. Pivarnik, 20200713: Integration effort. Removed IsQuantified from if statement to enter Coachella/IID diversion adjustments. No need for the reference because it is already in the monthlyDiv calculation for each user. This also allows the water users to be adjusted correcty if there is a switch in surplus condition<br>A. Pivarnik, 20200714: Integration effort. Added execution constraint to not fire in start timestep of RC3 in 24MS mode. This rule is different than the 24 MS rule due to MTOM's ruleset structure but accomplishes that same thing. <br>A. Pivarnik, 20200807: Changed if conditional for CVWD and IID schedule adjustments to adjust schedules in January only<br>A. Pivarnik: 20210209: Changed execution constraint so MTOM determinstic run executes the same as 24 MS";
    BEGIN

    DESCRIPTION          "MWD Diversion adjustment logic <br>";
      WITH_STATEMENT (NUMERIC totalDeliveryMWDICS = IF ( "IsAPRtoDECofStartYear"(  ) OR NOT "IsMRM"(  ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "ICS Credits.AnnualICSDelivery_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"]
 ENDIF) DO
            WITH_STATEMENT (NUMERIC totalCreationECICS = IF ( "IsAPRtoDECofStartYear"(  ) OR NOT "IsMRM"(  ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "ICS Credits.AnnualCreationEC_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"]
 ENDIF) DO
            WITH_STATEMENT (NUMERIC DCPreductionMWD = $ "ICS Credits.AnnualSimultaneousCreationDCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] / "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.AnnualSysWaterforDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - "CVWD DCP Contribution"(  )) DO
            WITH_STATEMENT (NUMERIC MWDDivRequested = IF ( "IsDomesticOrQuantified"(  ) )
 THEN
  $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] COMMENTED_BY "Checks against return flows/TJ div in calculation of total annual sched<br>"
 ELSE
  $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "California_CU_Forecast1.MWDReturns" [@"24:00:00 December Max DayOfMonth, Current Year"]
 ENDIF) DO
            WITH_STATEMENT (NUMERIC IIDAdjustment = IF ( "IsMRM"(  ) )
 THEN
  "IID ICS Diversion Adjustment"(  )
 ELSE
  0.00000000 "acre-ft"
 ENDIF) DO
            WITH_STATEMENT (NUMERIC DeliveryToDate = "GetDiversionToDate"( $ "California_CU_Actual.MWDDiversion" )) DO
            WITH_STATEMENT (NUMERIC AnnualAdjustedDivRequested = ( MWDDivRequested + ( totalDeliveryMWDICS - totalCreationECICS - DCPreductionMWD - DeliveryToDate + IIDAdjustment ) COMMENTED_BY "Increase the MWD depletion amount by the total delivery less any over delivery that might be <br>occuring in a given scenario, or decrease the delivery if any creation of water for a given <br>scenario. TP 12/22/2017  <br>" )) DO
            WITH_STATEMENT (LIST newMWDDivDepList = FOR ( DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year" ) WITH LIST result = {  } DO
  WITH NUMERIC MaximumMonthlyDiv = $ "MWDDiversionData.MWDCanal_DailyCapacity" [] * "GetDaysInMonth"( date ) DO
   WITH NUMERIC newMWDDivAmount = WITH NUMERIC monthPercent = "FlowToVolume"( $ "MWDDiversion:MWD.Diversion Requested" [date], date ) / "SumFlowsToVolume"( $ "MWDDiversion:MWD.Diversion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) DO
    WITH NUMERIC MWDAdjustedDiv = AnnualAdjustedDivRequested * monthPercent DO
     "Min"( MaximumMonthlyDiv, MWDAdjustedDiv )
    ENDWITH
   ENDWITH DO
    WITH NUMERIC val = "DebuggerStop"(  ) DO
     WITH NUMERIC newDivReq = newMWDDivAmount DO
      WITH NUMERIC newDepReq = newDivReq - $ "California_CU_Schedules.MWDReturns" [date] DO
       WITH NUMERIC RemainingCanalSpace = MaximumMonthlyDiv - newDivReq DO
        APPEND { date , newDivReq , newDepReq , RemainingCanalSpace } ONTO result
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDFOR COMMENTED_BY "Adjust the MWD Diversion Request to reduce the request if there is not enough total ICS in the <br>system for the total delivery to California.  The reduction will be the difference between the <br>determined delivery to california above the state apportionment minus the availalbe ICS volume.  <br>MWD takes the reduction.   <br>") DO
            WITH_STATEMENT (NUMERIC RemainingDelivery = "Max"( AnnualAdjustedDivRequested - "SumByIndex"( newMWDDivDepList, 1.00000000 ), 0.00000000 "acre-ft" )) DO
            WITH_STATEMENT (LIST MonthlyAdjustment = FOR ( DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year" ) WITH LIST result = {  } DO
  WITH LIST CurrentMonthlySublist = GET @INDEX "GetMonth"( date ) - 1.00000000 - IF ( "GetYear"( date ) == "GetYear"( @"Start Timestep" ) )
  THEN
   "GetMonth"( @"Start Timestep" ) - 1.00000000
  ELSE
   0.00000000
  ENDIF FROM newMWDDivDepList DO
   WITH LIST PreviousMonthlySublistforAdditionalWaterDelivered = IF ( "GetMonth"( date ) == 1.00000000 OR date == @"Start Timestep" )
   THEN
    { 0.00000000 }
   ELSE
    GET @INDEX "GetMonth"( date ) - 2.00000000 - IF ( "GetYear"( date ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) != 1.00000000 )
    THEN
     "GetMonth"( @"Start Timestep - 1" )
    ELSE
     0.00000000
    ENDIF FROM result
   ENDIF DO
    WITH NUMERIC RemainingDeliveryBalance = IF ( ( LENGTH result ) == 0.00000000 )
    THEN
     RemainingDelivery
    ELSE
     RemainingDelivery - GET @INDEX 3.00000000 FROM PreviousMonthlySublistforAdditionalWaterDelivered
    ENDIF DO
     WITH NUMERIC RemainingCanalSpace = GET @INDEX 3.00000000 FROM CurrentMonthlySublist DO
      WITH NUMERIC AdditionalDeliveryAmount = "Min"( RemainingCanalSpace, RemainingDeliveryBalance ) DO
       WITH NUMERIC AdditionalWaterDelivered = IF ( ( LENGTH result ) == 0.00000000 )
       THEN
        AdditionalDeliveryAmount
       ELSE
        ( GET @INDEX 3.00000000 FROM PreviousMonthlySublistforAdditionalWaterDelivered ) + AdditionalDeliveryAmount
       ENDIF DO
        WITH NUMERIC val1 = "DebuggerStop"(  ) DO
         APPEND { date , ( GET @INDEX 1.00000000 FROM CurrentMonthlySublist ) + AdditionalDeliveryAmount , ( GET @INDEX 2.00000000 FROM CurrentMonthlySublist ) + AdditionalDeliveryAmount , AdditionalWaterDelivered } ONTO result
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDFOR) DO
            FOREACH (LIST subListMonthlyAdjustment IN MonthlyAdjustment) DO
            $ "MWDDiversion:MWD.Diversion Requested" [GET @INDEX 0.00000000 FROM subListMonthlyAdjustment] := "VolumeToFlow"( GET @INDEX 1.00000000 FROM subListMonthlyAdjustment, GET @INDEX 0.00000000 FROM subListMonthlyAdjustment );

            $ "MWDDiversion:MWD.Depletion Requested" [GET @INDEX 0.00000000 FROM subListMonthlyAdjustment] := "VolumeToFlow"( GET @INDEX 2.00000000 FROM subListMonthlyAdjustment, GET @INDEX 0.00000000 FROM subListMonthlyAdjustment );

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    DESCRIPTION          "Adjust Coachella Valley Water District Diverison (CVWD) in quantified surplus or DCP scenarios. <br>Adjust CVWD only if its january to apply DV or if there is a DCP contribution <br>";
      IF_STATEMENT ("GetMonth"( @"t" ) == 1.00000000) THEN
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "AAC:Coachella.Diversion Requested" [date] := WITH NUMERIC CVWDMonthlyDiv = IF ( "IsQuantifiedSurplus"(  ) )
 THEN
  "Set Monthly Surplus Schedule"( date, "Coachella" )
 ELSE
  $ "California_CU_Schedules.Coachella" [date] * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CVWD" ) - "CVWD DCP Contribution"(  ) * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"]
 ENDIF DO
  "VolumeToFlow"( CVWDMonthlyDiv, date )
 ENDWITH;

      ENDFOREACH;

      END_IF_STATEMENT;

    DESCRIPTION          "Adjust IID Diversion Requested if there is an IID ICS Diversion adjustment or quantified surplus <br>scenario <br>";
      IF_STATEMENT ("GetMonth"( @"t" ) == 1.00000000) THEN
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "AAC:IID.Diversion Requested" [date] := WITH NUMERIC IIDMonthlyDiv = IF ( "IsQuantifiedSurplus"(  ) )
 THEN
  "Set Monthly Surplus Schedule"( date, "IID" )
 ELSE
  $ "California_CU_Schedules.IID" [date] * "AgUsersBelowParkerDemandVariabilityFactor"( date, "IID" )
 ENDIF DO
  "VolumeToFlow"( IIDMonthlyDiv, date )
 ENDWITH;

      ENDFOREACH;

      END_IF_STATEMENT;

    END
    UUID "{6a54fd44-a0fc-456b-bdff-5faea9c4fc1e}";;

    RULE                 "AZ Diversion Adjustment";
    DESCRIPTION          "DESCRIPTION: This rule adjusts Arizona's diversion for CAP. The diversion requested is calculated as an annual value  based on the diversion request, firming obligation, shortage volume, DCP volume reduction, and ICS delivery. The annual volume is split to monthly values using the monthly percentage currently in the diversion requested slot. <br><br>EXECUTION CONSTRAINTS: This rule fires if not a hindcast run and not Domestic Surplus, Quantified Surplus, and Flood Control. In run cycle 3, this rule executes in January if not the start timestep and if the rule has not fired successfully yet. In run cycle 4, the rule executes in January and if the LB or DCP condition has changed since run cycle 3. <br><br>SLOTS SET: <br>CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "IsJANofOutyear"(  ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "IsLBorDCPconditionChanged"(  ) ) AND NOT "IsFloodControl"(  ) ) COMMENTED_BY "This rule does not need to fire in the start year because there is no CAP demand varibility applied <br>directly to the diversion. All adjustments are assumed to be included in the start year schedule.    <br>";
    NOTES                "S. Baker, 20200311: Added description. Add function IsDomesticOrQuantifiedOrFloodControl() & IsLBorDCPconditionChanged() to replace Or statement to improve readability. <br>A. Pivarnik, 20200416: Added if statement to CAPdiv requested temporary variable. Rule is now setting CAP domestic surplus schedule<br>A. Pivarnik, 20200501: Updated the month percent calculation to be based off volume and not flow<br>A. Pivarnik, 20200505: Updated logic and run constraint to allow rule to solve in quantified surplus scenarios. Moved non CAP AZ water diversion assignments to this rule for Domestic/Quantified surplus enetitlement holders. Refernced Annual Shortage volume slot instead of calculating shortage via table<br>A. Pivarnik, 20200713: Integration effort. Removed if statements for setting non CAP user suprlus schedules. This allows for the schedules to be reset to normal if there is a condition change. No other changes made to the rule. This covers the two rules in the 24 MS which change CAP diversion based on DCP and non DCP adjustments. Added CAPDiversion. Total Depletion requested slot assignment to match the 24 MS rule";
    BEGIN

      WITH_STATEMENT (LIST AZFirming = "AZ Firming Agreement"(  )) DO
          DESCRIPTION          "Shortage reduction volume <br>";
      WITH_STATEMENT (NUMERIC CAPShortageVolume = $ "Shortage.CAP Annual Shortage Volume" [@"24:00:00 December Max DayOfMonth, Current Year"] COMMENTED_BY "Adjust CAP for shortage <br>") DO
            WITH_STATEMENT (NUMERIC CAWCDICSdiversionAdjustment = $ "ICS Credits.ICSDiversionAdjustment_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
          DESCRIPTION          "If the LB is in Domestic or Quantified Surplus, use the total annual schedules slot. This is the base <br>diversion volume prior to any adjustments being made <br>";
      WITH_STATEMENT (NUMERIC CAPDivRequested = IF ( "IsDomesticOrQuantified"(  ) )
 THEN
  $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December Max DayOfMonth, Current Year"]
 ELSE
  $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"]
 ENDIF) DO
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC MonthPercent = "FlowToVolume"( $ "CAPDiversion.Total Diversion Requested" [date], date ) / "SumFlowsToVolume"( $ "CAPDiversion.Total Diversion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" )) DO
            $ "CAPDiversion.Total Diversion Requested" [date] := "VolumeToFlow"( ( ( ( CAPDivRequested + GET @INDEX 0.00000000 FROM AZFirming ) + CAWCDICSdiversionAdjustment ) - CAPShortageVolume ) * MonthPercent, date );

            $ "CAPDiversion.Total Depletion Requested" [date] := "VolumeToFlow"( ( ( ( CAPDivRequested + GET @INDEX 0.00000000 FROM AZFirming ) + CAWCDICSdiversionAdjustment ) - CAPShortageVolume ) * MonthPercent, date );

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := WITH NUMERIC MonthlyDiv = IF ( "IsDomesticOrQuantified"(  ) )
 THEN
  "Set Monthly Surplus Schedule"( date, "Gila Monster Farms" )
 ELSE
  $ "Arizona_CU_Schedules.Gila Monster Farms" [date]
 ENDIF DO
  "VolumeToFlow"( MonthlyDiv, date )
 ENDWITH;

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := WITH NUMERIC MonthlyDiv = IF ( "IsDomesticOrQuantified"(  ) )
 THEN
  "Set Monthly Surplus Schedule"( date, "AzPumpersBlwImp" )
 ELSE
  $ "Arizona_CU_Schedules.AzPumpersBlwImp" [date]
 ENDIF DO
  "VolumeToFlow"( MonthlyDiv, date )
 ENDWITH;

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := WITH NUMERIC MonthlyDiv = IF ( "IsQuantifiedSurplus"(  ) )
 THEN
  "Set Monthly Surplus Schedule"( date, "CibolaValleyIID" )
 ELSE
  $ "Arizona_CU_Schedules.CibolaValleyIID" [date]
 ENDIF DO
  "VolumeToFlow"( MonthlyDiv, date )
 ENDWITH;

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := WITH NUMERIC MonthlyDiv = IF ( "IsQuantifiedSurplus"(  ) )
 THEN
  "Set Monthly Surplus Schedule"( date, "City of Parker" )
 ELSE
  $ "Arizona_CU_Schedules.City of Parker" [date]
 ENDIF DO
  "VolumeToFlow"( MonthlyDiv, date )
 ENDWITH;

      ENDFOREACH;

    END
    UUID "{1574216e-dc24-4ea2-9307-60c03d96cdbb}";;

  END
  UUID "{f84695a6-60d5-4324-82b4-b0ea2bb85e38}";;

  POLICY_GROUP   "ICS Accounting";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Flood Control ICS Reduction";
    DESCRIPTION          "DESCRIPTION: This rule will use the Flood Control Volume to reduce the amount of Extraordinary Conservation ICS for each state. If the Flood Control Volume is greater than the volume of EC ICS water for all of the states and EC Delivery for each state, the balance of EC water is taken to 0 AF for each state. If the volume of FC water is less than the total EC volume, then the volume reduced from each state will be proportional to the volume that each state has when the Flood Control occurs. This rule assigns the new values of EC ICS water for California, Nevada, and Arizona and also re-calculates and assignes the Total ICS Volumes for each state. <br><br>EXECUTION CONSTRAINTS: This rule fires in December or the end date of the run in run cycle 4 if it is Flood Control or Quantified Surplus and this rule has not fired sucessfully yet. <br><br>SLOTS SET: <br>ICS Credits.ExtraordinaryConservationICS_[ MWD, IID, CA, NV, CAWCD, CRIT, GRIC, MVIDD, MW, AZ ]<br>ICS Credits.TotalICS_[ MWD, IID, CA,  NV, CAWCD, AZ ]<br>ICS Creitds.Bank_[ MWD, CA, NV, CAWCD, AZ ]";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 4.00000000 AND "IsQuantifiedOrFloodControl"(  ) AND ( @"t" == @"24:00:00 December Max DayOfMonth, Current Year" OR @"t" == @"Finish Timestep" ) AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 11/4/2014<br><br>AP, 20181211:: edited to include MWD / IID ICS CA split<br>AP, 20191130: Updated for DCP.<br>S.Baker, 20200310: updated description.<br>A.Pivarnik, 2021020: Changed string in HasFiredSuccessfully function call to &quot;this rule&quot; so the function works correctly ";
    BEGIN

    DESCRIPTION          "Recalulates ICS balances when in FC <br>";
      WITH_STATEMENT (NUMERIC floodControlVol = "SumFlowsToVolume"( $ "Lower Basin Output.MexicoExcessFlow", @"24:00:00 January Max DayOfMonth, Current Year", "DateMin"( @"24:00:00 December Max DayOfMonth, Current Year", @"Finish Timestep" ) )) DO
            WITH_STATEMENT (LIST stateECBalances = "FloodControlECICSBalance"( floodControlVol )) DO
            $ "ICS Credits.ExtraordinaryConservationICS_MWD" COMMENTED_BY "----- Set individual EC ICS Accounts <br>" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_CA" COMMENTED_BY "CA ICS is MWD + IID <br>" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 1.00000000 FROM stateECBalances ) + GET @INDEX 2.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_CRIT" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_GRIC" ["Dec31ofYear"( @"t" )] := GET @INDEX 6.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" ["Dec31ofYear"( @"t" )] := GET @INDEX 7.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_WM" ["Dec31ofYear"( @"t" )] := GET @INDEX 8.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_AZ" COMMENTED_BY "AZ ICS is CAWCD + CRIT + GRIC + MVIDD + MW <br>" ["Dec31ofYear"( @"t" )] := ( ( ( ( GET @INDEX 4.00000000 FROM stateECBalances ) + GET @INDEX 5.00000000 FROM stateECBalances ) + GET @INDEX 6.00000000 FROM stateECBalances ) + GET @INDEX 7.00000000 FROM stateECBalances ) + GET @INDEX 8.00000000 FROM stateECBalances;

            $ "ICS Credits.TotalICS_MWD" ["Dec31ofYear"( @"t" )] COMMENTED_BY " ------  California Accounting ------  #  <br>" := ( GET @INDEX 9.00000000 FROM stateECBalances );

            $ "ICS Credits.TotalICS_IID" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 10.00000000 FROM stateECBalances );

            $ "ICS Credits.TotalICS_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 9.00000000 FROM stateECBalances ) + ( GET @INDEX 10.00000000 FROM stateECBalances );

            $ "ICS Credits.Bank_MWD" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.Bank_MWD" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.ExtraordinaryConservationICS_MWD" ["Dec31ofYear"( @"t" )] - GET @INDEX 1.00000000 FROM stateECBalances );

            $ "ICS Credits.Bank_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.Bank_CA" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] - ( ( GET @INDEX 1.00000000 FROM stateECBalances ) + GET @INDEX 2.00000000 FROM stateECBalances ) );

            $ "ICS Credits.TotalICS_NV" COMMENTED_BY " ------  Nevada Accounting ------  #  <br>" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 11.00000000 FROM stateECBalances );

            $ "ICS Credits.Bank_NV" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.Bank_NV" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] - GET @INDEX 3.00000000 FROM stateECBalances );

            $ "ICS Credits.TotalICS_CAWCD" COMMENTED_BY " ------  Arizona Accounting ------  # <br>" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 12.00000000 FROM stateECBalances );

            $ "ICS Credits.TotalICS_AZ" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.TotalICS_AZ" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] - ( ( ( ( ( GET @INDEX 4.00000000 FROM stateECBalances ) + GET @INDEX 5.00000000 FROM stateECBalances ) + GET @INDEX 6.00000000 FROM stateECBalances ) + GET @INDEX 7.00000000 FROM stateECBalances ) + GET @INDEX 8.00000000 FROM stateECBalances ) );

            $ "ICS Credits.Bank_CAWCD" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.Bank_CAWCD" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" ["Dec31ofYear"( @"t" )] - GET @INDEX 4.00000000 FROM stateECBalances );

            $ "ICS Credits.Bank_AZ" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.Bank_AZ" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] - ( ( ( ( ( GET @INDEX 4.00000000 FROM stateECBalances ) + GET @INDEX 5.00000000 FROM stateECBalances ) + GET @INDEX 6.00000000 FROM stateECBalances ) + GET @INDEX 7.00000000 FROM stateECBalances ) + GET @INDEX 8.00000000 FROM stateECBalances ) );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{1d4c55e4-42ce-4d4d-a961-8d71f2ad62f0}";;

    RULE                 "MX Accounting";
    DESCRIPTION          "DESCRIPTION: This rule calculates the value for Mexico's Bination Water Scarcity Contingency Plan. <br><br>EXECUTION CONSTRAINTS: This rule fires during run cycle 3 if it is December or the end date of the run.<br><br>SLOTS SET: <br>Mexico Shortage and Surplus.Mexico Water Reserve Balance<br>Mexico Shortage and Surplus.AnnualBWSCP_SysWater<br>Mexico Shortage and Surplus.AnnualCreationMXRecoverableWaterSavings<br>Mexico Shortage and Surplus.Mexico Recoverable Water Savings Balance<br>Mexico Shortage and Surplus.Total Combined MX Savings and Reserve";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "Is24MonthStudy"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsDomesticOrQuantifiedOrFloodControl"(  ) ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE;<br>MC, 20160908: Moved slot Mexico Shortage and Surplus.AnnualCreationICMA inside parentheses so it is subject to 0.97 factor per Shana T. email on 20160831<br><br>GCAA, 20181030: Replaced references to ICMA slots to Mexico Water Reserve slots<br>AP, 20191130: Updated for DCP.<br>GCAA, 20200330: Updated execution constraint to be consistent with other ICS Accounting rules<br>S.Baker, 20200310: updated description. Removed duplicated setting of slot Mexico Shortage and Surplus.Mexico Water Reserve Balance. Added function SetNegativeToZero() which can replace all Max(0 &quot;acre-ft&quot;, xxx).<br>A.Pivarnik, 20200715: Integration effort. While written differently than the 24 MS rule, this accomplishes the same thing within the updated MTOM/Integration ruleset framework";
    BEGIN

      WITH_STATEMENT (NUMERIC WaterReserveBal = $ "Mexico Shortage and Surplus.Mexico Water Reserve Balance" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "MX water reserve balance is previous year's balance plus creation, minus deliveries and any Binational ICS creation  <br>" - $ "Mexico Shortage and Surplus.AnnualDeliveryMexicoWaterReserve" [@"24:00:00 December 31, Current Year"] - $ "ICS Credits.AnnualCreationBiNat_AZ" [@"24:00:00 December 31, Current Year"] - $ "ICS Credits.AnnualCreationBiNat_CA" [@"24:00:00 December 31, Current Year"] - $ "ICS Credits.AnnualCreationBiNat_NV" [@"24:00:00 December 31, Current Year"] + $ "Mexico Shortage and Surplus.AnnualCreationMexicoWaterReserve" [@"24:00:00 December 31, Current Year"] * "SystemTaxAdjustment_DCP"(  )) DO
            WITH_STATEMENT (NUMERIC RecoverableWater_prelim = ( $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings Balance" [@"24:00:00 December 31, Previous Year"] - $ "Mexico Shortage and Surplus.AnnualDeliveryMXRecoverableWaterSavings" [@"24:00:00 December 31, Current Year"] ) COMMENTED_BY "Amount of RecovWaterSavings less delivery <br>") DO
            WITH_STATEMENT (NUMERIC MXBank_prelim = ( RecoverableWater_prelim + WaterReserveBal ) COMMENTED_BY "Calculate prelim bank space used <br>") DO
            WITH_STATEMENT (NUMERIC MXRemainingBankSpace = $ "ICS Credits.MeadBankParameters" ["Mexico", "Max Capacity"] - MXBank_prelim) DO
            WITH_STATEMENT (NUMERIC MXRemainingBankSpace_PreTax = MXRemainingBankSpace / "SystemTaxAdjustment_DCP"(  )) DO
            WITH_STATEMENT (NUMERIC annualBNWSCPcontribution = ( GET @INDEX 1.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "MX" ) )) DO
            WITH_STATEMENT (NUMERIC recoverablewaterBNWSCPcontribution = "SetNegativeToZero"( "Min"( MXRemainingBankSpace_PreTax, annualBNWSCPcontribution ) ) COMMENTED_BY "Recoverable water savings contribution up to allowable bank space.Rest will be system water <br>") DO
            WITH_STATEMENT (NUMERIC syswaterBNWSCPcontribution = ( annualBNWSCPcontribution - recoverablewaterBNWSCPcontribution ) COMMENTED_BY "Sys Water Calculation <br>") DO
            WITH_STATEMENT (NUMERIC RecoverableWaterSavingsBalance = RecoverableWater_prelim + recoverablewaterBNWSCPcontribution * "SystemTaxAdjustment_DCP"(  )) DO
          DESCRIPTION          "Set slots <br>";
      $ "Mexico Shortage and Surplus.AnnualBWSCP_SysWater" [@"24:00:00 December 31, Current Year"] := syswaterBNWSCPcontribution;

            $ "Mexico Shortage and Surplus.AnnualCreationMXRecoverableWaterSavings" [@"24:00:00 December 31, Current Year"] := recoverablewaterBNWSCPcontribution;

            $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings Balance" [@"24:00:00 December 31, Current Year"] := RecoverableWaterSavingsBalance;

            $ "Mexico Shortage and Surplus.Mexico Water Reserve Balance" [@"24:00:00 December 31, Current Year"] := WaterReserveBal;

            $ "Mexico Shortage and Surplus.Total Combined MX Savings and Reserve" [@"24:00:00 December 31, Current Year"] := RecoverableWaterSavingsBalance + WaterReserveBal;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{3cf25486-9222-4d9a-9f7b-d151fe589f1b}";;

    RULE                 "CA Accounting";
    DESCRIPTION          "DESCRIPTION: This rule assigns the values for the California ICS.  The function &quot;ICSAccountingForCA&quot; calculates the delivery and annual values based on input creation values, and assigns the appropriate slots for California ICS.  <br><br>EXECUTION CONSTRAINTS: This rule fires under two different sets of conditions: (1) if it is the start timestep or January, it is run cycle 3, and this rule has not fired successfully; or (2) if it is January and run cycle 4, the model is run in MRM mode, and the Lower Basin condition or the Mexico Binational Water Scarcity Contingency Plan condition has changed between run cycle 3 and 4, it is domestic surplus, quantified surplus, or flood control.<br><br>SLOTS SET: <br>ICS Credits.AnnualDeliveryBiNat_[IID, CA] ;  ICS Credits.AnnualDeliveryEC_[IID, CA] ;  ICS Credits.AnnualDeliverySysEff_CA ; ICS Credits.AnnualDeliveryDCP_CA<br>ICS Credits.AnnualCreationBiNat_CA ;  ICS Credits.AnnualCreationEC_[IID, MWD, CA] ;  ICS Credits.AnnualCreationSysEff_CA ;  ICS Credits.AnnualCreationDCP_[MWD, CA]<br>ICS Credits.BiNationalICS_[MWD, IID, CA] ;  ICS Credits.ExtraordinaryConservationICS_[MWD, IID, CA] ;  ICS Credits.SystemEfficiencyICS_[MWD, CA]<br>ICS Credits.AnnualSimultaneousCreationDCPICS_MWD ;  ICS Credits.DCPICS_[MWD, CA]; ICS Credits.AnnualSysWaterforDCP_[MWD, CA]<br>ICS Credits.TotalICS_[MWD, IID, CA] ; ICS Credits.Bank_[MWD, CA]";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "Is24MonthStudy"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsDomesticOrQuantifiedOrFloodControl"(  ) ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 9/10/2014<br><br>MC, 20180125: Made changes to newMWDDivAmount local variable and subsequent assignments based on changes USBR made in their ruleset<br>CH, 5/10/18: Added assignments for: IID EC ICS balance, IID Binat ICS balance, and total IID ICS (binat + EC) and edited total CA ICS assignment to include total MWD and total IID in order to distinguish MWD ICS creation/delivery/balance from IID ICS creation/delivery/balance <br>AP, 20191130: Updated for DCP.<br>S.Baker, 20200310: updated description.<br>S. Baker, 20200311: Add function IsDomesticOrQuantifiedOrFloodControl() to replace Or statement to improve readability. ";
    BEGIN

      WITH_STATEMENT (LIST iidICSValues = "ICSAccountingForIID"(  )) DO
            WITH_STATEMENT (LIST mwdICSValues = "ICSAccountingForMWD"(  )) DO
          DESCRIPTION          "Annual Delivery BiNatational ICS  <br>";
      $ "ICS Credits.AnnualDeliveryBiNat_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM iidICSValues;

            $ "ICS Credits.AnnualDeliveryBiNat_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualDeliveryBiNat_MWD" ["Dec31ofYear"( @"t" )] + GET @INDEX 0.00000000 FROM iidICSValues;

          DESCRIPTION          "Annual Extraordinary ICS Delivery  <br>";
      $ "ICS Credits.AnnualDeliveryEC_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM iidICSValues;

            $ "ICS Credits.AnnualDeliveryEC_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualDeliveryEC_MWD" ["Dec31ofYear"( @"t" )] + GET @INDEX 1.00000000 FROM iidICSValues;

          DESCRIPTION          "Annual Delivery System Efficiency ICS <br>";
      $ "ICS Credits.AnnualDeliverySysEff_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualDeliverySysEff_MWD" ["Dec31ofYear"( @"t" )];

          DESCRIPTION          "Annual Delivery DCP ICS  <br>";
      $ "ICS Credits.AnnualDeliveryDCP_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualDeliveryDCP_MWD" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualDeliveryDCP_Coachella" ["Dec31ofYear"( @"t" )];

          DESCRIPTION          "Annual Creation Extraordinary Conservation ICS  <br>";
      $ "ICS Credits.AnnualCreationEC_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM iidICSValues;

            $ "ICS Credits.AnnualCreationEC_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM mwdICSValues;

            $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 3.00000000 FROM mwdICSValues ) + GET @INDEX 2.00000000 FROM iidICSValues;

          DESCRIPTION          "Annual Creation BiNational ICS <br>";
      $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualCreationBiNat_IID" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationBiNat_MWD" ["Dec31ofYear"( @"t" )];

          DESCRIPTION          "Annual Creation System Efficiency ICS <br>";
      $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualCreationSysEff_MWD" ["Dec31ofYear"( @"t" )];

          DESCRIPTION          "Annual Creation DCP ICS  <br>";
      $ "ICS Credits.AnnualCreationDCP_MWD" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" ["Dec31ofYear"( @"t" )] + GET @INDEX 2.00000000 FROM mwdICSValues;

            $ "ICS Credits.AnnualSimultaneousCreationDCPICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM mwdICSValues;

            $ "ICS Credits.AnnualCreationDCP_CA" ["Dec31ofYear"( @"t" )] := ( $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" ["Dec31ofYear"( @"t" )] + GET @INDEX 2.00000000 FROM mwdICSValues ) COMMENTED_BY "Coachella DCP ICS is a sub account for MWD. MWD makes full DCP contribution for state of CA .  <br>";

          DESCRIPTION          "Extraordinary Conservation ICS Balances <br>";
      $ "ICS Credits.ExtraordinaryConservationICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 6.00000000 FROM mwdICSValues;

            $ "ICS Credits.ExtraordinaryConservationICS_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM iidICSValues;

            $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 6.00000000 FROM mwdICSValues ) + GET @INDEX 3.00000000 FROM iidICSValues;

          DESCRIPTION          "System Efficiency ICS Balances <br>";
      $ "ICS Credits.SystemEfficiencyICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM mwdICSValues;

            $ "ICS Credits.SystemEfficiencyICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM mwdICSValues;

          DESCRIPTION          "BiNational ICS  <br>";
      $ "ICS Credits.BiNationalICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM mwdICSValues;

            $ "ICS Credits.BiNationalICS_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM iidICSValues;

            $ "ICS Credits.BiNationalICS_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 4.00000000 FROM iidICSValues ) + GET @INDEX 1.00000000 FROM mwdICSValues;

          DESCRIPTION          "DCP ICS <br>";
      $ "ICS Credits.DCPICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM mwdICSValues;

            $ "ICS Credits.DCPICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM mwdICSValues;

          DESCRIPTION          "Total ICS Balances <br>";
      $ "ICS Credits.TotalICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 7.00000000 FROM mwdICSValues;

            $ "ICS Credits.TotalICS_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM iidICSValues;

            $ "ICS Credits.TotalICS_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 7.00000000 FROM mwdICSValues ) + GET @INDEX 5.00000000 FROM iidICSValues;

            $ "ICS Credits.Bank_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 8.00000000 FROM mwdICSValues ) + GET @INDEX 5.00000000 FROM iidICSValues;

            $ "ICS Credits.Bank_MWD" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 8.00000000 FROM mwdICSValues );

          DESCRIPTION          "DCP System Water Contributions <br>";
      $ "ICS Credits.AnnualSysWaterforDCP_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM mwdICSValues;

            $ "ICS Credits.AnnualSysWaterforDCP_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM mwdICSValues;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{91e7030e-d0a9-4803-abae-a6255d74df51}";;

    RULE                 "AZ Accounting";
    DESCRIPTION          "DESCRIPTION: This rule assigns the values for the Arizona ICS.  The function &quot;ICSAccountingForAZ&quot; calculates the delivery and annual values based on input creation values, and assigns the appropriate slots for Arizona ICS. The rule only sets informative values to data object slots and not any simulation object slots, the Lower Basin Demand Variability, Surplus and Shortage Logic will reference this data in later rules.  <br><br>EXECUTION CONSTRAINTS: This rule fires under two different sets of conditions: (1) if it is the start timestep or January, it is run cycle 3, and this rule has not fired successfully; or (2) if it is January and run cycle 4, the model is run in MRM mode, and the Lower Basin condition or the Mexico Binational Water Scarcity Contingency Plan condition has changed between run cycle 3 and 4, it is domestic surplus, quantified surplus, or flood control.<br><br>SLOTS SET: <br>ICS Credits.AnnualCreation[SysEff_AZ, BiNat_AZ, DCP_CAWCD, DCP_AZ]<br>ICS Credits.AnnualCreationEC_[CRIT, GRIC, CAWCD, MVIDD, MW, AZ]<br>ICS Credits.AnnualDelivery[SysEff_AZ, EC_AZ, BiNat_AZ, DCP_AZ]<br>ICS Credits.ExtraordinaryConservationICS_[CRIT, GRIC, CAWCD, MVIDD, MW, AZ]<br>ICS Credits.BiNationalICS_[CAWCD, AZ]<br>ICS Credits.SystemEfficiencyICS_[CAWCD, AZ]<br>ICS Credits.AnnualSimultaneousCreatoinDCPICS_CAWCD<br>ICS Credits.AnnualSysWaterforDCP_[CAWCD, AZ]<br>ICS Credits.DCPICS_[CAWCD, AZ]<br>ICS Credits.Bank_[CAWCD, AZ]<br>ICS Credits.TotalICS_[CAWCD, AZ]<br>ICS Credits.FirmingAgreementBalance_[AZ, US]";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "Is24MonthStudy"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsDomesticOrQuantifiedOrFloodControl"(  ) ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014<br><br>AP, 9/18/2018: Added constraints to fire rule if the LB condition changed between RC 3 and RC 4.<br>AP, 20191130: Updated for DCP.<br>S.Baker, 20200310: updated description.<br>S. Baker, 20200311: Add function IsDomesticOrQuantifiedOrFloodControl() & IsLBorDCPconditionChanged() to replace Or statement to improve readability. <br>A. Pivarnik, 20200713: Integration effort. Changed slot assignment calculations to align with CAP/AZ ICS accounting overhaul ";
    BEGIN

      WITH_STATEMENT (NUMERIC NonCAPBalances_EC = $ "ICS Credits.ExtraordinaryConservationICS_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.ExtraordinaryConservationICS_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.ExtraordinaryConservationICS_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            WITH_STATEMENT (LIST azICSvalues = "ICSAccountingForAZ"(  )) DO
            $ "ICS Credits.AnnualCreationSysEff_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICS Credits.AnnualCreationSysEff_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"];

            $ "ICS Credits.AnnualCreationEC_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( $ "ICS Credits.AnnualCreationEC_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualCreationEC_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualCreationEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualCreationEC_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] ) + GET @INDEX 4.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationBiNat_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICS Credits.AnnualCreationBiNat_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"];

          DESCRIPTION          "Annual Delivery ICS AZ <br>";
      $ "ICS Credits.AnnualDeliverySysEff_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICS Credits.AnnualDeliverySysEff_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"];

            $ "ICS Credits.AnnualDeliveryEC_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_WM" [@"24:00:00 December Max DayOfMonth, Current Year"];

            $ "ICS Credits.AnnualDeliveryBiNat_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICS Credits.AnnualDeliveryBiNat_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"];

            $ "ICS Credits.AnnualDeliveryDCP_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICS Credits.AnnualDeliveryDCP_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"];

          DESCRIPTION          "EC ICS Balances  <br>";
      $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 7.00000000 FROM azICSvalues;

            $ "ICS Credits.ExtraordinaryConservationICS_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( GET @INDEX 7.00000000 FROM azICSvalues ) + NonCAPBalances_EC;

          DESCRIPTION          "BiNat Balances <br>";
      $ "ICS Credits.BiNationalICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 1.00000000 FROM azICSvalues;

            $ "ICS Credits.BiNationalICS_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 1.00000000 FROM azICSvalues;

          DESCRIPTION          "System Eff Balances <br>";
      $ "ICS Credits.SystemEfficiencyICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 0.00000000 FROM azICSvalues;

            $ "ICS Credits.SystemEfficiencyICS_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 0.00000000 FROM azICSvalues;

          DESCRIPTION          "Annual DCP Slots <br>";
      $ "ICS Credits.AnnualSimultaneousCreationDCPICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 2.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualSysWaterforDCP_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 3.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationDCP_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 2.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationDCP_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 2.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualSysWaterforDCP_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 3.00000000 FROM azICSvalues;

          DESCRIPTION          "DCP Balances <br>";
      $ "ICS Credits.DCPICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 8.00000000 FROM azICSvalues;

            $ "ICS Credits.DCPICS_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 8.00000000 FROM azICSvalues;

          DESCRIPTION          "Totals and Bank <br>";
      $ "ICS Credits.Bank_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 9.00000000 FROM azICSvalues;

            $ "ICS Credits.Bank_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( GET @INDEX 9.00000000 FROM azICSvalues ) + NonCAPBalances_EC;

            $ "ICS Credits.TotalICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 10.00000000 FROM azICSvalues;

            $ "ICS Credits.TotalICS_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( GET @INDEX 10.00000000 FROM azICSvalues ) + NonCAPBalances_EC;

          DESCRIPTION          "Firming Balances <br>";
      $ "ICS Credits.FirmingAgreementBalance_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 5.00000000 FROM azICSvalues;

            $ "ICS Credits.FirmingAgreementBalance_US" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 6.00000000 FROM azICSvalues;

          DESCRIPTION          "Annual Creation EC CAWCD <br>";
      $ "ICS Credits.AnnualCreationEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 4.00000000 FROM azICSvalues;

            $ "ICS Credits.ICSDiversionAdjustment_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 11.00000000 FROM azICSvalues;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{880fdd8a-b06f-4f83-a7c8-f99bf19d486d}";;

    RULE                 "NV Accounting";
    DESCRIPTION          "DESCRIPTION: This rule assigns the values for the Nevada ICS.  The function &quot;ICSAccountingForNV&quot; calculates the delivery and annual values based on input creation values, and assigns the appropriate slots for Nevada ICS.  <br><br>EXECUTION CONSTRAINTS: This rule fires under two different sets of conditions: (1) if it is the start timestep or January, it is run cycle 3, and this rule has not fired successfully; or (2) if it is January and run cycle 4, the model is run in MRM mode, and the Lower Basin condition or the Mexico Binational Water Scarcity Contingency Plan condition has changed between run cycle 3 and 4, it is domestic surplus, quantified surplus, or flood control.<br><br>SLOTS SET: <br>ICS Credits.[ BiNational, SystemEfficiency, Imported, Tributary, ExtraordinaryConservation, DCP  ]ICS_NV <br>ICS Credits.AnnualCreationEC_NV ;  ICS Credits.AnnualCreationDCP_NV<br>ICS Credits.AnnualSimultaneousCreationDCPICS_NV ;  ICS Credits.AnnualSysWaterforDCP_NV<br>ICS Credits.Bank_NV ;  ICS Credits.TotalICS_NV";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "Is24MonthStudy"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsDomesticOrQuantifiedOrFloodControl"(  ) ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014<br><br>AP, 20191130: Updated for DCP.<br>S.Baker, 20200310: updated description.<br>S. Baker, 20200311: Add function IsDomesticOrQuantifiedOrFloodControl() & IsLBorDCPconditionChanged() to replace Or statement to improve readability. <br>A.Pivarnik, 20200713: Integration effort. No changes to this rule. Changes to the ICS accounting function for NV";
    BEGIN

      WITH_STATEMENT (LIST ICSAccounting = "ICSAccountingForNV"(  )) DO
            $ "ICS Credits.SystemEfficiencyICS_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 0.00000000 FROM ICSAccounting;

            $ "ICS Credits.BiNationalICS_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 1.00000000 FROM ICSAccounting;

            $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 2.00000000 FROM ICSAccounting;

            $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 3.00000000 FROM ICSAccounting;

            $ "ICS Credits.AnnualSimultaneousCreationDCPICS_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 4.00000000 FROM ICSAccounting;

            $ "ICS Credits.AnnualCreationEC_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 5.00000000 FROM ICSAccounting;

            $ "ICS Credits.AnnualSysWaterforDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 6.00000000 FROM ICSAccounting;

            $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 7.00000000 FROM ICSAccounting;

            $ "ICS Credits.DCPICS_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 8.00000000 FROM ICSAccounting;

            $ "ICS Credits.AnnualCreationDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] + GET @INDEX 4.00000000 FROM ICSAccounting;

            $ "ICS Credits.Bank_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 9.00000000 FROM ICSAccounting;

            $ "ICS Credits.TotalICS_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 10.00000000 FROM ICSAccounting;

      END_WITH_STATEMENT;

    END
    UUID "{6a434372-0c7e-459f-babc-5eb600511d40}";;

    RULE                 "NV ICS Delivery";
    DESCRIPTION          "DESCRIPTION: This rule sets the annual delivery for each Nevada ICS account. The annual delivery is constrained by the bank capacity, Mead's pool elevation, the delivery limit, and any surplus delivery. It is assumed that Nevada will take any tributary or imported ICS delivery made during the current year when in quantified surplus or flood control. The rule determines which ICS account type the annual ICS delivery comes from using a list. The order in which the ICS deliveries are made is: DCP (constrained by Mead recovery elevation), Extraordinary Conservation, Tributary, System Efficiency, Binational, and Imported.<br><br>EXECUTION CONSTRAINTS: This rule fires under two different sets of conditions: (1) if it is the start timestep or January, it is run cycle 3, and this rule has not fired successfully; or (2) if it is January and run cycle 4, the model is run in MRM mode, and the Lower Basin condition or the Mexico Binational Water Scarcity Contingency Plan condition have changed between run cycle 3 and 4. <br><br>SLOTS SET: <br>ICS Credits.AnnualDeliveryDCP_NV<br>ICS Credits.AnnualDeliveryEC_NV<br>ICS Credits.AnnualDeliveryTrib_NV<br>ICS Credits.AnnualDeliverySysEff_NV<br>ICS Credits.AnnualDeliveryBiNat_NV<br>ICS Credits.AnnualDeliveryImp_NV<br>ICS Credits.AnnualICSDelivery_NV";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsDomesticOrQuantifiedOrFloodControl"(  ) COMMENTED_BY "Forcing rule to fire in RC4 when in surplus scenario because LC flag does not differentiate <br>between surplus types <br>" ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: <br><br>AP, 20191117: DCP development.<br>S.Baker, 20200309: Add description.<br>S.Baker, 20200310: Added SetNegativeToZero() to replace Max(0 &quot;acre-ft&quot;, xxxx). Added function IsMeadBelowDCPRecoveryElevation() to replace frequently used boolean. This also changes this rule so that it checks the projected Mead PE to be consistent with other rules. Replace OR statement with & IsLBorDCPconditionChanged() .<br>GCAA, 20200330: Updated rule to include delivery of Nevada's DCP ICS<br>S.Baker, 20200420: Updated execution constraints to match LCs model.<br>A.Pivarnik, 20200713: Integration effort. This rule is slightly different than the one that was in the 24MS ruleset. This rule is more complex and covers more operations as guided by SNWA. This rule was unchanged in the integration effort.";
    BEGIN

      WITH_STATEMENT (NUMERIC ECICStoDCP = "SetNegativeToZero"( "Min"( $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] + ( $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Capacity"] - $ "ICS Credits.Bank_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] ), $ "ICS Credits.AnnualDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) COMMENTED_BY "EC ICS converted to DCP ICS during the current year, constrained by bank capacity  <br>") DO
            WITH_STATEMENT (NUMERIC AnnualDelivery = "ICSDeliveryReduction_DCP"( $ "ICSProjectionData.AnnualICSDelivery_NV_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"], "Nevada", "Max Delivery", ECICStoDCP ) COMMENTED_BY "Checks desired ICS delivery amount against DCP policy restrictions   <br>") DO
            WITH_STATEMENT (NUMERIC DCPSurplusDelivery = IF ( "IsQuantifiedOrFloodControl"(  ) )
 THEN
  $ "ICS Credits.DCPICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF) DO
            WITH_STATEMENT (NUMERIC TribSurplusDeliv = WITH NUMERIC TribVol = $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) DO
  IF ( "IsQuantifiedOrFloodControl"(  ) )
  THEN
   TribVol
  ELSE
   0.00000000 "acre-ft"
  ENDIF
  ELSEIF_COND ( $ "ICS Credits.AnnualNevadaBankSpaceforTrib" [@"24:00:00 December Max DayOfMonth, Current Year"] < TribVol )
  ELSEIF_CLAUSE ( ( TribVol - $ "ICS Credits.AnnualNevadaBankSpaceforTrib" [@"24:00:00 December Max DayOfMonth, Current Year"] ) COMMENTED_BY "If there is not enough room in the bank to create tributary ICS, deliver the amount of ICS that <br>does not fit<br>" )
  END_ELSEIF
 ENDWITH COMMENTED_BY "Take delivery of trib ICS creation if in QS or FC <br>") DO
            WITH_STATEMENT (NUMERIC ImpSurplusDeliv = WITH NUMERIC ImpVol = $ "ICS Credits.AnnualCreationImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) DO
  WITH NUMERIC TribVol = $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) DO
   IF ( "IsQuantifiedOrFloodControl"(  ) )
   THEN
    ImpVol
   ELSE
    0.00000000 "acre-ft"
   ENDIF
   ELSEIF_COND ( "SetNegativeToZero"( $ "ICS Credits.AnnualNevadaBankSpaceforTrib" [@"24:00:00 December Max DayOfMonth, Current Year"] - TribVol ) < ImpVol )
   ELSEIF_CLAUSE ( ( ImpVol - "SetNegativeToZero"( $ "ICS Credits.AnnualNevadaBankSpaceforTrib" [@"24:00:00 December Max DayOfMonth, Current Year"] - TribVol ) ) COMMENTED_BY "If there is not enough room in the bank to create tributary ICS, deliver the amount of ICS that <br>does not fit<br>" )
   END_ELSEIF
  ENDWITH
 ENDWITH COMMENTED_BY "Take delivery of Imported ICS if in QS or FC <br>") DO
            WITH_STATEMENT (LIST DeliveryChargedList = FOR ( NUMERIC CategoryBalance IN { $ "ICS Credits.DCPICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] COMMENTED_BY "If there is an ICS deivery amount, take out of accounts in the following order. <br>" , ( $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) COMMENTED_BY "ECICS balance  <br>" , ( $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) ) COMMENTED_BY "Current Year trib <br>" , $ "ICS Credits.SystemEfficiencyICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] COMMENTED_BY "SysEff <br>" , $ "ICS Credits.BiNationalICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] COMMENTED_BY "BiNat <br>" , ( $ "ICS Credits.AnnualCreationImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) ) COMMENTED_BY "Imported <br>" } ) WITH LIST result = {  } DO
  WITH NUMERIC RemainingBalance = IF ( ( LENGTH result ) == 0.00000000 )
  THEN
   AnnualDelivery
  ELSE
   AnnualDelivery - "Sum"( result )
  ENDIF COMMENTED_BY "Remaining ICS delivery balance   <br>" DO
   WITH NUMERIC DeliveryAmount = IF ( ( ( ( LENGTH result ) == 0.00000000 AND "IsMeadBelowDCPRecoveryElevation"( @"24:00:00 December Max DayOfMonth, Previous Year" ) ) OR ( ( ( ( LENGTH result ) == 0.00000000 OR ( LENGTH result ) == 5.00000000 AND "IsQuantifiedOrFloodControl"(  ) ) COMMENTED_BY "If surplus, do not take any ICS out of Tributary or Imported ICS accounts because they were <br>already cleared in the logic above.  <br>" ) OR ( ( LENGTH result ) == 2.00000000 AND TribSurplusDeliv > 0.00000000 "acre-ft" ) ) ) COMMENTED_BY "Don't take DCP ICS if the Mead elevation is below the recovery elevation of 1110 <br>" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "Min"( RemainingBalance, CategoryBalance )
   ENDIF DO
    APPEND DeliveryAmount ONTO result
   ENDWITH
  ENDWITH
 ENDFOR) DO
          DESCRIPTION          "Set ICS delivery slots <br>";
      $ "ICS Credits.AnnualDeliveryDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( GET @INDEX 0.00000000 FROM DeliveryChargedList ) + DCPSurplusDelivery;

            $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 1.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( GET @INDEX 2.00000000 FROM DeliveryChargedList ) + TribSurplusDeliv;

            $ "ICS Credits.AnnualDeliverySysEff_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 3.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryBiNat_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 4.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( GET @INDEX 5.00000000 FROM DeliveryChargedList ) + ImpSurplusDeliv;

            $ "ICS Credits.AnnualICSDelivery_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Sum"( DeliveryChargedList ) + TribSurplusDeliv + ImpSurplusDeliv + DCPSurplusDelivery;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{060b25bf-4fd4-45e9-a045-c846eff6827e}";;

    RULE                 "CA ICS Delivery";
    DESCRIPTION          "DESCRIPTION: This rule sets the annual delivery for each MWD ICS account. The annual delivery is constrained by the bank capacity, Mead's pool elevation, and the delivery limit. The rule determines which ICS account type the annual ICS delivery comes from using a list. The order in which the ICS deliveries are made is: DCP (constrained by Mead recovery elevation), Extraordinary Conservation, System Efficiency, and Binational. The EC ISC balance is the previous years account balance minus the EC to DCP conversion(from the previous year). MWD can either create or deliver EC ICS based on Sac WY index, not both. <br><br>EXECUTION CONSTRAINTS: This rule fires under two different sets of conditions: (1) if it is the start timestep or January, it is run cycle 3, and this rule has not fired successfully; or (2) if it is January and run cycle 4, the model is run in MRM mode, and the Lower Basin condition or the Mexico Binational Water Scarcity Contingency Plan condition have changed between run cycle 3 and 4. <br><br>SLOTS SET: <br>ICS Credits.AnnualDeliveryDCP_MWD<br>ICS Credits.AnnualDeliveryEC_MWD<br>ICS Credits.AnnualDeliverySysEff_MWD<br>ICS Credits.AnnualDeliveryBiNat_MWD<br>ICS Credits.AnnualICSDelivery_MWD";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsDomesticOrQuantifiedOrFloodControl"(  ) COMMENTED_BY "Forcing rule to fire in RC4 when in surplus scenario because LC flag does not differentiate <br>between surplus types <br>" ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: <br><br>AP, 20191117: DCP development.<br>S.Baker, 20200309: Add description. Added SetNegativeToZero() to replace Max(0 &quot;acre-ft&quot;, xxxx). Added function IsMeadBelowDCPRecoveryElevation() to replace frequently used boolean. Replace OR statement with & IsLBorDCPconditionChanged() .<br>A.Pivarnik, 20200713: Integration effort. There are minor differences in this rule compared to the 24 MS equivalent due to the structure of the MTOM ruleset. No changes needed";
    BEGIN

      WITH_STATEMENT (NUMERIC ECICStoDCP = "SetNegativeToZero"( "Min"( $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] + ( $ "ICS Credits.MeadBankParameters" ["California", "Max Capacity"] - $ "ICS Credits.Bank_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] ), $ "ICS Credits.AnnualDCPContribution_CA" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) COMMENTED_BY "EC ICS converted to DCP ICS during the current year, constrained by bank capacity <br>") DO
            WITH_STATEMENT (NUMERIC AnnualDelivery = "ICSDeliveryReduction_DCP"( $ "ICSProjectionData.AnnualICSDelivery_MWD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"], "California", "Max Delivery", ECICStoDCP ) COMMENTED_BY "Checks desired ICS delivery amount against DCP policy restrictions . This also checks against Max <br>delivery constraint as set by guidelines <br>") DO
            WITH_STATEMENT (LIST DeliveryChargedList = FOR ( NUMERIC CategoryBalance IN { ( $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualDeliveryDCP_Coachella" [@"24:00:00 December Max DayOfMonth, Current Year"] ) COMMENTED_BY "If there is an ICS delivery amount, take out of accounts in the following order.  <br>" , ( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) COMMENTED_BY "EC ICS: previous year's balance less any conversion for DCP ICS     <br>" , $ "ICS Credits.SystemEfficiencyICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] , $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] } ) WITH LIST result = {  } DO
  WITH NUMERIC RemainingBalance = IF ( ( LENGTH result ) == 0.00000000 )
  THEN
   AnnualDelivery
  ELSE
   AnnualDelivery - "Sum"( result )
  ENDIF COMMENTED_BY "Remaining ICS delivery balance  <br>" DO
   WITH NUMERIC DeliveryAmount = IF ( ( ( LENGTH result ) == 0.00000000 AND "IsMeadBelowDCPRecoveryElevation"( @"24:00:00 December Max DayOfMonth, Previous Year" ) ) COMMENTED_BY "Don't take DCP ICS if the Mead elevation is below the recovery elevation of 1110  <br>" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "Min"( RemainingBalance, CategoryBalance )
   ENDIF DO
    APPEND DeliveryAmount ONTO result
   ENDWITH
  ENDWITH
 ENDFOR) DO
          DESCRIPTION          "Set ICS delivery slots  <br>";
      $ "ICS Credits.AnnualDeliveryDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 0.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 1.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliverySysEff_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 2.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryBiNat_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 3.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualICSDelivery_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Sum"( DeliveryChargedList );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{eae562f8-31fd-4638-9ba6-2f6cd97320b2}";;

    RULE                 "AZ ICS Delivery";
    DESCRIPTION          "DESCRIPTION: This rule sets the annual delivery for each Arizona ICS account. The annual delivery is constrained by the bank capacity, Mead's pool elevation, and the delivery limit. The rule determines which ICS account type the annual ICS delivery comes from using a list. The order in which the ICS deliveries are made is: DCP (constrained by Mead recovery elevation), Extraordinary Conservation, Binational, and System Efficiency. <br><br>EXECUTION CONSTRAINTS: This rule fires under two different sets of conditions: (1) if it is the start timestep or January, it is run cycle 3, and this rule has not fired successfully; or (2) if it is January and run cycle 4, the model is run in MRM mode, and the Lower Basin condition or the Mexico Binational Water Scarcity Contingency Plan condition has changed between run cycle 3 and 4, it is domestic surplus, quantified surplus, or flood control.<br><br>SLOTS SET: <br>ICS Credits.AnnualDeliveryDCP_CAWCD<br>ICS Credits.AnnualDeliveryEC_CAWCD<br>ICS Credits.AnnualDeliveryBiNat_CAWCD<br>ICS Credits.AnnualDeliverySysEff_CAWCD<br>ICS Credits.AnnualICSDelivery_CAWCD";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsDomesticOrQuantifiedOrFloodControl"(  ) COMMENTED_BY "Forcing rule to fire in RC4 when in surplus scenario because LC flag does not differentiate <br>between surplus types <br>" ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: <br><br>AP, 20191117: DCP development.<br>S.Baker, 20200309: Add description. Added SetNegativeToZero() to replace Max(0 &quot;acre-ft&quot;, xxxx). Added function IsMeadBelowDCPRecoveryElevation() to replace frequently used boolean. <br>S. Baker, 20200311: Add function IsDomesticOrQuantifiedOrFloodControl() to replace Or statement to improve readability. Replace OR statement with & IsLBorDCPconditionChanged().<br>A.Pivarnik, 20200713: Integration effort. There are minor differences in this rule compared to the 24 MS equivalent due to the structure of the MTOM ruleset. Changed refernce to AnnualCreationEC_Preliminary value. Previous slot reference does not exist anymore/is now incorrect. This was done as part of te AZ ICS/Accounting overhaul.<br>APivarnik, 20200804: Changed bank calculation for CAP to take into account the non CAP AZ creation for a given year";
    BEGIN

      WITH_STATEMENT (NUMERIC ECICStoDCP = "SetNegativeToZero"( "Min"( $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Capacity"] - ( $ "ICS Credits.Bank_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.ExtraordinaryConservationICS_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] COMMENTED_BY "Non cap water user bank is equal to the EC ICS balance of the current year <br>" + $ "ICS Credits.ExtraordinaryConservationICS_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.ExtraordinaryConservationICS_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] ), $ "ICSProjectionData.AnnualCreationEC_CAWCD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) COMMENTED_BY "EC ICS converted to DCP ICS during the current year, constrained by bank capacity.<br><br>Since CAWCD is not converting from previous ICS balance, its the minimum between the bank <br>space and the amount of ICS created during the year.   <br>") DO
            WITH_STATEMENT (NUMERIC AnnualDelivery = "ICSDeliveryReduction_DCP"( $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"], "Arizona", "Max Delivery", ECICStoDCP ) COMMENTED_BY "Checks desired ICS delivery amount against DCP policy restrictions   <br>") DO
            WITH_STATEMENT (LIST DeliveryChargedList = FOR ( NUMERIC CategoryBalance IN { $ "ICS Credits.DCPICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] , $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] , $ "ICS Credits.BiNationalICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] , $ "ICS Credits.SystemEfficiencyICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] } COMMENTED_BY "Accounts for ICS delivery (in order) <br>" ) WITH LIST result = {  } DO
  WITH NUMERIC RemainingBalance = IF ( ( LENGTH result ) == 0.00000000 )
  THEN
   AnnualDelivery
  ELSE
   AnnualDelivery - "Sum"( result )
  ENDIF COMMENTED_BY "Remaining ICS delivery balance   <br>" DO
   WITH NUMERIC DeliveryAmount = IF ( ( ( LENGTH result ) == 0.00000000 AND "IsMeadBelowDCPRecoveryElevation"( @"24:00:00 December Max DayOfMonth, Previous Year" ) ) COMMENTED_BY "Don't take DCP ICS if the Mead elevation is below the recovery elevation of 1110  <br>" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "Min"( RemainingBalance, CategoryBalance )
   ENDIF DO
    APPEND DeliveryAmount ONTO result
   ENDWITH
  ENDWITH
 ENDFOR) DO
          DESCRIPTION          "Set ICS delivery slots  <br>";
      $ "ICS Credits.AnnualDeliveryDCP_CAWCD" [@"24:00:00 December 31, Current Year"] := GET @INDEX 0.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December 31, Current Year"] := GET @INDEX 1.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryBiNat_CAWCD" [@"24:00:00 December 31, Current Year"] := GET @INDEX 2.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliverySysEff_CAWCD" [@"24:00:00 December 31, Current Year"] := GET @INDEX 3.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualICSDelivery_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Sum"( DeliveryChargedList );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{ccb68901-761d-4298-aba0-749bec3b23f9}";;

  END
  UUID "{3f523123-2536-4487-a732-9f06f03e16f6}";;

  POLICY_GROUP   "ICS Creation and Delivery";
  DESCRIPTION    "This policy group handles Lower Basn deliveries and ICS based on changes in operating conditions due to Lower Basin Demand Variability. The rules reset the Lower Basin water user diversions if necessary. Rules also set preliminary volumes of ICS creation and delivieries for CAWCD, MWD, and SNWP. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "SNWP ICS Creation and Delivery";
    DESCRIPTION          "DESCRIPTION: This rule determines the preliminary Nevada ICS creation and delivery volumes based on Nevada's demand and basic apporitionment during non-flood control conditions. The ICS delivery is the minimum of the Nevada's maximum annual delivery, the water remaining in its apportionment after deliveries based on the LB operating condition, and Nevada's total ICS and DCP ICS credits with the constraint on DCP recovery elevation. The EC ICS creation is minimum of the ICS available based on apportionment and delivery constraints, Nevada's maximum annual creation, Lower Basin operating condition, and bank availability. The bank availability calculates volumes that can be taxed and not taxed since ICS is not taxed if it is paying back the previous year's delivery. The bank availability that can be taxed is calculated by the bank capacity minus any deliveries from the previous year, the bank and any tributary/imported ICS being converted to EC ICS, and annual creation of bi-national ICS (input slot). The EC ICS delivery from the previous year is then added back after the tax adjustment to calculate the bank availability.<br><br>EXECUTION CONSTRAINTS: This rule fires under two different sets of conditions: (1) if it is the start timestep or January, it is run cycle 3, and this rule has not fired successfully; or (2) if it is January and run cycle 4, the model is run in MRM mode, and the Lower Basin condition or the Mexico Binational Water Scarcity Contingency Plan condition has changed between run cycle 3 and 4, it is domestic surplus, quantified surplus, or flood control.<br><br>SLOTS SET: <br>ICSProjectionData.AnnualICSDelivery_NV_Preliminary<br>ICSProjectionData.AnnualCreationEC_SNWP_Preliminary";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsDomesticOrQuantifiedOrFloodControl"(  ) ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: unknown<br><br>S.Baker, 20200309: Add description. Added SetNegativeToZero() to replace Max(0 &quot;acre-ft&quot;, xxxx). Added function IsMeadAboveDCPRecoveryElevation() to replace frequently used boolean. <br><br><br>S. Baker, 20200311: Add function IsDomesticOrQuantifiedOrFloodControl() & IsDomesticSurplus() to replace Or statement to improve readability. Replace OR statement with & IsLBorDCPconditionChanged().<br>APivarnik, 20200501: Moved Above Hoover trigger set assignment to this rule. Moved from SNWP Demand Variability Rule (deleted)<br>A. Pivarnik, 20200713: Integration effort. This rule is written differently than in the 24 MS. It is more complex but covers the same rule logic as the 24 MS rule. A with/if statement were added to only check ICS Creation based on bank capacity in MTOM runs. Added StartYearDCP contribution function call to take into account not ending in the same tier as projected in the August 24 MS of the previous year. Removed ISMRM from RC4 execution constraint";
    BEGIN

      WITH_STATEMENT (LIST ICS = WITH NUMERIC PotentialICS = ( $ "AnnualWaterUse.NV_BasicApportionment" [] - ( $ "AnnualWaterUse.Nevada_Forecast1" [@"24:00:00 December 31, Current Year"] - $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] ) COMMENTED_BY "Non SNWA Water Use <br>" - IF ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000 )
 THEN
  $ "Shortage.State Shortage Volumes" [( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) - 1.00000000, "Nevada"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF - $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] * "MeadPumpingDemandVariabilityFactor"( @"24:00:00 December Max DayOfMonth, Current Year" ) ) COMMENTED_BY "ICS calculation based on annual apportionment and diversion calculation affected by demand variability   <br>" DO
  IF ( "IsStartYear"(  ) )
  THEN
   WITH NUMERIC StartYearDCPContribution = ( GET @INDEX 0.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "NV" ) ) COMMENTED_BY "This function splits the DCP contribution in the start year into two values, the DCP contribution <br>that must go into a DCP account, and a volume (if applicable) which must be met but does not <br>qualify as DCP ICS (i.e. 2020). Since this second volume, the MandatedNonDCPICSContribution, <br>is not met using the typical logic of converting exitisting EC ICS to DCP ICS, it must be met with <br>the potential creation of EC ICS in the current year. If the potential ICS creation volume is <br>greater than the MandatedNonDCPICSContribution, then it will not force ICS delivery to meet the <br>demand in the start year.  <br>" DO
    { ( PotentialICS + IF ( PotentialICS <= 0.00000000 "acre-ft" )
    THEN
     StartYearDCPContribution * - 1.00000000
    ELSE
     0.00000000 "acre-ft"
    ENDIF COMMENTED_BY "#1 in note above. If there is delivery of ICS, the potential ICS is negative. <br>" ) COMMENTED_BY "If potential ICS is negative (delivery), add the full DCP contribution that is required as EC ICS to <br>the delivery amount, else its 0  <br>" , IF ( PotentialICS >= 0.00000000 "acre-ft" )
    THEN
     "Max"( StartYearDCPContribution - PotentialICS * "SystemTaxAdjustment_DCP"(  ), 0.00000000 "acre-ft" )
    ELSE
     0.00000000 "acre-ft" COMMENTED_BY "#3 in note above <br>"
    ENDIF COMMENTED_BY "The second part of this list covers the scenarios when ICS is being created.<br><br>If creating ICS, this is the adjustment to cover the required DCP contribution if the ICS created <br>does not cover the full amount (adjustment value for number 2 in note above)  <br>" }
   ENDWITH COMMENTED_BY "3 scenarios in start year that need to be taken into consideration if there is a mandated DCP <br>contribution that does not go into the DCP ICS account (i.e. 2020).<br><br>1) If already taking delivery of ICS, SNWA has to take additional ICS delivery equal to the <br>required system water contribution to meet the DCP requirement and meet the water <br>demands<br><br>2) If SNWA is creating ICS but not enough to cover the DCP requirement, SNWA will have to <br>take additional ICS delivery equal to the amount of system water needed to meet the dcp <br>contribution not met by the ICS creation and to still meet their demand<br><br>3) SNWA does not need to take any additional ICS delivery because the DCP contribution is <br>already being met by the ICS creation for the current year (demands are sufficiently low)   <br>"
  ELSE
   { PotentialICS , 0.00000000 "acre-ft" } COMMENTED_BY "Second element is the adjustment value, and in an outyear that adjustment is 0. <br>"
  ENDIF
 ENDWITH) DO
            WITH_STATEMENT (NUMERIC SNWPprelimDelivery = "MinItem"( { IF ( "IsDomesticSurplus"(  ) )
 THEN
  "SetNegativeToZero"( "Abs"( "Min"( GET @INDEX 0.00000000 FROM ICS, 0.00000000 "acre-ft" ) ) - $ "Surplus Volume Entitlements.SNWA Domestic" ["Dec31ofYear"( @"t" )] ) COMMENTED_BY "For domestic surplus, reduce ICS delivery by the amount of surplus entitlement for SNWP<br>"
 ELSE
  ( "Abs"( "Min"( GET @INDEX 0.00000000 FROM ICS, 0.00000000 "acre-ft" ) ) + GET @INDEX 1.00000000 FROM ICS ) COMMENTED_BY "No surplus <br>"
 ENDIF , $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Delivery"] COMMENTED_BY "Max possible delivery <br>" , IF ( "IsMeadAboveDCPRecoveryElevation"( @"24:00:00 December 31, Previous Year" ) )
 THEN
  $ "ICS Credits.TotalICS_NV" [@"24:00:00 December 31, Previous Year"]
 ELSE
  $ "ICS Credits.TotalICS_NV" [@"24:00:00 December 31, Previous Year"] - $ "ICS Credits.DCPICS_NV" [@"24:00:00 December 31, Previous Year"]
 ENDIF COMMENTED_BY "Total available ICS to take in delivery scenario <br>" } )) DO
          DESCRIPTION          "If ICS <0> is negative, then ICS is being delivered <br>";
      $ "ICSProjectionData.AnnualICSDelivery_NV_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] := SNWPprelimDelivery;

            WITH_STATEMENT (NUMERIC NVavailBankPreTax = "SetNegativeToZero"( ( ( $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Capacity"] - $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) - ( $ "ICS Credits.Bank_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) / "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] )) DO
            WITH_STATEMENT (NUMERIC MaxCreationBasedonCapacity = IF ( ( "Is24MonthStudy"(  ) OR NOT "IsMRM"(  ) ) COMMENTED_BY "Don't check against the bank in 24 MS or in an MTOM deterministic run <br>" )
 THEN
  1000000.00000000 "acre-ft" COMMENTED_BY "Extremely high value so this option can never be chosen in the min statement below<br>"
 ELSE
  NVavailBankPreTax COMMENTED_BY "Only check ICS creation based on bank capacity in MTOM modes  <br>"
 ENDIF) DO
          DESCRIPTION          "If ICS <0> is positive then there is ICS creation <br>";
      WITH_STATEMENT (NUMERIC SNWPprelimCreation = IF ( "IsQuantifiedOrFloodControl"(  ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "MinItem"( { "SetNegativeToZero"( GET @INDEX 0.00000000 FROM ICS ) , $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Creation"] , MaxCreationBasedonCapacity COMMENTED_BY "Max EC ICS creation based on bank availability<br>" } )
 ENDIF) DO
          DESCRIPTION          "Preliminary ICS value <br>";
      $ "ICSProjectionData.AnnualCreationEC_SNWP_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] := SNWPprelimCreation;

          DESCRIPTION          "The amount of NV basic apportionment that can not be stored in Mead as ICS, thus will be <br>divereted offstream and stored by NV. This diversion adjustment occurs in the NV diversion rule.  <br>";
      $ "ICS Credits.AnnualNevadaStoredOffstream" [@"24:00:00 December Max DayOfMonth, Current Year"] := "SetNegativeToZero"( GET @INDEX 0.00000000 FROM ICS ) - SNWPprelimCreation;

          DESCRIPTION          "This slot is the amount of bank space available to NV after the preliminary ICS creation. While  <br>logic exists for additional creation of ICS to meet a DCP contribution later on in the ruleset; it <br>is assumed that this will not occur in the near future due to the bank balance being so high.<br><br>The remaining bank balance is calculated and stored in this slot, which is used at a later point <br>to determine how much of the current years Tributary ICS needs to be delivered because it <br>won't fit into the bank upon Jan 1 conversion the following year. <br><br>Ex. If the slot's value is greater than the amount of Trib created, then all the trib will stay in <br>Mead. If the amount is < trib volume but > 0, some amount of tributary ICS will be stored in <br>Mead to be converted the following year and the rest will be diverted offstream. If the value <br>is 0, there is no bank space, thus the whole tributary ICS amount created during the current <br>year will be stored offstream. This math occurs in the ICS delivery rule which sets the Annual <br>Tributary ICS delivery slot.   <br>";
      $ "ICS Credits.AnnualNevadaBankSpaceforTrib" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( MaxCreationBasedonCapacity - SNWPprelimCreation ) * "SystemTaxAdjustment_DCP"(  ) + SNWPprelimDelivery;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    DESCRIPTION          "There is no demand variabiity logic in the 24 MS. This is MTOM only <br>";
      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( "MeadPumpingDemandVariabilityFactor"( @"24:00:00 December Max DayOfMonth, Current Year" ) == 1.00000000 )
 THEN
  0.00000000
 ELSE
  IF ( "MeadPumpingDemandVariabilityFactor"( @"24:00:00 December Max DayOfMonth, Current Year" ) == 0.95000000 )
  THEN
   1.00000000
  ELSE
   - 1.00000000
  ENDIF
 ENDIF;

    END
    UUID "{5d5e351e-06c4-4fc7-995b-88253e582c4a}";;

    RULE                 "MWD ICS Creation and Delivery";
    DESCRIPTION          "DESCRIPTION: This rule sets ICS deliveries and creation for MWD. If it is the start year and April-December, the ICS creation and delivery (bi-national, system efficiency, extraordinary conservation) will be set to the default value passed from the 24MS. Otherwise, ICS delivery will be the minimum of the default based on the Sac WY type and LB conditions, the maximum ICS take based on Mead pool elevation, and capped at canal capacity. ICS creation is minimum constrained by the Sac WY type and LB conditions, the remaining space to bank ICS in Mead by MWD, the maximum annual creation by MWD, and the diversion requested that is above their annual delivery.<br><br>EXECUTION CONSTRAINTS: This rule fires under two different sets of conditions: (1) if it is the start timestep or January, it is run cycle 3, and this rule has not fired successfully; or (2) if it is January and run cycle 4, the model is run in MRM mode, and the Lower Basin condition has changed between run cycle 3 and 4, or it is quantified surplus or flood control, or the Mexico Binational Water Scarcity Contingency Plan condition has changed. <br><br>SLOTS SET: <br>ICSProjectionData.AnnualCreationEC_MWD_Preliminary<br>ICSProjectionData.AnnualICSDelivery_MWD_Preliminary";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsDomesticOrQuantifiedOrFloodControl"(  ) ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>TP, 20171218: In domestic surplus, reduce the ICS Delivery by the amount of Domestic surplus entitlement for MWD. Make sure the amount of Delivery taken is within the MWD ICS bank or below the Maximum Take that MWD can have.<br>AP, 20191921: Updated for DCP. Added constraint for max available ICS limited based on recovery elevation for DCP.<br>S.Baker, 20200309: Updated and edited description. Added WITH statement for SacWY_Take. Added SetNegativeToZero() to replace Max(0 &quot;acre-ft&quot;, xxxx). Added function IsMeadAboveDCPRecoveryElevation() to replace frequently used boolean. <br>S. Baker, 20200311: Add function IsDomesticOrQuantifiedOrFloodControl() & IsDomesticSurplus() to replace Or statement to improve readability. Replace OR statement with & IsLBorDCPconditionChanged(). <br>GCAA, 20200330: Updated rule to constrain MWD's ICS delivery by the normal operational maximum (1.2 maf) in non-surplus years and annual canal capacity (1.25 maf) if in surplus years<br>A.Pivarnik, 20200423: Replace sum of MWD div requested with sim of Forecast use Reset annual and returns<br>A.Pivarnik, 20200511: Added TJ div into full ditch converyance calculation<br>A.Pivarnik, 20200713: Integration effort. Added Is24MonthStudy function call to the first if statement. This way the ruleset always uses the default values when in 24 MS mode. Replaced default value for 3 types of MWD ICS delivery with an ICS default slot for MWD. Removed ISMRM from RC4 execution constraint<br>";
    BEGIN

      IF_STATEMENT (( "IsAPRtoDECofStartYear"(  ) OR NOT "IsMRM"(  ) ) OR "Is24MonthStudy"(  )) THEN
          DESCRIPTION          "If April-December in start year or not a MRM run, use the default value passed from the 24 MS <br>";
      $ "ICSProjectionData.AnnualCreationEC_MWD_Preliminary" ["Dec31ofYear"( @"t" )] := $ "ICSProjectionData.AnnualCreationEC_MWD_Default" ["Dec31ofYear"( @"t" )];

            $ "ICSProjectionData.AnnualICSDelivery_MWD_Preliminary" ["Dec31ofYear"( @"t" )] := $ "ICSProjectionData.AnnualICSDelivery_MWD_Default" ["Dec31ofYear"( @"t" )];

      ELSE
            WITH_STATEMENT (LIST IIDAccounting = "ICSAccountingForIID"(  )) DO
            $ "ICSProjectionData.AnnualICSDelivery_MWD_Preliminary" ["Dec31ofYear"( @"t" )] := "MinItem"( { WITH NUMERIC SacWY_Take = $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December Max DayOfMonth, Current Year"] ) - 1.00000000, "Take Step 1"] DO
  IF ( "IsDomesticSurplus"(  ) COMMENTED_BY "In domestic surplus, reduce the ICS Delivery by the amount of domestic surplus entitlement for MWD.  <br>" )
  THEN
   "SetNegativeToZero"( SacWY_Take - $ "Surplus Volume Entitlements.MWD Domestic" ["Dec31ofYear"( @"t" )] )
  ELSE
   SacWY_Take COMMENTED_BY "Not Surplus or Shortage <br>"
  ENDIF
 ENDWITH , IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December Max DayOfMonth, Previous Year" ) <= $ "Surplus.Domestic Surplus Trigger Elevation" [] )
 THEN
  $ "AnnualWaterUse.MWD_NormalOpMax" [] - ( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "California_CU_Forecast1.MWDReturns" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December Max DayOfMonth, Current Year"] )
 ELSE
  $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - ( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "California_CU_Forecast1.MWDReturns" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December Max DayOfMonth, Current Year"] )
 ENDIF COMMENTED_BY "MWD at full ditch (Conveyance Capacity)<br>" , "Min"( ( $ "ICS Credits.MeadBankParameters" ["California", "Max Delivery"] - ( ( GET @INDEX 0.00000000 FROM IIDAccounting ) + GET @INDEX 1.00000000 FROM IIDAccounting ) ) COMMENTED_BY "Available ICS delivery amount left for MWD based on other user delivery in CA <br>", IF ( "IsMeadAboveDCPRecoveryElevation"( @"24:00:00 December Max DayOfMonth, Previous Year" ) )
 THEN
  $ "ICS Credits.TotalICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"]
 ELSE
  $ "ICS Credits.TotalICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"]
 ENDIF COMMENTED_BY "Total available ICS for delivery limited by DCP recovery elevation. EC ICS creation and delivery are mutually <br>exclusive (either create or deliver, not both). <br>" ) COMMENTED_BY "Available ICS Water <br>" } );

            $ "ICSProjectionData.AnnualCreationEC_MWD_Preliminary" ["Dec31ofYear"( @"t" )] := IF ( "IsDomesticOrQuantifiedOrFloodControl"(  ) COMMENTED_BY "No ICS creation if a Quantified Surplus, Flood Control, or DCP<br>" )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "MinItem"( { $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December Max DayOfMonth, Current Year"] ) - 1.00000000, "Put Step 1"] COMMENTED_BY "Annual Max <br>" , "SetNegativeToZero"( ( ( ( $ "ICS Credits.MeadBankParameters" ["MWD", "Max Capacity"] - $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) - ( $ "ICS Credits.Bank_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) / "SystemTaxAdjustment_DCP"(  ) ) COMMENTED_BY "Taxable ICS creation space <br>" + $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] COMMENTED_BY "Non Taxable ICS creation space. If EC delivery is paid back the following year, creation amount <br>equal to said delivery is not taxed   <br>" ) COMMENTED_BY "Bank space <br>" , ( $ "ICS Credits.MeadBankParameters" ["California", "Max Creation"] - GET @INDEX 2.00000000 FROM IIDAccounting ) COMMENTED_BY "Maximum Creation of MWD ICS <br>" , "SetNegativeToZero"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "California_CU_Forecast1.MWDReturns" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "AnnualWaterUse.MWDMinimumAnnualDelivery" [] ) COMMENTED_BY "Difference between Diversion Requests and Minimum Required MWD Delivery <br>" } )
 ENDIF;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{c16ff88f-1baa-46a3-9410-6ba82373f4a6}";;

    RULE                 "CAP ICS Creation and Delivery";
    DESCRIPTION          "DESCRIPTION: This rule sets ICS deliveries for CAWCD. If it is the start year and April-December, the ICS delivery will be set to the default value from the 24MS. Otherwise, determine the ICS delivery desired for CAWCD, and restrict delivery to not take more water than is banked in Mead (minus non-CAWCD ICS) based on pool elevation and capping the delivery at canal capacity. <br><br>EXECUTION CONSTRAINTS: This rule fires under two different sets of conditions: (1) if it is the start timestep or January, it is run cycle 3, and this rule has not fired successfully; or (2) if it is January and run cycle 4, the model is run in MRM mode, and the Lower Basin condition has changed between run cycle 3 and 4, or it is quantified surplus or flood control, or the Mexico Binational Water Scarcity Contingency Plan condition has changed. <br><br>SLOTS SET: <br>ICSProjectionData.AnnualICSDelivery_CAWCD_Preliminary";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsQuantifiedOrFloodControl"(  ) ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20200309: Updated and edited description.<br>S.Baker, 20200310: Removed Min() inside MinItem() to reduce redundancy. Added function IsMeadAboveDCPRecoveryElevation() to replace frequently used boolean. <br>S.Baker, 20200311: Add function IsDomesticOrQuantifiedOrFloodControl() to replace Or statement to improve readability. Replace OR statement with & IsLBorDCPconditionChanged().<br>A.Pivarnik, 20200416: Removed execution constraint which cause rule to fire in RC 4 if the model is in domestic surplus <br>A.Pivarnik, 20200713: Integration effort. Added if statement and Is24MSStudy Function call to use the default delivery + any other delivery determined by functions in outyears for 24 MS mode. Renamed rule from AZ to CAP ICS Creation and Delivery. Added ICS creation logic for MTOM to check against bank space, max creation or default value. This is part of the AZ ICS/Accounting overhaul. Removed ISMRM from RC4 execution constraint<br>";
    BEGIN

      WITH_STATEMENT (NUMERIC outyearICSdelivery = IF ( "IsStartYear"(  ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "CAWCD Mitigation Water"(  ) + "CAWCD DCP ICS Delivery"(  ) + "CAWCD Post 2026 ICS Delivery"(  )
 ENDIF) DO
            IF_STATEMENT (( "Is24MonthStudy"(  ) OR NOT "IsMRM"(  ) ) COMMENTED_BY "If April-December in start year or not a MRM run, use the default value passed from the 24 MS  <br>") THEN
            $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"] + outyearICSdelivery;

            $ "ICSProjectionData.AnnualCreationEC_CAWCD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICSProjectionData.AnnualCreationEC_CAWCD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"];

      ELSE
            WITH_STATEMENT (NUMERIC AnnualICSDelivery = ( $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"] + outyearICSdelivery ) COMMENTED_BY "Determine Annual ICS delivery volume using default value from 24 MS and functions for any extra needed <br>") DO
            WITH_STATEMENT (NUMERIC NonCAPICSDelivery = ( $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] ) COMMENTED_BY "Sum of non CAP ICS delivery for AZ. All inputs from 24MS, no delivery logic for other entities as <br>of 1/28/20 <br>") DO
            $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] := "MinItem"( { AnnualICSDelivery COMMENTED_BY "Annual ICS delivery calculated based on functions + value passed from 24MS <br>" , "CAWCD Available Canal Space"(  ) COMMENTED_BY "CAP at full ditch (Conveyance Capacity)<br>" , ( $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Delivery"] - NonCAPICSDelivery ) COMMENTED_BY "Available ICS delivery volume in AZ left for CAWCD based on state volume less other users <br>" , IF ( "IsMeadAboveDCPRecoveryElevation"( @"24:00:00 December 31, Previous Year" ) )
 THEN
  $ "ICS Credits.TotalICS_CAWCD" [@"24:00:00 December 31, Previous Year"]
 ELSE
  $ "ICS Credits.TotalICS_CAWCD" [@"24:00:00 December 31, Previous Year"] - $ "ICS Credits.DCPICS_CAWCD" [@"24:00:00 December 31, Previous Year"]
 ENDIF COMMENTED_BY "Available ICS for delivery. EC ICS creation and delivery are mutually exclusive (either create or <br>delivery, not both). Max available ICS now limited based on recovery elevation for DCP AP <br>11/19/19        <br>" } );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC AnnualICSCreation = "MinItem"( { "SetNegativeToZero"( ( ( ( $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Capacity"] - $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) - ( $ "ICS Credits.Bank_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.ExtraordinaryConservationICS_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] COMMENTED_BY "Non cap water user bank is equal to the EC ICS balance of the current year <br>" + $ "ICS Credits.ExtraordinaryConservationICS_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.ExtraordinaryConservationICS_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualCreationBiNat_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) / "SystemTaxAdjustment_DCP"(  ) ) COMMENTED_BY "Taxable ICS creation space <br>" + $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] COMMENTED_BY "Non Taxable ICS creation space. If EC delivery is paid back the following year, creation amount <br>equal to said delivery is not taxed   <br>" ) COMMENTED_BY "Bank space <br>" , $ "ICSProjectionData.AnnualCreationEC_CAWCD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"] , ( $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Creation"] - $ "ICS Credits.AnnualCreationEC_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualCreationEC_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualCreationEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualCreationEC_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] ) COMMENTED_BY "Maximum Creation of CAP ICS  <br>" } )) DO
            $ "ICSProjectionData.AnnualCreationEC_CAWCD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] := AnnualICSCreation;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{ff4606ef-0ef2-43e0-bcdf-caaa1f19fbc4}";;

    RULE                 "AZ (non CAP) Water User EC ICS Accounting";
    DESCRIPTION          "Rule created during integration effort and AZ ICS/Accounting overhaul<br><br>Solves for Annual EC ICS creation and balances for non CAP AZ users. This rule provides the neccessary information to solve for CAP EC ICS creation correctly in the following rule<br><br>APivarnik 20200714";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( "IsLBorDCPconditionChanged"(  ) OR "IsQuantifiedOrFloodControl"(  ) ) );
    NOTES                "";
    BEGIN

    DESCRIPTION          "This rule sets EC creation for non CAP AZ water users. It does this by trying to fit each default <br>ICS entry into the bank in the following order:<br><br>CRIT<br>GRIC<br>MVIDD<br>WM<br><br>After calculating each EC ICS creation volume, the rule then sets the annual creation volume and <br>calculates the EOY EC ICS balance for each water user.   <br>";
      WITH_STATEMENT (NUMERIC AnnualCreationEC_CRIT = IF ( "IsQuantifiedOrFloodControl"(  ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  IF ( "Is24MonthStudy"(  ) OR NOT "IsMRM"(  ) )
  THEN
   $ "ICSProjectionData.AnnualCreationEC_CRIT_Default" [@"24:00:00 December Max DayOfMonth, Current Year"]
  ELSE
   "FitDefaultECICSIntoBank"( $ "ICSProjectionData.AnnualCreationEC_CRIT_Default" [@"24:00:00 December Max DayOfMonth, Current Year"], $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona", $ "ICS Credits.Bank_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"], 0.00000000 "acre-ft" )
  ENDIF
 ENDIF) DO
            WITH_STATEMENT (NUMERIC AnnualCreationEC_GRIC = IF ( "IsQuantifiedOrFloodControl"(  ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  IF ( "Is24MonthStudy"(  ) OR NOT "IsMRM"(  ) )
  THEN
   $ "ICSProjectionData.AnnualCreationEC_GRIC_Default" [@"24:00:00 December Max DayOfMonth, Current Year"]
  ELSE
   "FitDefaultECICSIntoBank"( $ "ICSProjectionData.AnnualCreationEC_GRIC_Default" [@"24:00:00 December Max DayOfMonth, Current Year"], $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona", $ "ICS Credits.Bank_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Current Year ECICS into Bank"( AnnualCreationEC_CRIT, $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) )
  ENDIF
 ENDIF) DO
            WITH_STATEMENT (NUMERIC AnnualCreationEC_MVIDD = IF ( "IsQuantifiedOrFloodControl"(  ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  IF ( "Is24MonthStudy"(  ) OR NOT "IsMRM"(  ) )
  THEN
   $ "ICSProjectionData.AnnualCreationEC_MVIDD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"]
  ELSE
   "FitDefaultECICSIntoBank"( $ "ICSProjectionData.AnnualCreationEC_MVIDD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"], $ "ICS Credits.AnnualDeliveryEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona", $ "ICS Credits.Bank_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"], ( "Current Year ECICS into Bank"( AnnualCreationEC_CRIT, $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) + "Current Year ECICS into Bank"( AnnualCreationEC_GRIC, $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) ) )
  ENDIF
 ENDIF) DO
            WITH_STATEMENT (NUMERIC AnnualCreationEC_WM = IF ( "IsQuantifiedOrFloodControl"(  ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  IF ( "Is24MonthStudy"(  ) OR NOT "IsMRM"(  ) )
  THEN
   $ "ICSProjectionData.AnnualCreationEC_WM_Default" [@"24:00:00 December Max DayOfMonth, Current Year"]
  ELSE
   "FitDefaultECICSIntoBank"( $ "ICSProjectionData.AnnualCreationEC_WM_Default" [@"24:00:00 December Max DayOfMonth, Current Year"], $ "ICS Credits.AnnualDeliveryEC_WM" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona", $ "ICS Credits.Bank_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"], ( "Current Year ECICS into Bank"( AnnualCreationEC_CRIT, $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) + "Current Year ECICS into Bank"( AnnualCreationEC_GRIC, $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) + "Current Year ECICS into Bank"( AnnualCreationEC_MVIDD, $ "ICS Credits.AnnualDeliveryEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) ) )
  ENDIF
 ENDIF) DO
            WITH_STATEMENT (LIST AZFiming = "AZ Firming Agreement"(  )) DO
            $ "ICS Credits.AnnualCreationEC_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] := AnnualCreationEC_GRIC;

            $ "ICS Credits.ExtraordinaryConservationICS_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( $ "ICS Credits.ExtraordinaryConservationICS_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year ECICS into Bank"( AnnualCreationEC_GRIC, $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) - $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December 31, Current Year"] ) - GET @INDEX 0.00000000 FROM AZFiming;

      END_WITH_STATEMENT;

            $ "ICS Credits.AnnualCreationEC_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] := AnnualCreationEC_CRIT;

            $ "ICS Credits.ExtraordinaryConservationICS_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( $ "ICS Credits.ExtraordinaryConservationICS_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year ECICS into Bank"( AnnualCreationEC_CRIT, $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) - $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] );

            $ "ICS Credits.AnnualCreationEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] := AnnualCreationEC_MVIDD;

            $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year ECICS into Bank"( AnnualCreationEC_MVIDD, $ "ICS Credits.AnnualDeliveryEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) - $ "ICS Credits.AnnualDeliveryEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] );

            $ "ICS Credits.AnnualCreationEC_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] := AnnualCreationEC_WM;

            $ "ICS Credits.ExtraordinaryConservationICS_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( $ "ICS Credits.ExtraordinaryConservationICS_WM" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year ECICS into Bank"( AnnualCreationEC_WM, $ "ICS Credits.AnnualDeliveryEC_WM" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) - $ "ICS Credits.AnnualDeliveryEC_WM" [@"24:00:00 December 31, Current Year"] );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{13953c90-afe5-464e-84c0-2654d5bb5b69}";;

  END
  UUID "{7d23b72b-fd8b-40be-8e47-056a0c6b9de8}";;

  POLICY_GROUP   "Shortage";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Outyear Shortage Volumes";
    DESCRIPTION          "Sets outyear shortage volumes for SNWA, CAP and Mexico";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "IsJANofOutyear"(  ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "IsLBorDCPconditionChanged"(  ) );
    NOTES                "";
    BEGIN

    DESCRIPTION          "Set outyear shortage volumes for CAP, SNWA and MX <br>";
      $ "Mexico Shortage and Surplus.Mexico Annual Shortage" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( $ "Shortage.Shortage Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] > 0.00000000 )
 THEN
  $ "Mexico Shortage and Surplus.Mexico Shortage Volumes" [$ "Shortage.Shortage Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] - 1.00000000, "Mexico"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

      $ "Shortage.CAP Annual Shortage Volume" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( $ "Shortage.Shortage Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] > 0.00000000 )
 THEN
  $ "Shortage.State Shortage Volumes" [$ "Shortage.Shortage Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] - 1.00000000, "Arizona"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

      $ "Shortage.SNWP Annual Shortage Volume" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( ( $ "Shortage.Shortage Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] ) > 0.00000000 )
 THEN
  $ "Shortage.State Shortage Volumes" [( $ "Shortage.Shortage Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] ) - 1.00000000, "Nevada"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

    END
    UUID "{c9d32adb-af95-41e4-9ada-40f25c37c3c7}";;

  END
  UUID "{18926ca0-7d63-4131-9528-7579068d3f76}";;

  POLICY_GROUP   "LB Surplus";
  DESCRIPTION    "This policy group contains the rules required to simulate Lower Basin Surplus operations. Lower Basin Surplus operations are based on the 2007 Interim Guidelines as well as IBWC Minute 323. Surplus volume entitlements are based on contracts between Reclamation and the various water users, as well as the 2007 Interim Guidelines and Minute 323.<br><br>This policy group works in the following way. Solves LB surplus entitlements for water users, then sets surplus schedules based on the following criteria:<br><br>Water user has DS, QS, and FC surplus entitlements (JP users + GMF and AZPumpBlwImp)<br>Water User has QS an FC surplus entitlements<br>Water user only has FC entitlements";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set User Surplus  Schedule - FC Only";
    DESCRIPTION          "This rule sets total annual schedules for users that have quantified and flood control surplus entitlments. Created during the redo of the surplus logic during the 24 MS - MTOM integration effort<br><br>Users set in the rule: Mexico, Needles, CAPumpersAboveImp";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [] AND "IsJANofOutyear"(  ) AND "GetRunCycleIndex"(  ) >= 3.00000000 );
    NOTES                "Mexico non FC surplus set in the Mexico Shortage and Suprlus. Annual Surplus Volume slot (Set Outyear Surplus Entitlement for Mexico rule)<br><br>APivarnik, 20201001: Changed run constraint to fire if RC > 3. Removed RC4 + condition changed constraint<br>";
    BEGIN

      WITH_STATEMENT (NUMERIC SurplusType = NaNToZero ( $ "Surplus.Surplus Flag" [@"24:00:00 December 31, Current Year"] )) DO
            FOREACH (SLOT user IN "SurplusUsers_FConly"(  )) DO
            IF_STATEMENT (NaNToZero ( $ "Surplus.Surplus Flag" [@"24:00:00 December 31, Current Year"] ) <= 2.00000000) THEN
            user [@"24:00:00 December 31, Current Year"] := 0.00000000 "acre-ft";

      ELSE
            IF_STATEMENT ("GetSlotName"( user ) == "Mexico") THEN
            user [@"24:00:00 December 31, Current Year"] := $ "Mexico Shortage and Surplus.Mexico Flood Control Delivery" [];

      ELSE
            user [@"24:00:00 December 31, Current Year"] := % "California_CU_Forecast1" & "GetSlotName"( user ) [@"24:00:00 December 31, Current Year"] + % "Surplus Volume Entitlements" & "GetSlotName"( user ) [@"24:00:00 December 31, Current Year"];

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

    END
    UUID "{7186129e-dcf8-4366-b0b9-cb432ae0eed1}";;

    RULE                 "Set User Surplus  Schedule -  QS, FC";
    DESCRIPTION          "This rule sets total annual schedules for users that have quantified and flood control surplus entitlments. Created during the redo of the surplus logic during the 24 MS - MTOM integration effort<br><br>Users set in the rule: Coachella, IID, City of Parker, Cibola Valley IID";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [] AND "IsJANofOutyear"(  ) AND "GetRunCycleIndex"(  ) >= 3.00000000 );
    NOTES                "APivarnik, 20201001: Changed run constraint to fire if RC > 3. Removed RC4 + condition changed constraint<br>";
    BEGIN

      WITH_STATEMENT (NUMERIC SurplusType = NaNToZero ( $ "Surplus.Surplus Flag" [@"24:00:00 December 31, Current Year"] )) DO
            FOREACH (SLOT user IN "SurplusUsers_QSandFC"(  )) DO
            IF_STATEMENT (SurplusType <= 1.00000000) THEN
            user [@"24:00:00 December 31, Current Year"] := 0.00000000 "acre-ft";

      ELSE
            IF_STATEMENT ("GetSlotName"( user ) IN { "Coachella" , "IID" }) THEN
            WITH_STATEMENT (STRING scheduleType = IF ( SurplusType == 2.00000000 )
 THEN
  " Quantified"
 ELSE
  " FC"
 ENDIF) DO
            user [@"24:00:00 December 31, Current Year"] := % "California_CU_Forecast1" & "GetSlotName"( user ) [@"24:00:00 December 31, Current Year"] + % "Surplus Volume Entitlements" & "GetSlotName"( user ) CONCAT scheduleType [@"24:00:00 December 31, Current Year"];

      END_WITH_STATEMENT;

      ELSE
            user [@"24:00:00 December 31, Current Year"] := % "Arizona_CU_Forecast1" & "GetSlotName"( user ) [@"24:00:00 December 31, Current Year"] + % "Surplus Volume Entitlements" & "GetSlotName"( user ) [@"24:00:00 December 31, Current Year"];

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

    END
    UUID "{4281d46b-9b96-4481-babc-c2f63667a28f}";;

    RULE                 "Set User Surplus  Schedule -  DS, QS, FC";
    DESCRIPTION          "This rule sets total annual schedules for users that have domestic, quantified and flood control surplus entitlments. Created during the redo of the surplus logic during the 24 MS - MTOM integration effort<br><br>Users set in the rule: SNWA, MWD, CAP, Gila Monster Farms, AZPumpersBlwImperial";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [] AND "IsJANofOutyear"(  ) AND "GetRunCycleIndex"(  ) >= 3.00000000 );
    NOTES                "APivarnik, 20201001: Changed run constraint to fire if RC > 3. Removed RC4 + condition changed constraint<br>";
    BEGIN

      WITH_STATEMENT (NUMERIC SurplusType = NaNToZero ( $ "Surplus.Surplus Flag" [@"24:00:00 December 31, Current Year"] )) DO
            FOREACH (SLOT user IN "SurplusUsers_AllTypes"(  )) DO
            IF_STATEMENT (SurplusType == 0.00000000) THEN
            user [@"24:00:00 December 31, Current Year"] := 0.00000000 "acre-ft";

      ELSE
            IF_STATEMENT ("GetSlotName"( user ) IN "IsJPUser"(  )) THEN
            WITH_STATEMENT (STRING scheduleType = IF ( SurplusType == 1.00000000 )
 THEN
  " Domestic"
 ELSE
  " FC"
 ENDIF
 ELSEIF_COND ( SurplusType == 2.00000000 )
 ELSEIF_CLAUSE ( " Quantified" )
 END_ELSEIF) DO
            IF_STATEMENT ("GetSlotName"( user ) == "SNWA") THEN
          DESCRIPTION          "SNWA needs to be seperated out from the other JP's because the Nevada Apportionment <br>(demand) can be over the basic apportionment of 300 KAF. If over 300KAF and SNWA is  <br>potentially taking delivery of ICS, the ResetAnnualFC already takes that into account. For <br>example:<br><br>NV Demand = 320 KAF, the reset annual will be approx 310 KAF. If the surplus volume <br>entitlement (calculated in a previous rule) is added to the reset volume, SNWA will be taking <br>extra water  because the surplus volume also includes the extra water needed to meet the <br>demand above 300 KAF. More logic had to be developed in the cases of QS and FC because <br>SNWA has instructed reclamation to deliver ICS volumes whether above or below the basic <br>apportionment (no longer just meeting the demand).       <br>";
      user [@"24:00:00 December 31, Current Year"] := IF ( $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December Max DayOfMonth, Current Year"] > $ "AnnualWaterUse.NV_BasicApportionment" [] )
 THEN
  IF ( scheduleType == " Domestic" )
  THEN
   "Min"( $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"], $ "AnnualWaterUse.NV_BasicApportionment" [] - "Annual Sum Non SNWP Nevada Users"( @"24:00:00 December Max DayOfMonth, Current Year" ) + % "Surplus Volume Entitlements" & "GetSlotName"( user ) CONCAT scheduleType [@"24:00:00 December 31, Current Year"] )
  ELSE
   "Min"( $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"], $ "AnnualWaterUse.NV_BasicApportionment" [] - "Annual Sum Non SNWP Nevada Users"( @"24:00:00 December Max DayOfMonth, Current Year" ) ) + % "Surplus Volume Entitlements" & "GetSlotName"( user ) CONCAT scheduleType [@"24:00:00 December 31, Current Year"]
  ENDIF
 ELSE
  $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] + % "Surplus Volume Entitlements" & "GetSlotName"( user ) CONCAT scheduleType [@"24:00:00 December 31, Current Year"]
 ENDIF;

      ELSE
            user [@"24:00:00 December 31, Current Year"] := % "ForecastUse" & ( GET @INDEX FIND "GetSlotName"( user ) WITHIN "IsJPUser"(  ) FROM "IsJPUser"(  ) ) CONCAT "ResetAnnualFC" [@"24:00:00 December 31, Current Year"] + % "Surplus Volume Entitlements" & "GetSlotName"( user ) CONCAT scheduleType [@"24:00:00 December 31, Current Year"];

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            user [@"24:00:00 December 31, Current Year"] := % "Arizona_CU_Forecast1" & "GetSlotName"( user ) [@"24:00:00 December 31, Current Year"] + % "Surplus Volume Entitlements" & "GetSlotName"( user ) [@"24:00:00 December 31, Current Year"];

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

    END
    UUID "{3d10b2ad-9a20-4204-806d-4a18ab6f9e63}";;

    RULE                 "Set Quantified Surplus Entitlement Vols MWD, CAP, SNWA, CVWD, IID";
    DESCRIPTION          "DESCRIPTION: This rule distributes the volume of Quantified Surplus available between MWD and CAP. If California's Quantified Surplus volume is greater than the MWD's Domestic Surplus volume, the MWD Quantified Surplus volume is equal to the canal capacity minus the current water diversion requested, allowing MWD to take full canal capacity, otherwise MWD receives only the water entitled from the Domestic Surplus. The Quantified Surplus volume for CAP after 1992 (canal finished) is set based on the remaining Quantified Surplus volume available. If there is any remaining Quantified Surplus volume after the Gila Monster Farmers, the Arizona pumpers below Imperial, and the CAP Domestic Surplus take thier entitlement, CAP receives the remaining volume up to thier canal capacity.  Otherwise, they receive their Domestic Surplus volume.<br><br>EXECUTION CONSTRAINTS: This rule fires if the rule has not fired successfully in run cycle 3 and 4 and if the Quantified Surplus Volume greater than zero.<br><br>SLOTS SET: <br>Surplus Volume Entitlements.MWD Quantified<br>Surplus Volume Entitlements.CAP Quantified<br>Surplus Volume Entitlements.SNWA Quantified";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet" AND "IsJANofOutyear"(  );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker 06/20/2018: Added constraint to not allow Quantified surplus to be taken by CPAT prior to 1992.<br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from rule name. Replaced hardcoded MWD surplus entitlement values with reference to DefaultSurplusEntitlement slot<br>GCAA, 20200330: Added logic to determine SNWA's Quantified Surplus Entitlement.<br>S.Baker, 20200306: Edited rule description. <br><br>A. Pivarnik, 20200709: Integration effort. Added assignment/calculations for CVWD and IID quantified surplus schedules<br>A. Pivarnik,  20200803: Edited execution constraint to fire only in January of out years<br>A. Pivarnik, 20201106: Added city of parker and cibolavalley IID to Remaining QS calculation";
    BEGIN

    DESCRIPTION          "Based on the quantified surplus entitlement for each state, set individual surplus entitlements for <br>water users. <br>";
      WITH_STATEMENT (NUMERIC MWDQuantified = IF ( $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] )
 THEN
  "Min"( $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"], $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] ) COMMENTED_BY "Min of remaining canal capcity over the course of the yr or CA QS volume <br>"
 ELSE
  $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"]
 ENDIF) DO
            $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"] := MWDQuantified;

          DESCRIPTION          "If there is any QS vol left in CA, allow CVWD and IID to take QS entitlements <br>";
      IF_STATEMENT ($ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > MWDQuantified) THEN
            $ "Surplus Volume Entitlements.Coachella Quantified" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.Coachella" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 0.00000000];

            $ "Surplus Volume Entitlements.IID Quantified" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 1.00000000];

      ELSE
            $ "Surplus Volume Entitlements.Coachella Quantified" [@"24:00:00 December 31, Current Year"] := 0.00000000 "acre-ft";

            $ "Surplus Volume Entitlements.IID Quantified" [@"24:00:00 December 31, Current Year"] := 0.00000000 "acre-ft";

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      $ "Surplus Volume Entitlements.CAP Quantified" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) > 1992.00000000 )
 THEN
  WITH NUMERIC RemainingCanalCapacity = $ "AnnualWaterUse.CAPCanal_AnnualCapacity" [] - $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] DO
   WITH NUMERIC RemainingQS_AZ = $ "Surplus.Arizona Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] - ( $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.City of Parker" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] ) DO
    IF ( RemainingQS_AZ > 0.00000000 "acre-feet" )
    THEN
     "Min"( RemainingQS_AZ, RemainingCanalCapacity )
    ELSE
     $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"]
    ENDIF
   ENDWITH
  ENDWITH
 ELSE
  0.00000000 "acre-ft"
 ENDIF COMMENTED_BY "Testbed Hindcast Simulations - Prior to 1992 do not allow CAP to take water since canal was not <br>built  <br>";

      $ "Surplus Volume Entitlements.SNWA Quantified" [@"24:00:00 December 31, Current Year"] := ( IF ( $ "Surplus.Nevada Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December 31, Current Year"] )
 THEN
  "Min"( $ "Surplus.Nevada Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"], "Max"( $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.NV_BasicApportionment" [], 0.00000000 "acre-ft" ) )
 ELSE
  $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December 31, Current Year"]
 ENDIF + ( ( $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualCreationImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) * "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.DCPICS_NV" [@"24:00:00 December 31, Previous Year"] ) ) COMMENTED_BY "Original entitlement calculation <br>";

    END
    UUID "{662dfa55-5c5c-49c7-9015-5ad6055fd735}";;

    RULE                 "Set Domestic and FC Surplus Entitlement Vols for MWD, CVWD, IID";
    DESCRIPTION          "DESCRIPTION: For Domestic Surplus prior to 2017, MWD gets 1,250 KAF (canal capacity), minus the MWD Diversion to date and 1/3 of the Mexico annual surplus volume. For Domestic Surplus after 2017, if CAP and SNWA are taking domestic surplus, MWD gets 250 KAF less 1/3 the Mexico annual surplus value, otherwise NWD gets 250 kaf.  In a flood control year MWD is entitled to a full canal so their entitlement is the current diversion plus what it takes to fill the canal. <br><br>SLOTS SET:<br>Surplus Volume Entitlements.MWD Domestic<br>Surplus Volume Entitlements.MWD FC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015<br><br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from name, replaced hardcoded CAP surplus entitlement value with reference to Surplus Volume Entitlements.CAP Domestic slot, replaced hardcoded share of surplus by state value with ShareofMexicoSurplusbyState() function, and replaced CAP surplus entitlement value with reference to Surplus.Default Surplus Entitlements slot.<br>S.Baker, 20200306: Edited rule description. <br><br>A. Pivarnik, 20200709: Integration effort. Added RC >=3 for execution constraint. See comments for other potential changes. Moved additional calculations of surplus volume water from the set domestic suprlus schedules/set flood control schedules rule to this rule<br><br>A.Pivarnik, 20200803: Changed if condition for surplus entitlements to &quot;OR&quot;. Changed for loop summing MWD div requested to referencing the reset values<br>A.Pivarnik, 20201001: Changed if condition for surplus entitlements to &quot;AND&quot;. Removed TJ flows from MWD FC surplus vol calc";
    BEGIN

    DESCRIPTION          "Set CA domestic and flood control surplus entitlements. This rule sets the volume of extra water <br>available to MWD under flood control and domestic surplus, and  FC entitlements for Coachella <br>and IID. MWD's volume will be added to what they are currently taking in the Set User Surplus <br>Schedule - DS, QS, FC rule, whereas CVWD and IID will be adjusted under the QS, FC rule.     <br>";
      $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] := "Min"( ( IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
 THEN
  $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] - "ShareofMexicoSurplusbyState"(  ) * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December Max DayOfMonth, Current Year"]
 ELSE
  IF ( ( $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December Max DayOfMonth, Current Year"] > 0.00000000 "acre-ft" AND $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December Max DayOfMonth, Current Year"] > 0.00000000 "acre-ft" ) COMMENTED_BY "This conditional is an &quot;AND&quot; via the minute 323 implementation agreement <br>APivarnik 20201001 <br><br>Minute 323 interim operating agreement section 6.1.1.4 <br>" )
  THEN
   $ "Surplus.Default Surplus Entitlements" [0.00000000, 1.00000000] - "ShareofMexicoSurplusbyState"(  ) * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December Max DayOfMonth, Current Year"]
  ELSE
   $ "Surplus.Default Surplus Entitlements" [0.00000000, 1.00000000]
  ENDIF
 ENDIF COMMENTED_BY "Original entitlement calculation <br>" ) + $ "California_CU_Forecast1.MWDReturns" [@"24:00:00 December Max DayOfMonth, Current Year"] COMMENTED_BY "Additional water to take into account when finding volume domestic surplus volume to divert in a <br>year <br>", ( $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December Max DayOfMonth, Current Year"] ) COMMENTED_BY "Available space in canal after diversion and water for TJ <br>" );

      $ "Surplus Volume Entitlements.MWD FC" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Volume Entitlements.IID FC" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December Max DayOfMonth, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 1.00000000];

      $ "Surplus Volume Entitlements.Coachella FC" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December Max DayOfMonth, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 0.00000000] + 100000.00000000 "acre-ft" COMMENTED_BY "100 KAF comes from Coachella surplus contract  <br>";

    END
    UUID "{aff04063-da50-435d-872e-1a22a0d7fad4}";;

    RULE                 "Set Domestic and FC Surplus Entitlement Vols for SNWA";
    DESCRIPTION          "DESCRIPTION:  If the year is after 2017 and if Nevada's apportionment is greater than the Nevada basic apportionment (300 kaf) and less than Nevada's share of Mexico's surplus (1/3) then set the domestic surplus entitlement equal to that volume. If it is before 2017 or Nevada's apportionment is less than the basic apportionment then the domestic surplus entitlement is 0 acre-ft. If Nevada's apportionment is greater than the basic apportionment then that difference is the surplus flood control entitlement, otherwise it is 0 acre-ft.<br><br>SLOTS SET: <br>Surplus Volume Entitlements.SNWA Domestic<br>Surplus Volume Entitlements.SNWA FC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: GCAA, 20200330<br><br>A. Pivarnik, 20200709: Integration effort. Added execution constraint of RC >=3 so the rule does not fire in every timestep.  Moved additional calculations of  surplus volume water from the &quot;set domestic suprlus schedules&quot; and &quot;set flood control surplus schedules rule to this entitlement calculation rule";
    BEGIN

    DESCRIPTION          "This rule sets both the domestic and flood control surplus volume entitlements for SNWA. This <br>volume is added to their current year diversion in the Set User Surplus Schedule - DS, QS, FC <br>rule. Under domestic surplus, SNWA will only take extra water if the water demand is above the <br>states basic apportionment. Under flood control, if SNWA's use is below 300 KAF, SNWA will take <br>delivery of the entire DCP balance and all tributary/imported ICS available to store off stream. If <br>in flood control and SNWA is above 300 KAF, then meet the demand using the surplus water first, <br>then DCP, EC, TRIB and SE ICS. After the demand is met, DCP and imported/tributary will be <br>taken and stored off stream (see email from Casey Collins dated 2020/01/14).    <br>";
      $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December 31, Current Year"] := "Min"( IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "Min"( $ "Surplus.Default Surplus Entitlements" [0.00000000, 2.00000000] - "ShareofMexicoSurplusbyState"(  ) * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"], "Max"( $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.NV_BasicApportionment" [], 0.00000000 "acre-ft" ) )
 ENDIF COMMENTED_BY "original entitlement calculation <br>" + $ "ICS Credits.TotalICS_NV" [@"24:00:00 December 31, Previous Year"], "Max"( $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.NV_BasicApportionment" [], 0.00000000 "acre-ft" ) );

      $ "Surplus Volume Entitlements.SNWA FC" [@"24:00:00 December 31, Current Year"] := "Max"( $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.NV_BasicApportionment" [], 0.00000000 "acre-ft" ) + ( ( $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualCreationImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) * "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.DCPICS_NV" [@"24:00:00 December 31, Previous Year"] );

    END
    UUID "{416415a3-c8b7-4225-8922-dc0e84b338d0}";;

    RULE                 "Set Domestic and FC Surplus Entitlement Vols for CAP";
    DESCRIPTION          "DESCRIPTION: For Domestic Surplus after 2017, CAP receives 100 KAF, minus a 1/3 of the Mexico Annual Surplus, the Surplus entitlements for Gila Monster Farms, and AZ pumpers below Imperial.  If the system is in Flood Control, the CAP FC surplus volume is set to 1,835 KAF less the current CAP Diversion Request so that they are entitled to a full canal volume of 1,835 KAF in a year of Flood Control. <br><br>SLOTS SET: <br>Surplus Volume Entitlements.CAP Domestic<br>Surplus Volume Entitlements.CAP FC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015<br><br>GCAA, 20181030: Replaced hardcoded CAP default surplus entitlement value with reference to Surplus.Default Surplus Entitlements slot, replaced share of Mexico surplus by state value with ShareofMexicoSurplusbyState() function, and removed &quot;-Minute 323&quot; from rule name.<br>S.Baker, 20200306: Edited rule description. <br><br>A. Pivarnik, 20200709: Integration effort. Added execution constraint of RC >=3 so the rule does not fire in every timestep. Moved additional logic from the &quot;Set Flood Control Schedules rule&quot; to this rule for surplus logic reconstruction effort<br><br>A. Pivarnik, 20200803: Changed logic to always limit CAP to canal capacity in FC. No difference between run types";
    BEGIN

    DESCRIPTION          "Set CAP domestic and flood control surplus entitlements. This rule sets the volume of extra water <br>available to CAP under the two different surplus scenarios. This volume will be added to what <br>they are currently taking in the Set User Surplus Schedule - DS, QS, FC rule. Under domestic <br>surplus, CAP is allowed to take the AZ entitlement less other AZ users that also have domestic <br>surplus entitlements. Under flood control, CAP takes a full canal.        <br>";
      $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "Surplus.Default Surplus Entitlements" [0.00000000, 0.00000000] - "ShareofMexicoSurplusbyState"(  ) * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"] - ( $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] )
 ENDIF;

      $ "Surplus Volume Entitlements.CAP FC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.CAPCanal_AnnualCapacity" [] - $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"];

    END
    UUID "{cb1d29bd-a1c6-4f53-9311-a9939da062ea}";;

    RULE                 "Set Quantified Volumes by State";
    DESCRIPTION          "DESCRIPTION: This rule will distribute the total LB Quantified Surplus Volume among the Lower Basin states of AZ, CA, and NV. The distribution amounts (shares) are stored in a slot on the Surplus object.<br><br>EXECUTION CONSTRAINTS: This rule fires if there is a positive Quantified Surplus volume and if the run cycle is 3 and 4. <br><br>SLOTS SET: <br>Surplus.California Quantified Surplus Volume<br>Surplus.Arizona Quantified Surplus Volume<br>Surplus.Nevada Quantified Surplus Volume";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet" AND "IsJANofOutyear"(  );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011<br><br>S.Baker, 20200306: Edited rule description. <br><br>A. Pivarnik, 20200709: Integration effort. This rule was not changed as it is the same in the 24MS and MTOM.<br>A. Pivarnik,  20200803: Edited execution constraint to fire only in January of out years";
    BEGIN

    DESCRIPTION          "This rule sets the quantified surplus volumes for each state. This volume is used to calculate the <br>quantified surplus entitlments for water users <br>";
      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "Surplus" & ( state CONCAT " Quantified Surplus Volume" ) [@"24:00:00 December 31, Current Year"] := $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of Quantified Surplus by State" [0.00000000, state];

      ENDFOREACH;

    END
    UUID "{5b328700-3564-4714-b5ad-22cdf863945f}";;

    RULE                 "Set Outyear Surplus Entitlement for Mexico";
    DESCRIPTION          "DESCRIPTION: This rule uses the volume associated with the Mexico Surplus Flag to set the Mexico diversion request for surplus according to the Mexico Surplus Table. The shortage monthly percent is used to apply the surplus over the year. Also, set the annual surplus volume based on the surplus flag. <br><br>EXECUTION CONSTRAINTS: This rule fires in January as long as it is not the start timestep, and if the Mexico surplus flag for the current year is greater than zero. <br><br>SLOTS SET:<br>MexicanTreatyDelivery:MexicoSched.Diversion Requested<br>Mexico Shortage and Surplus.Mexico Annual Surplus";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsJANofOutyear"(  ) AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from rule name<br>S.Baker, 20200306: Edited rule description. <br>A. Pivarnik, 20200506: removed Mexico Div requested slot asssignment. Moved slot assignment to MX div adjustment rule higher in ruleset. Placed IsJanofOutyear function in execution constraint<br><br>A. Pivarnik, 202020709: Integration effort. This rule was not changed. The equivalent rule in the 24 MS sets the volume (as in this rule) and adjusts the diversion. The diversion adjustment in the integrated ruleset happens in the Mexico Diversion Adjustment rule higher in the ruleset. Added execution constraint to only run in RC >=3";
    BEGIN

    DESCRIPTION          "This rule sets the annual surplus volume for Mexico. The Mexico diversion is adjusted in the <br>Mexico Diversion Adjustment rule later on in the ruleset.    <br>";
      $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"] := IF ( $ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000 )
 THEN
  $ "Mexico Shortage and Surplus.Mexico Surplus Table" [$ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Volume"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

    END
    UUID "{f3dbd19c-a6c1-48f9-84f5-897b39f6ea58}";;

  END
  UUID "{cbb72186-2e5b-4e67-b3cf-19fc35925e1c}";;

  POLICY_GROUP   "DCP and BWSCP";
  DESCRIPTION    "This policy group is used to preliminarily set the contributions for California, Nevada, Arizona, and Mexico set by the U.S. Lower Basin Drought Contingency Plan (DCP) and Mexico Binational Water Scarcity Contingency Plan Savings (BWSCP; Minute 323). The contributions are based off the projected Mead pool elevation.";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "California DCP";
    DESCRIPTION          "DESCRIPTION:  This rule sets California's DCP contribution and determines whether the contribution can be made with existing EC ICS. The rule sets the amount of converted EC ICS to DCP ICS based on the total DCP contribution required and determines if there are remaining DCP contribution after all previous year's ICS has been converted. These values will be refined in later rules located in the ICS Accounting and Releases policy group.<br><br>NOTE: Coachella can not &quot;officially&quot; create DCP ICS. Instead DCP creation for Coachella will be done &quot;unofficially&quot; and held in MWD account. Coachella will reduce diversion by 7% to help CA meet DCP contribution and will be stored store in MWD's system. MWD to pay tax for now. No logic for Coachella besides 7% reduction to diversion to create water for MWD. CVWD account in MWD system will not be tracked, all DCP ICS will be assumed to be MWD. -AP 7/31/19     <br><br>CONSTRAINTS: The rule fires in run cycle 3 if it is January or the start timestep and the rule has not fired successfully. The rule fires in run cycle 4 if the DCP BWSCP flag has changed from run cycle 3 and only if it is January. <br><br>SLOTS SET: <br>ICS Credits.AnnualRemainingDCPContributions_MWD<br>ICS Credits.AnnualConversionPreviousECtoDCP_MWD<br>ICS Credits.AnnualSimultaneousCreationDCPICS_MWD [only if DCP contributions > 0]<br>ICS Credits.AnnualSysWaterforDCP_MWD [only if DCP contributions > 0]";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND $ "DCP BWSCP Flags.LB DCP BWSCP Check" ["Dec31ofYear"( @"t" )] != $ "DCP BWSCP Flags.LB DCP BWSCP" ["Dec31ofYear"( @"t" )] );
    NOTES                "AUTHOR: AP, 2020-01-01<br><br>EDITS: <br>S.Baker, 2020-03-05: edited comments and added description.<br><br>A. Pivarnik, 20200709: Integration effort. This rule was streamlined for the MTOM ruleset when created. It was written differently than the 24 MS rule but accomplishes the same thing. General structure for the rule did not change in the integration effort because the 24 MS ruleset is being merged into MTOM, and the MTOM structure is what solves correctly within this ruleset. Added a start year dcp creation function call to for solve the DCP creation volume in year 1 if we end in a DCP tier that is lower than the one projected by the 24 MS in August.";
    BEGIN

    DESCRIPTION          "MWD will take on the full amount of DCP contribution for the state of California and all <br>accounting works under this assumption. Since MWD is taking the full DCP contribution for the <br>state, any DCP contribution required by Coachella Valley will be water left on the system for <br>MWD to take as delivery. Any potential DCP ICS created by Coachella is considered an <br>intrastate deal, and thus is in the MWD balance.<br><br>This rule solves for part A below. <br><br>Per MWD's instructions,  DCP will be handled the following way:<br><br>(A) If available, convert existing EC ICS to meet the DCP contribution.<br><br>The value is stored in the AnnualConversionPreviousECtoDCP_MWD slot. If the existing EC <br>ICS can not cover the full DCP amount, then the model will store any remaining DCP <br>contribution in the AnnualRemainingDCPContribution_MWD slot.<br><br>(B) Reduce deliveries to simultaneously create DCP ICS until bank is filled. <br><br>Since the model  already has current year EC ICS creation which is solved for in a later rule, it <br>attempts to use this first prior to reducing the delivery further. This math happens in the <br>accounting rule using the AnnualRemainingDCPContribution_MWD slot.<br><br>(C) Create system water if there is no bank space (handled in the CA accounting rule)                     <br>";
      WITH_STATEMENT (NUMERIC AnnualDCPContribution = GET @INDEX 1.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "CA" )) DO
          DESCRIPTION          "If a DCP contribution is needed for the year, detemine how much can be covered by previously <br>created EC ICS. If there is any left over, store it in the AnnualRemainingDCPContribution_MWD <br>slot (Part A above).   <br>";
      IF_STATEMENT (AnnualDCPContribution > 0.00000000 "acre-ft") THEN
            WITH_STATEMENT (NUMERIC PreviousECtoDCP = "Min"( AnnualDCPContribution, $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] )) DO
            WITH_STATEMENT (NUMERIC RemainingContribution = IF ( AnnualDCPContribution == PreviousECtoDCP )
 THEN
  0.00000000 "acre-ft"
 ELSE
  AnnualDCPContribution - PreviousECtoDCP
 ENDIF) DO
            $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := PreviousECtoDCP;

            $ "ICS Credits.AnnualRemainingDCPContribution_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := RemainingContribution;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

            $ "ICS Credits.AnnualRemainingDCPContribution_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{c862f2bd-77c9-4b9d-957d-8c1f3f2b3bfe}";;

    RULE                 "Nevada DCP";
    DESCRIPTION          "DESCRIPTION:  This rule sets Nevada's DCP contribution and determines whether the contribution will be made as conversion of existing EC ICS (including previous year Imported or Tributary ICS creation) to DCP ICS or as scheduled reductions (simultaneous conversion or system water). The rule sets the amount of converted EC+Trib+Imported ICS to DCP ICS based on the total DCP contribution required and determines if there are remaining DCP contribution after all previous year's ICS has been converted. These values will be refined in later rules located in the ICS Accounting and Releases policy group.<br><br>CONSTRAINTS: The rule fires in run cycle 3 if it is January or the start timestep and the rule has not fired successfully. The rule fires in run cycle 4 if the DCP BWSCP flag has changed from run cycle 3 and only if it is January. <br><br>SLOTS SET: <br>ICS Credits.AnnualRemainingDCPContributions_NV<br>ICS Credits.AnnualConversionPreviousECtoDCP_NV";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND $ "DCP BWSCP Flags.LB DCP BWSCP Check" ["Dec31ofYear"( @"t" )] != $ "DCP BWSCP Flags.LB DCP BWSCP" ["Dec31ofYear"( @"t" )] );
    NOTES                "AUTHOR: AP, 2020-01-01<br><br>EDITS: <br>S.Baker, 2020-03-05: edited comments and added description.<br><br>A. Pivarnik, 20200709: Integration effort. This rule was streamlined for the MTOM ruleset when created. It was written differently than the 24 MS rule but accomplishes the same thing. General structure for the rule did not change in the integration effort because the 24 MS ruleset is being merged into MTOM, and the MTOM structure is what solves correctly within this ruleset. Added a start year dcp creation function call to for solve the DCP creation volume in year 1 if we end in a DCP tier that is lower than the one projected by the 24 MS in August.";
    BEGIN

    BREAKPOINT AFTER_EXEC FALSE;
    DESCRIPTION          "This rule does part A in the description below.<br><br>Per SNWA's instructions,  DCP will be handled the following way:<br><br>(A) If available, convert existing EC ICS to meet the DCP contribution. <br><br>The value is stored in the AnnualConversionPreviousECtoDCP_NV slot. If the existing EC ICS <br>can not cover the full DCP amount, then the model will store any remaining DCP contribution <br>in the AnnualRemainingDCPContribution_NV slot.<br><br>(B) Reduce deliveries to simultaneously create DCP ICS until bank is filled. <br><br>Since the model  already has current year EC ICS creation which is solved for in a later rule, it <br>attempts to use this first prior to reducing the delivery further. This math happens in the <br>accounting rule using the AnnualRemainingDCPContribution_NV slot.<br><br>(C) Create system water if there is no bank space (handled in the NV accounting rule)                    <br>";
      WITH_STATEMENT (NUMERIC AnnualDCPContribution = GET @INDEX 1.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "NV" )) DO
          DESCRIPTION          "If a DCP contribution is needed for the year, detemine how much can be covered by previously <br>created EC ICS. If there is any left over, store it in the AnnualRemainingDCPContribution_NV slot <br>(Part A above).   <br>";
      IF_STATEMENT (AnnualDCPContribution > 0.00000000 "acre-feet") THEN
            WITH_STATEMENT (NUMERIC PreviousECtoDCP = "Min"( AnnualDCPContribution, $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + ( $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December 31, Previous Year"] ) COMMENTED_BY "Imported and Tributary from the previous year included in the calculation because the balance <br>will be converted to EC ICS at EOCY   <br>" )) DO
            WITH_STATEMENT (NUMERIC RemainingContribution = IF ( AnnualDCPContribution == PreviousECtoDCP )
 THEN
  0.00000000 "acre-ft"
 ELSE
  AnnualDCPContribution - PreviousECtoDCP
 ENDIF) DO
            $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := PreviousECtoDCP;

            $ "ICS Credits.AnnualRemainingDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := RemainingContribution;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

            $ "ICS Credits.AnnualRemainingDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{6e31581a-a7c2-4a0d-b9ae-34e4ae15b347}";;

    RULE                 "Arizona DCP";
    DESCRIPTION          "DESCRIPTION:  This rule sets Arizona's DCP contribution if a DCP contribution is needed (solved for in previous rule). The DCP contribution is made by converting any EC ICS water created for the current year to DCP ICS by imposing a tax on the water. The annual creation of DCP ICS is input from the 24MS and is the desired DCP ICS creation [unsure how this is set for 24MS?]. The Arizona DCP ICS creation and DCP contribute is set here, but will be refined in later rules located in the ICS Accounting and Releases policy group.<br><br>CONSTRAINTS: The rule fires in run cycle 3 if it is January or the start timestep and the rule has not fired successfully. The rule fires in run cycle 4 if the DCP BWSCP flag has changed from run cycle 3 and only if it is January. <br><br>SLOTS SET: <br>ICSProjectedData.AnnualCreationECtoDCPICS_CAWCD_Preliminary";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND $ "DCP BWSCP Flags.LB DCP BWSCP Check" ["Dec31ofYear"( @"t" )] != $ "DCP BWSCP Flags.LB DCP BWSCP" ["Dec31ofYear"( @"t" )] );
    NOTES                "AUTHOR: AP, 2020-01-01<br><br>EDITS: <br>S.Baker, 2020-03-05: edited comments and added description. Also, updated execution contraints to match the other DCP rules in this policy group. <br><br>A. Pivarnik, 20200714: Integration effort. This rule was streamlined for the MTOM ruleset when created.  Added a StartYearDCPCreation function call to for solve the DCP creation volume in year 1 if Mead ends in a DCP tier that is lower than the one projected by the 24 MS in August. This rule now sets a remaining DCP contribution slot for CAWCD (part of AZ ICS acocunting overhaul). This way the logic matches what is in both NV and CA.";
    BEGIN

    DESCRIPTION          "Unlike CA and NV, AZ does not currently convert previous EC ICS to DCP ICS. Any simultaneous <br>creation of DCP ICS happens in the state accounting rules.<br><br>Under the current logic, AZ will only simultaneously create DCP ICS. Due to this, the full DCP <br>amount needs to be passed through the ruleset in the AnnualRemainingDCPContribution_CAWCD <br>slot. As stated above, any simultaneous creation of DCP ICS will happen in the AZ Accounting <br>logic later on.           <br><br>This rule is set up similar to the other states so if AZ wanted to change logic it could easily be <br>added. <br>";
      IF_STATEMENT ($ "ICS Credits.AnnualDCPContribution_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] > 0.00000000 "acre-ft") THEN
            WITH_STATEMENT (NUMERIC AnnualDCPContribution = GET @INDEX 1.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "AZ" )) DO
            $ "ICS Credits.AnnualRemainingDCPContribution_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := AnnualDCPContribution + GET @INDEX 0.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "AZ" );

      END_WITH_STATEMENT;

      ELSE
            $ "ICS Credits.AnnualRemainingDCPContribution_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

      END_IF_STATEMENT;

    END
    UUID "{0ae60bc0-928a-4151-b115-4a58787c56dd}";;

    RULE                 "Determine DCP and BWSCP Contrib";
    DESCRIPTION          "DESCRIPTION: This rule determines DCP contributions and sets DCP flags in the out-year. For the first year, these slots should be input through a DMI from the 24MS. The DCP users set include MX, AZ, CA, NV, MWD, and Coachella. The rule uses the projected Mead pool elevation from the 24MS if available (in start months of August - December). The DCP flags set which the elevation level for DCP contributions. A check flag is used to see if the DCP contribution level changes between run cycle 3 and 4. <br><br>CONSTRAINTS: The rule fires in run cycles 3 and 4 in January, as long as it is not the start timestep, and only if the rule has not fired successfully. <br><br>SLOTS SET: <br>Mexico Shortabe and Surplus.Mexico Recoverable Water Savings_AnnualContributions<br>ICS Credits.AnnualDCPContribution_AZ<br>ICS Credits.AnnualDCPContribution_CA<br>ICS Credits.cAnnualDCPContribution_NV<br>ICS Credits.AnnualDCPContribution_MWD<br>ICS Credits.AnnualDCPContribution_Coachella<br>DCP BWSCP Flags.LB DCP BWSCP<br>DCP BWSCP Flags.LB DCP BWSCP Check<br><br>NOTE: If the slots are input, the rule fails to execute. This is the desired execution for the hindcast runs in the testbed. ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) >= 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) );
    NOTES                "AUTHOR: AP, 2020-01-01<br><br>EDITS: <br>S.Baker, 2020-03-05: edited comments and added description.<br><br>A. Pivarnik, 20200709: No change to this rule in the integrated model. This rule is the same as the 24 MS but the flag set in the 24 MS rule is different. Move to using the new flag for diagnostic";
    BEGIN

    DESCRIPTION          "Set DCP contributions in out-years and set DCP flag <br>";
      WITH_STATEMENT (NUMERIC MeadPoolElevation = "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" )) DO
          DESCRIPTION          "Determine the DCP contribution needed for AZ, CA, NV and MX based on Meads previous EOCY projection  <br>";
      FOREACH (STRING user IN "DCP Users"(  )) DO
            IF_STATEMENT (user == "MX") THEN
            $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings_AnnualContribution" [@"24:00:00 December 31, Current Year"] := "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, "GetColumnIndex"( $ "DCP.Contributions", user ), MeadPoolElevation, @"t", FALSE );

      ELSE
            % "ICS Credits" & "AnnualDCPContribution_" CONCAT user [@"24:00:00 December 31, Current Year"] := "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, "GetColumnIndex"( $ "DCP.Contributions", user ), MeadPoolElevation, @"t", FALSE );

      END_IF_STATEMENT;

      ENDFOREACH;

          DESCRIPTION          "DCP flag - set in both run cycle 3 and 4  <br>";
      $ "DCP BWSCP Flags.LB DCP BWSCP" [@"24:00:00 December 31, Current Year"] := "GetRowIndex"( $ "DCP.Contributions", STRINGIFY "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, 0.00000000, MeadPoolElevation, @"t", FALSE ) );

          DESCRIPTION          "Sets DCP flag check in RC 3 for use in RC 4 to refire rules if the DCP condition changed between run cycles <br>";
      IF_STATEMENT ("GetRunCycleIndex"(  ) == 3.00000000) THEN
            $ "DCP BWSCP Flags.LB DCP BWSCP Check" [@"24:00:00 December 31, Current Year"] := "GetRowIndex"( $ "DCP.Contributions", STRINGIFY "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, 0.00000000, MeadPoolElevation, @"t", FALSE ) );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{938b73ef-6bd0-48ac-9cf9-a371f9ad9e95}";;

  END
  UUID "{9e01eacb-5079-4b62-90bd-edea3c9a6313}";;

  POLICY_GROUP   "Mead and Lower Basin Condition Determination";
  DESCRIPTION    "The rules, to the extent practical, attempt to reproduce operations of Lake Make under the Law of the River including, but is not limited to, provisions of the Criteria for Coordinated Long-Range Operation of Colorado River Reservoirs (1970 LROC), the Colorado River Interim Surplus Guidelines (2001), the Colorado River Interim Guidelines for Lower Basin Shortages and the Coordinated Operations for Lake Powell and Lake Mead (2007 Interim Guidelines), and the Lower Basin Drought Contingency Plan Agreement (2019 DCP). <br><br>With the exception of Flood Control, the other operations at Lake Mead (shortage, surplus, DCP) are handled in other policy groups. The rule here simply sets Mead's release to meet all downstream demands as those downstream demands have been modified appropriately with rules in other policy groups. The Mead Flood Control rule procedures were developed in the original CRSS and are based on the Field Working Agreement between Reclamation and the USACE (United States Army Corps of Engineers 1982). ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Quantified Surplus Flags";
    DESCRIPTION          "DESCRIPTION: This rule sets the flags that indicate a Quantified Surplus condition<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Quantified Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND @"t" == @"24:00:00 January 31, Current Year" AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170706<br><br>MC, 20170706: The setting of these flags was moved from the rule Quantified Surplus Schedules Data Volume to Simulation Flow at the suggestion of Shana T. to consolidate setting of flags related to Mead condition. Note that the Execution Constraints for this rule depend on the Surplus.Quantified Surplus Volume slot, which isn't set until Rule 39-Copute Quantified Surplus Volume - Minute 323; so, this rule will not fire successfully until after that rule<br><br>A. Pivarnik, 20180921: Disabled statement setting LowerBasinDemandVariability.AbvHooverTriggerSet. Was causing MTOM to fail in August run when trying to set Mead operations. <br><br>A. Pivarnik, 20200709: Integration effort. Deleted disabled slot assignment. These slot assignments are imbedded within a different rule in the 24 MS ruleset. This rule is unchanged<br><br>A. Pivarnik, 20200731: Removed execution constraint requiring surplus flag to be empty";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 2.00000000;

            $ "Surplus.Quantified Surplus Flag" [date] := 1.00000000;

      ENDFOREACH;

    END
    UUID "{daaf29da-016c-4ea8-966c-f83cf3956b4d}";;

    RULE                 "Set Domestic Surplus Flags";
    DESCRIPTION          "DESCRIPTION: This rule sets the flags that indicate a Domestic Surplus condition<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Domestic Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Surplus.Domestic Surplus Trigger Elevation" [] AND IsNaN $ "Surplus.Surplus Flag" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170706<br><br>MC, 20170706: The setting of these flags was moved from the rule Domestic Surplus Schedules Data Volume to Simulation Flow at the suggestion of Shana T. to consolidate setting of flags related to Mead condition<br><br>A.Pivarnik, 20180921: Disabled statement setting LowerBasinDemandVariability.AbvHooverTriggerSet. Was causing MTOM to fail in August run when trying to set Mead operations. <br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). <br><br>A. Pivarnik, 20200709: Integration effort. Deleted disabled slot assignment. These slot assignments are imbedded within a different rule in the 24 MS ruleset. This rule is unchanged";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 1.00000000;

            $ "Surplus.Domestic Surplus Flag" [date] := 1.00000000;

      ENDFOREACH;

    END
    UUID "{80df0f7b-b6ae-4c02-86da-f2fcd9a0bff8}";;

    RULE                 "Compute Quantified Surplus Volume";
    DESCRIPTION          "DESCRIPTION: This rule computes the total volume of Quantified Surplus water for the year. This slot only computes once per year in January and is NOT recalculated if Lower Basin demands are revised. If this value is postitive, there is a Quantified Surplus determination and water use schedules are revised as appropriate. <br>Equation:   Surplus Volume = (Powell Storage + Mead Storage - maxstorage - previous year ICS credits)*(1+avgBankStorcoef) + runoff - UBDemand - LBDemand <br>Variable Definitions:<br>  Powell Storage = Powell storage at beginning of the year (December month-end) <br>  Mead Storage = Mead storage at the beginning of the year (December month-end) <br>  Max Storage = 47.96 maf <br>  Previous year ICS credits - cumulative ICS credits over entire Lower Basin over all years <br>  avgBankStorcoef = average of Powell and Mead bank storage coefficients <br>  Runoff = 17.4 maf (70th percentile non-exceedence flow) <br>  UBDemand = Upper Basin depletion scheduled for the year + average evaporation loss in the Upper Basin (same as in 602a calculation, 560 kaf) <br>  LBDemand = sum of depletions below Powell + evaporation losses in the Lower Basin (avg 900 kaf) ? avg gains below Powell (Powell to Mead and below Mead) <br><br>-HMG 8/2/11<br><br>SLOTS SET: Surplus.Quantified Surplus Volume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] AND "IsJANofOutyear"(  ) AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/11<br>MC, 20160114: There is a function, QuantifiedSurplusVolume, with the same calculation in it.  Are both necessary?<br>MC, 20170512: Need to edit Execution Constraints to ensure execution in January?<br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from rule name<br>A.Pivarnik, 20200731: Added Run cycle index > 3 to execution constraint. No other changes needed for integration effort";
    BEGIN

      $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] := "QuantifiedSurplusVolume"(  );

    END
    UUID "{ad6802dc-2ef8-4a9b-be08-65b9452a4fe8}";;

    RULE                 "Determine Mead and Lower Basin Condition";
    DESCRIPTION          "DESCRIPTION: This rule sets a slot that determines the Condition of Lake Mead and the Lower Basin. A setting of 0 means a normal year, a 1 means shortage, a 2 means Domestic Surplus and a 3 is Quantified Surplus.  In the condition of anything that is not normal. TP 7/28/2015<br>                         Sets LBDV.schedulecheck to something other than 0 if the LB condition changes in RC 3. AP 9/18/2018<br><br>SLOTS SET: LowerBasinDemandVariability.LowerBasinCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 3.00000000 ) AND NOT "Is24MonthStudy"(  );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015<br><br>9/18/2018, AP: Removed logic to determine LB operating condition and moved it into LBConditionDetermination function. Rule now sets LBDV.Schedule check value to either a 1 (shortage) or 2 (surplus) if the LB condition switches to something other than normal in run cycle 3. This value does not change after run cycle 3.<br><br>S.Baker, 20180925: Changed execution constraint to allow rule to execute in start timestep since 24MS projected Mead PE is known. Edited time in function to Dec Previous year. This will allow the rule to execute correctly in start timestep. Edited date input in second assignment to be consistent with the first assignment (shouldnt change how rule works). <br><br>A. Pivarnik. 20200709: this rule is not in the 24 MS but is needed by MTOM to fire later rules. This rule was turned off in 24 MS mode";
    BEGIN

      $ "LowerBasinDemandVariability.LowerBasinCondition" [@"24:00:00 December 31, Current Year"] := "LBConditionDetermination"(  );

      $ "LowerBasinDemandVariability.ScheduleCheck" [@"24:00:00 December 31, Current Year"] := IF ( "GetRunCycleIndex"(  ) == 3.00000000 AND "LBConditionDetermination"(  ) != 0.00000000 )
 THEN
  IF ( "LBConditionDetermination"(  ) == 1.00000000 )
  THEN
   1.00000000
  ELSE
   2.00000000
  ENDIF
 ENDIF;

    END
    UUID "{f22ba73e-2bb4-4e47-83d8-d6a0aaf4321a}";;

    RULE                 "Set Mexico Surplus Flag";
    DESCRIPTION          "DESCRIPTION: This rule sets the Mexico Surplus flag as a function of Mead compared to the Mexico Surplus Table. A Mead elevation of >= 1,200 ft. receives a value of 3, a value greater than 1,170 ft and less than the level 3 elevation, receives a value of 2, a value of 1,145 ft and less than a level 2 receives a value of 0 and any other condition receives a value of 0. This flag is used in subsequent Mexico Surplus rules. TP 7/28/2015<br><br>SLOTS SET: Mexico Shortage and Surplus.Mexico Surplus Flag<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170706: Moved from Priority 41 while consolidating Mead conditions flag-setting per Shana T. suggestion<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). Changed execution constraint to allow execution in start timestep.<br><br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from rule name<br><br>A. Pivarnik, 20200709: Integration effort.  This rule is essentially the same as the 24 MS rule except it uses te GetProjectedPoolElevation function. No other changes were made to the rule during the integration effort. ";
    BEGIN

      $ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] COMMENTED_BY "This rule sets the MX surplus flag for the model run. This flag will be used later to determine <br>surplus volumes for MX.   <br>" := IF ( ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [2.00000000, "Elevation"] ) COMMENTED_BY "Mead >= 1200 <br>" )
 THEN
  3.00000000
 ELSE
  IF ( ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [1.00000000, "Elevation"] ) COMMENTED_BY "Mead >= 1170   <br>" )
  THEN
   2.00000000
  ELSE
   IF ( ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [0.00000000, "Elevation"] ) COMMENTED_BY "Mead >= 1145 <br>" )
   THEN
    1.00000000
   ELSE
    0.00000000 COMMENTED_BY "No surplus <br>"
   ENDIF
  ENDIF
 ENDIF;

    END
    UUID "{e61bbf9a-a73d-4513-953d-9bf386f620cd}";;

    RULE                 "Set Shortage Flag";
    DESCRIPTION          "DESCRIPTION: In the event that a Lower Basin shortage is projected, this rule sets the Shortage Flag slot to indicate the level of shortage. No shortage = 0. Most severe shortage (Mead < 1025 feet) = 3. Mead < 1050 ft = 2, Mead < 1075 ft = 1. If there is a shortage or surplus then the Abv Hoover Trigger is set to a 2 and no LBDV will occur for the parties that look at the Above Hoover Trigger Set for LBDV.  (SNWP)<br><br>SLOTS SET: Shortage.Shortage Flag, LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170706: Moved from Priority 46 while consolidating Mead conditions flag-setting per Shana T. suggestion<br>S.Baker, 20180925: Changed IF statements to use function 'GetProjectedPoolElevation' instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). Changed execution constraint to allow rule to execute in start timestep since 24MS projected Mead PE is known. Edited time in function to Dec Previous year. This will allow the rule to execute correctly in start timestep.<br><br>A. Pivarnik, 20200709: Integration effort. Deleted disabled slot assingment. This rule is essentially the same as the 24 MS rule except it uses te GetProjectedPoolElevation function. No other changes were made to the rule during the integration effort";
    BEGIN

    DESCRIPTION          "This rule sets the shortage flag for the model run. This flag will be used later to determine <br>shortage reductions for AZ, NV, and MX. <br>";
      $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] := IF ( ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) < $ "Shortage.Mead Shortage Elevations" [2.00000000, 0.00000000] ) COMMENTED_BY "Mead < 1025<br>" )
 THEN
  3.00000000
 ELSE
  IF ( ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) < $ "Shortage.Mead Shortage Elevations" [1.00000000, 0.00000000] ) COMMENTED_BY "Mead < 1050 <br>" )
  THEN
   2.00000000
  ELSE
   IF ( ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] ) COMMENTED_BY "Mead <= 1075 <br>" )
   THEN
    1.00000000
   ELSE
    0.00000000 COMMENTED_BY "No shortage <br>"
   ENDIF
  ENDIF
 ENDIF;

    END
    UUID "{9d0ab11a-d5e2-4e62-80df-1c527c3532f9}";;

  END
  UUID "{59a47bfe-f3f4-40f3-814a-1b05921b744f}";;

  POLICY_GROUP   "Powell Steady Flow Experiment";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Steady Flow Experiment Release";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( $ "PowellData.SteadyFlowExperimentFlag" [] == 1.00000000 AND "GetRunCycleIndex"(  ) == 3.00000000 ) AND NOT "Is24MonthStudy"(  );
    NOTES                "APivarnik 20200706: Added execution contraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort";
    BEGIN

      IF_STATEMENT ("MonthIs"( { "September" } )) THEN
            $ "Powell.Outflow" [] := "GetSeptemberSteadyFlowRelease"( $ "PowellData.TargetAnnualReleaseVolume" [] );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "October" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [@"t - 1"];

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "April" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.5_ReduceApril" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "May" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.6_ReduceMay" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "June" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - ( $ "PowellSteadyFlowExperiment.4_ReduceJune_2" ["CurrentYear"(  )] + $ "PowellSteadyFlowExperiment.3_ReduceJune_1" ["CurrentYear"(  )] ) / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "July" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.2_ReduceAugust" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "July" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.1_ReduceJuly" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

    END
    UUID "{ea5d36ab-9eb5-48a7-ba12-c5e217d176de}";;

    RULE                 "Set Steady Flow Reductions";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( "MonthIs"( { "April" } ) AND "GetRunCycleIndex"(  ) == 3.00000000 ) AND NOT "Is24MonthStudy"(  );
    NOTES                "APivarnik 20200706: Added execution contraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort";
    BEGIN

      $ "PowellSteadyFlowExperiment.1_ReduceJuly" ["CurrentYear"(  )] := "SteadyFlowReduce_1_July"(  );

      $ "PowellSteadyFlowExperiment.2_ReduceAugust" ["CurrentYear"(  )] := "SteadyFlowReduce_2_August"(  );

      $ "PowellSteadyFlowExperiment.3_ReduceJune_1" ["CurrentYear"(  )] := "SteadyFlowReduce_3_June1"(  );

      $ "PowellSteadyFlowExperiment.4_ReduceJune_2" ["CurrentYear"(  )] := "SteadyFlowReduce_4_June2"(  );

      $ "PowellSteadyFlowExperiment.5_ReduceApril" ["CurrentYear"(  )] := "SteadyFlowReduce_5_April"(  );

      $ "PowellSteadyFlowExperiment.6_ReduceMay" ["CurrentYear"(  )] := "SteadyFlowReduce_6_May"(  );

    END
    UUID "{00b3bf07-1db5-40af-b0f4-59929943fad1}";;

  END
  UUID "{8b1f28ea-1166-42a1-b266-40f95b9da449}";;

  POLICY_GROUP   "PowellAfterLBDV";
  DESCRIPTION    "This policy group re-executes Powell operations in run cycle 4 after Lower Basin Demand Variability. A different policy group is needed due the way Powell solves (e.g. solving with 8.23 maf release and using the resulting elevation to determine tiering).";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Lower Balancing Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Lower Elevation Balancing Tier. This version of the rule executes in Run Cycle 4.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetRunCycleIndex"(  ) == 4.00000000 AND ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND "TierIs"( "Lower", @"t", FALSE ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20180925: Rule should not fire in the start timestep (execution constraint removed and IF statement removed). This is done in a separate rule. Removed IsYearDemandVariabilityandRunCycle4() since rule should always execute in Run Cycle 4. Added TierIs() to execution constraint.<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200914: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "For August timestep with Lower Balancing Release Tier in next outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t + 2" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{852392ad-b511-4677-b6e1-4d10704c4210}";;

    RULE                 "Set Mid-Elevation Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Mid-Elevation Tier. This version of the rule executes in Run Cycle 4.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetRunCycleIndex"(  ) == 4.00000000 AND ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND "TierIs"( "Mid", @"t", FALSE ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20180925: Rule should not fire in the start timestep (execution constraint removed and IF statement removed). This is done in a separate rule. Removed IsYearDemandVariabilityandRunCycle4() since rule should always execute in Run Cycle 4. Added TierIs() to execution constraint.<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation).<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200914: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "In August with Mid-elevation tier for the next outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Current Year" ) ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF;

      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{c2dfcd2b-d19d-46fd-9838-08812e43404f}";;

    RULE                 "Refine Equalization Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule refines the annual release volume from Powell when either the Equalization Tier or Upper Elevation Balancing Tier B3 branch is operative for setting the annual release from Powell.  The release needs to be refined by this rule because when it is originally set, it is a preliminary &quot;guess&quot; for the volume it will take to arrive at the appropriate final (end of water year) condition (Equalized storage volumes, or Powell at a specific pool elevation at the end of the year - see Equalization Tier logic for more details as to what the final eowy condition should be).  This volume is then released and the end of year condition is checked against what it is supposed to be.  The first guess will almost always be off by some amount because of the non-linear elements in the water balance in both Powell and Mead of Evaporation and Bank Storage.  So rather than trying to set up a calculation or mini-simulation to calculate the exact right release volume to hit the end of water year condtion the first time, the guess volume is actually released and then this rule, because it can see the results of the original release, adjusts the release volume to eliminate the deviation from the target that it observes as a result of the initial guess release.  This rule is allowed to fire multiple times in a timestep and may do so in order to hit exactly the end of water year target condition. - sc 06/21/12<br><br>This version of the rule executes in Run Cycle 4 with Lower Basin Demand Variability in effect.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( WITH DATETIME eoyDate = IF ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
 THEN
  "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )
 ELSE
  "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )
 ENDIF DO
  "HasRuleFiredSuccessfully"( "Set Equalization Release Volume post-LBDV" ) OR ( "HasRuleFiredSuccessfully"( "Set Upper Balancing Release Volume post-LBDV" ) AND $ "PowellData.UpperElevBalBranch" [eoyDate] == 1.30000000 ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) ) AND "GetRunCycleIndex"(  ) == 4.00000000 AND ( "TierIs"( "Upper", @"t", TRUE ) OR "TierIs"( "Equalization", @"t", TRUE ) )
 ENDWITH );
    NOTES                "S.Baker, 2018/10/17: Copied from normal Powell policy set and changed execution constraints for Run Cycle 4 and LBDV. Go to original rule for development details prior to this date. <br>S.Baker, 2018/11/26: [edited to match normal Powell rule for RC #3] Added WITH statement to store TARV and use in IF statement to look if solved TARV was equal to previous TARV. Then, allow for setting of the PowellData.ReleaseVolumeSetFlag when TARV solved in the current iteration is equal to the previously set TARV. This is necessary for solving for the carryover release pattern from Powell. This occurs normally when TARV is not changed from 8.23 MAF. <br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200914: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      IF_STATEMENT (( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) ) COMMENTED_BY "At Start Timestep for initial water year when release tier is either Upper Elevation Balancing or Equalization") THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t" ) )) DO
            IF_STATEMENT ("Abs"( ReleaseAdjustment ) > $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            WITH_STATEMENT (NUMERIC PowellnewTARV = "MaxItem"( { $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] + ReleaseAdjustment , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } )) DO
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := PowellnewTARV;

          DESCRIPTION          "If TARV solved in this rule is equal to the previous TARV solved, then set the <br>ReleaseVolumeSetFlag. This allow carryover releases to be set if necessary.  <br>";
      IF_STATEMENT (PowellnewTARV == $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Check in August timestep or StartMonth of September with UEBT or Equalization for outyear";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  )) THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t + 2" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t + 2" ) )) DO
            IF_STATEMENT ("Abs"( VolumeDeviation ) > 0.00000000 "acre-feet") THEN
            WITH_STATEMENT (NUMERIC CurrentAnnualRelease = FOR ( DATETIME dates IN "GetDates"( "OffsetDate"( @"24:00:00 September Max DayOfMonth, Next Year", - 11.00000000, "1 months" ), @"24:00:00 September Max DayOfMonth, Next Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Outflow" [dates], dates )
 ENDFOR) DO
          DESCRIPTION          "MC, 20171102: This version added to handle carryover situation by setting ReleaseVolumeSetFlag <br>";
      IF_STATEMENT ("Abs"( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] - ( CurrentAnnualRelease + VolumeDeviation ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) + 1.00000000 "year" )] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) ) > ( $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) COMMENTED_BY "The tolerance of the TARV slot; if the proposed change is less than this value the slot value won't change <br>") THEN
            WITH_STATEMENT (NUMERIC PowellnewTARV = "MaxItem"( { IF ( "Abs"( ReleaseAdjustment ) > 0.00000000 "acre-ft" )
 THEN
  ( CurrentAnnualRelease - IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 999.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] )
  ENDIF COMMENTED_BY "Remove the Carryover That has been Added from last year Unless an Equalization Tier is the <br>current tier. <br>" ) + ReleaseAdjustment + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) + 1.00000000 "year" )] )
 ELSE
  $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] + ReleaseAdjustment
 ENDIF , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } )) DO
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := PowellnewTARV;

            IF_STATEMENT (PowellnewTARV == $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )]) THEN
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{6f4bc009-d2e0-4fbb-a2ec-a66a7ffe29ec}";;

    RULE                 "Set Upper Balancing Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Upper Elevation Balancing Tier. It also sets the Upper Elevation Balancing Branch, which indicates the conditions controlling the release volume, and resets the Release Tier and the Controlling Equalization Condition if necessary (UEB Branch = 1.3). This version of the rule executes in Run Cycle 4.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.UpperElevBalBranch; PowellData.ReleaseTier; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "TierIs"( "Upper", @"t", FALSE ) AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "AUTHOR, DATE: Unknown<br>MC, 20161215: In the conditional statement checking for EqualizationTeirCalculationForRelease, changed PowellToMeadData.AugEOYPowellPEProjection[meadProjectionDate] to Powell.Pool Elevation[DateToCheckEOWYElevation(@&quot;t&quot;,TRUE)]. The check needs to be on the EOWY pool elevation, not the previous year's projected EOY pool elevation, because this is checking to see if the decision tree should follow the branch from Upper Elevation Balancing to Equalization. I had incorrectly changed the date used when adding the carryover functionality.<br><br>MC, 20170511: The GetRunCycleIndex()==3 condition will never be satisfied due to the Execution Constraints. Compare with initial version of rule for Run Cycle 4 and correct<br><br>S.Baker, 20180829: Edited the function 'UpperEleavationBalancingBranchCalculation' to have the correct number of inputs. <br><br>S.Baker, 20180925: Rule should not fire in the start timestep (execution constraint removed and IF statement removed). This is done in a separate rule. Removed IsYearDemandVariabilityandRunCycle4() since rule should always execute in Run Cycle 4. Added TierIs() to execution constraint.<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead Pool Elevation. This will allow MTOM to determine which PE projection to use (ie. AugEOYProjectedMeadPE).<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200914: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "In August or September start month with UEBT for outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", FALSE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) )
 THEN
  "MaxItem"( { ( GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "DateToCheckEOWYElevation"( @"t", FALSE ) )] ) , 8230000.00000000 "acre-feet" } )
 ELSE
  IF ( ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Current Year" ) ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1075.00000000 "ft" ) COMMENTED_BY "Determine which branch of UEBT to follow" )
  THEN
   "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ELSE
   "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ENDIF
 ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue...";

    DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", FALSE ) )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{1eba6ddb-8796-468b-9d12-fa2dc80da02c}";;

    RULE                 "Set Equalization Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for years when the Release Tier is Equalization. It also calculates and sets the Controlling Equalization Condition slot, which indicates the equalization condition that dictated the volume to be released. This version executes in Run Cycle 4 if Lower Basin Demand Variability is in effect.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "TierIs"( "Equalization", @"t", FALSE ) AND $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 0.00000000 AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only fires in Run Cycle 4 with demand variability in effect, it is August, and the model has selected the Equalization teir for the current year. - sc 02/02/11; TP 08/20/2014; MC, 20170511" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20180925: Rule should not fire in the start timestep (execution constraint removed and IF statement removed). This is done in a separate rule. Removed IsYearDemandVariabilityandRunCycle4() since rule should always execute in Run Cycle 4. Added TierIs() to execution constraint. Disabled PowellData.ReleaseVolumeSetFlag since this flag should be set in the Refine Equalization rule. <br>S.Baker, 2018/10/17: updated run cycle execution constraint to RC == 4 (was 3 which was incorrect).<br>S.Baker, 20200417: Updated rule to match the RC 3 rule and make sure release isnt less than 8.23 maf. Before fix, TARV was being set to less than 8.23 maf during equalization.<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200914: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Outyear with Equalization";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "MaxItem"( { GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , 8230000.00000000 "acre-feet" } );

      $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

    INACTIVE      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{796178cf-8f6b-44cf-83f1-7b016f6d805b}";;

    RULE                 "Set Release Tier post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule fires at the Start Timestep and in August timesteps to set the Powell Release tier, as well as preliminarily setting the Upper Elevation Balancing Branch and Controlling Equalization Condition values to 999<br><br>SLOTS SET: PowellData.ReleaseTier; PowellData.UpperElevBalBranch; PowellData.ControllingEqualizationCondition<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) ) AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "AUTHOR, DATE: SC, 02/02/2011 (copied to LBDV from Powell policy group)<br><br>S.Baker, 20180925: Added rule to post-LBDV since rule in Powell policy set wont fire in Run Cycle 4 due to condiditon of HasRuleFiredSucessfully() constraint. <br>S.Baker, 20180925: Changed order of rules. Moved &quot;Set Release Tier post-LBDV&quot; to a higher priority than &quot;Preliminary Set Out Year Release Volume to 8.23MAF post-LBDV&quot;. The priority issue was causing incorrectly calculated Release Tiers in the post-LBDV rules. When the ruleset got to the rule &quot;Set Release Tier post-LBDV&quot; the release for the water year was still set to a higher TARV (9.0MAF). This caused the rules to calculate the wrong release. MTOM then reset the TARV to 8.23MAF in &quot;Preliminary Set Out Year Release Volume to 8.23MAF post-LBDV&quot;. Switching the order of the rules allows for the TARV to be reset to 8.23MAF before calculating the release tier. <br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200914: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Model needs to set the teir for the following water year if current timestep is August. <br>";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND @"t + 2" IN "WaterYearDatesByGroup"( 2.00000000 )) THEN
            WITH_STATEMENT (NUMERIC Carryover = NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] )) DO
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - Carryover )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( IF ( @"t" == @"Start Timestep" )
 THEN
  $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t + 2", TRUE )]
 ELSE
  EffectivePoolElevation
 ENDIF, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "The model will set the tier for the third year of the model run (second out year)";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 3.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Third out year of the model run";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 4.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Fourth out year of model run";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 5.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Fifth out year of model run if it exists in the forecast";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 6.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{1e37ef40-8fde-4d4e-9d5c-09507136bf11}";;

    RULE                 "Preliminary Set Out Year Release Volume To 8.23MAF post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "AUTHOR, DATE: SC, 03/25/2011<br><br>S.Baker, 20190710: Edited the Max() statement to match the normal rule. The rule was using a function used in the Equalization rule instead of setting initial TARV to 8.23 (or close). <br>S.Baker, 20180925: Removed IsYearDemandVariabilityandRunCycle4() since rule should always execute in Run Cycle 4. <br>S.Baker, 20180925: Changed order of rules. Moved &quot;Set Release Tier post-LBDV&quot; to a higher priority than &quot;Preliminary Set Out Year Release Volume to 8.23MAF post-LBDV&quot;. The priority issue was causing incorrectly calculated Release Tiers in the post-LBDV rules. When the ruleset got to the rule &quot;Set Release Tier post-LBDV&quot; the release for the water year was still set to a higher TARV (9.0MAF). This caused the rules to calculate the wrong release. MTOM then reset the TARV to 8.23MAF in &quot;Preliminary Set Out Year Release Volume to 8.23MAF post-LBDV&quot;. Switching the order of the rules allows for the TARV to be reset to 8.23MAF before calculating the release tier. <br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200914: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      WITH_STATEMENT (NUMERIC waterYearNumber = "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF) DO
            WITH_STATEMENT (NUMERIC AvailablePowellWater = ( IF ( "GetMonth"( @"Start Timestep" ) == 9.00000000 )
 THEN
  $ "Powell.Storage" [@"t - 1"]
 ELSE
  $ "Powell.Storage" [@"t + 1"]
 ENDIF COMMENTED_BY "MC, 20170511: I don't understand the below conditions" + FOR ( DATETIME date IN "WaterYearDatesByGroup"( waterYearNumber ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Inflow" [date], date )
 ENDFOR ) COMMENTED_BY "This is added to check that in years when Powell might go very low, the model won't bomb out <br>when setting the preliminary release when Powell is low. TP 1/22/2013<br>") DO
            WITH_STATEMENT (DATETIME WY_EndOfCalendarYearDate = "Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), waterYearNumber - 1.00000000, "1 years" ) )) DO
            WITH_STATEMENT (NUMERIC VolumeToRelease = "Min"( "MaxItem"( { 8230.00000000 "1000 acre-feet" , WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  "Min"( 8230.00000000 "1000 acre-feet", releaseTable ["AnnualTotal", "NumColumns"( releaseTable ) - 2.00000000] )
 ENDWITH COMMENTED_BY "Ensure release enough so Powell doesn't exceed max pool elevation" , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" [WY_EndOfCalendarYearDate] ) COMMENTED_BY "User input minimum annual release volume" } ), AvailablePowellWater )) DO
            IF_STATEMENT (NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", WY_EndOfCalendarYearDate )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" [WY_EndOfCalendarYearDate] := VolumeToRelease;

          DESCRIPTION          "These flags have to be reset and set again if go to LBDV <br>";
      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

          INACTIVE      $ "PowellData.CarryoverSetFlag" ["Dec31ofYear"( "GetWaterYearEndDate"( @"t + 2" ) )] := 0.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{00ac8008-5e6e-42a9-b9c2-8c5d6d8671a9}";;

    RULE                 "Set WY1 Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for the first WY for any release Tier designation. It also calculates and sets the Controlling Equalization Condition slot, which indicates the condition that dictated the volume to be released based on which Tier has been set. <br><br>SLOTS SET: Some combination of the following - PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition; PowellData.UpperElevBalBranch<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only executes in Run Cycle 4; at the Start Timestep for only the first <br>WY;  and if the rule has not already fired successfully for the timestep   <br>" );
    NOTES                "AUTHOR, DATE: Unknown (copied rule from Powell policy group)<br><br>S.Baker, 20180925: Added rule to post-LBDV since rule in Powell policy set wont fire in Run Cycle 4 due to condiditon of HasRuleFiredSucessfully() constraint. <br>AP, 2019/04/11: Added contstraint where it sets TARV to make sure the model won't equalize when the upper elevation balancing branch is an input<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200914: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      IF_STATEMENT ("TierIs"( "Equalization", @"t", TRUE ) COMMENTED_BY "Initial water year, in an Equalization Condition in Start Year <br>") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , 8230000.00000000 "acre-feet" } );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep in Run Cycle 3 with UEBT in Start Year";
      IF_STATEMENT ("TierIs"( "Upper", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := WITH DATETIME meadProjectionDate = IF ( @"t" <= @"September 30" )
 THEN
  @"24:00:00 December 31, Previous Year"
 ELSE
  @"24:00:00 December 31, Current Year"
 ENDIF DO
  IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", TRUE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) AND NOT "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.30000000 ) )
  THEN
   GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
  ELSE
   IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" [meadProjectionDate] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) ) >= 1075.00000000 "ft" OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND NOT $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.20000000 ) )
   THEN
    "Max"( "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ELSE
    "Max"( "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ENDIF COMMENTED_BY "Determine which branch of UEBT to follow"
  ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue..."
 ENDWITH;

          DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = IF ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) )
 THEN
  $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]
 ELSE
  "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
 ENDIF) DO
          DESCRIPTION          "Check if branch is input before trying to set slot <br>";
      IF_STATEMENT (NOT "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := upperElevBranch;

      END_IF_STATEMENT;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

            IF_STATEMENT (NOT "IsInput"( $ "PowellData.ControllingEqualizationCondition", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep with Mid-Elevation tier in initial water year";
      IF_STATEMENT ("TierIs"( "Mid", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF, NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep with Lower Balancing Release Tier in initial water year";
      IF_STATEMENT ("TierIs"( "Lower", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

      END_IF_STATEMENT;

    END
    UUID "{be04a389-6176-4607-9ddf-1d26fb5a16f9}";;

    RULE                 "Set WY1 Release Tier post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule fires at the Start Timestep and in August timesteps to set the Powell Release tier, as well as preliminarily setting the Upper Elevation Balancing Branch and Controlling Equalization Condition values to 999, for the First Water Year<br><br>SLOTS SET: PowellData.ReleaseTier; PowellData.UpperElevBalBranch; PowellData.ControllingEqualizationCondition";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" AND ( "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) AND IsNaN $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] );
    NOTES                "AUTHOR, DATE: SC, 02/02/2011 (copied rule from Powell policy group)<br><br>S.Baker, 20180925: Added rule to post-LBDV since rule in Powell policy set wont fire in Run Cycle 4 due to condiditon of HasRuleFiredSucessfully() constraint<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200914: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Model needs to set the teir for the current year if at the start timestep, regardless of month. <br>";
      $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "PowellReleaseTier"( $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )], "RelativeEOWYDate"( @"t" ) );

      IF_STATEMENT (IsNaN $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

    END
    UUID "{b7ba1dd0-7e9c-4d59-ada8-66d94dffa65d}";;

    RULE                 "Preliminary Set WY1 Release Volume To 8.23MAF post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) );
    NOTES                "AUTHOR, DATE: SC, 03/25/2011<br><br>S.Baker, 20180925: Edited execution constraints to match Powell policy group rule. Changed rule TARV calculation to match Powell policy set rule. <br><br>S.Baker, 2018/10/17: Changed column number in releaseTable[AnnualVolume, Ncol - 3]<br>MTOM was failing in testbed runs in this rule in high inflow years when Powell was trying to release a large volume. In the historical run of 1983-06, the model aborted since it sets the initial TARV to 30 MAF based on the condition releaseTable[AnnualVolume, Ncol ? 2].  This caused the model to look for too high of upper bound in the function ?CalculatePowellMonthlyRelease?.  The upper bound was being reset in function 'FindRemainingReleaseUpperBoundColumn' by adding + 1 index which cause model to look for table index that didn?t exist. When we use Ncol ? 3, the TARV is initially set to 20 MAF and MTOM runs successfully finding a realistic TARV (18 MAF). <br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200914: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      IF_STATEMENT (NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { 8230.00000000 "1000 acre-feet" , WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  "Min"( "CalcReleaseForMaxPoolElevation"( "WaterYearDatesByGroup"( 1.00000000 ) ), releaseTable ["AnnualTotal", "NumColumns"( releaseTable ) - 3.00000000] )
 ENDWITH COMMENTED_BY "Ensure enough water released so Powell does not exceed max pool elevation" , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) COMMENTED_BY "User input min annual volume was added to allow overriding automatic determination" , IF ( "GetMonth"( @"t" ) != 10.00000000 )
 THEN
  "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( @"t", "MonthsSinceEOWY"( @"t" ), "-1 months" ), @"Start Timestep - 1" )
 ELSE
  0.00000000 "acre-foot"
 ENDIF COMMENTED_BY "Ensure TARV is not less than volume already released in water year" } );

          DESCRIPTION          "These flags have to be reset and set again if go to LBDV <br>";
      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

          INACTIVE      $ "PowellData.CarryoverSetFlag" ["Dec31ofYear"( "GetWaterYearEndDate"( @"t" ) )] := 0.00000000;

      END_IF_STATEMENT;

    END
    UUID "{c0de35a8-26d3-43b9-9349-a5c393b3de46}";;

  END
  UUID "{2b602780-8fa0-4012-8cf3-2c6a6ec1bdd2}";;

  POLICY_GROUP   "Powell";
  DESCRIPTION    "The rules, to the extent practical, attempt to reproduce operations of Lake Powell under the Law of the River including, but not limited to, provisions of the Criteria for Coordinated Long-Range Operation of Colorado River Reservoirs (1970 LROC), the Interim 602(a) Storage Guideline (2004), and the Colorado River Interim Guidelines for Lower Basin Shortages and the Coordinated Operations for Lake Powell and Lake Mead (2007 Interim Guidelines, IG).  <br><br>The rules begin by computing the 602a Storage volume (Compute 602a Storage rule) and then forecasting the EOWY storage at Powell and Mead (EOWYStorageForecasts rule), which is used to determine some annual operations, e.g., if an April switch to Balancing or Equalization should occur. The EOWY storage forecasts use the forecast Powell inflow (see Powell Forecasting policy group description). Note that the 602a Storage volume is only used in equalization releases when reverting to the 2007 FEIS ?No Action? rules. In a &quot;typical&quot; year, the rules then proceed as follows: Powell's release is set to the &quot;standard&quot; release subject to available water and safe operating capacity. Then, one of the following 4 Interim Guidelines rules will execute depending on the year?s tier determination.  <br><br>?Standard? releases depend on a rule curve consisting of a forecast-driven operation from January through July that attempts to fill the reservoir to July target storage, and an operation from August through December that attempts to draw down the reservoir to December target storage (Powell Operations rule). Another rule simulates the occurrence of Beach/Habitat-Building Flows (BHBFs or spike flows; Powell Spike Flow rule). Two other higher priority rules ensure that appropriate constraints are placed on outflow (Powell Limit Outflow Rule and Check Bypass Capacity rule) and that the minimum objective release of 8.23 million acre-feet per year (mafy) is met (Meet Powell Min Objective Release rule).  <br><br>The rules then proceed with one of the 4 Interim Guidelines rules, which will execute depending on the year?s tier: Lower Elevation Balancing, Mid-Elevation Release, Upper Elevation Balancing (January through March and April through September are handled in two different rules in order to model the potential switch to balancing or Equalization in April when operating in the Upper Elevation Balancing tier.), Equalization. In reality, the August 24-Month Study sets the operating tier at Powell for the next water year. However, as a simplifying assumption, these rules use the end-of-December eleveation to determine Powell?s operating tier for the current water year, rather than attempting to model and August projection. The one exception is that when Powell is between 3,525? and 3,575? in October ? December and Mead is above 1,025?, Powell will start the 7.48 maf releases in the Mid-Elevation release tier in October-December.  <br><br>When Powell is operating in the Equalization Tier, it is possible that the volume necessary to fully equalize (or to meet the equalization conditions from the ROD) cannot be entirely released in the water year due to the power plant capacity at Glen Canyon. When this is the case, the volume that could not be released in the current water year must be released in the next water year, I.e., carry over equalization. If/when this occurs, the carry over releases are added on to the releases computed by the other rules in the ?Add Carryover Equalization Rlease? rule.  <br><br>All releases are constrained by the physical release capacity at the dam. When the releases are going through the power plant, this constraint is handled in each rule. However, once levels fall below the power plant intake, the releases are constrained to the head-dependent capacity of the bypass tubes, handled in the ?Check Bypass Capacity? rule. <br><br>";
  ACTIVE         TRUE;
  NOTES          "Annual operations of Lake Powell follow the guidelines specified in the 2007 Record of Decision for the Colorado River Interim Guidelines for Lower Basin Shortages and the Coordinated Operations for Lake Powell and Lake Mead (2007 Interim Guidelines). The 2007 Interim Guidelines specify several requirements that coordinate annual operations between Lake Powell and Lake Mead. The objective of coordinated operations is to avoid curtailment of uses in the Upper Basin, minimize shortages in the Lower Basin, and not adversely affect the yield for development available in the Upper Basin.<br>The 2007 Interim Guidelines specify annual release volumes for each of the four tiers, described herein. Operating tiers are set based upon the August projection of the following January 1 elevation, but in some cases are subject to an April adjustment.   <br>Equalization Tier <br>In water years when the Lake Powell January 1 pool elevation is projected to be greater than or equal to the Equalization elevation for the water year (see the 2007 Interim Guidelines), an amount of water greater than 8.23 MAF will be released from Lake Powell to the extent necessary to avoid spills or equalize the storage in the two reservoirs, otherwise to remain at 8.23 MAF. If, however, Lake Powell reaches the Equalization elevation and the September 30 projected Lake Mead elevation is below 1,105 feet, then additional water will be released until the first of the following occur: (i) Lake Powell and Lake Mead storages equalize, (ii) Lake Mead pool elevation reaches 1,105 feet, or (iii) Lake Powell pool elevation is equal to 20 feet less than the Equalization level for that year. <br>Upper Elevation Balancing Tier <br>If the August 24-Month Study projects the Lake Powell pool elevation for January 1 to be less than the elevation stated in the Lake Powell Equalization Elevation Table and at or above 3,575 feet, then the tier is Upper Elevation Balancing Tier. If the August 24-Month Study also projects the Lake Mead January 1 pool elevation to be greater than 1,075 feet, then 8.23 MAF will be released from Lake Powell. <br>If the August 24-Month Study projects the January 1 Lake Powell elevation to be below the elevation stated in the Lake Powell Equalization Elevation Table and at or above 3,575 feet, and the projected January 1 Lake Mead elevation is below 1,075 feet, the release from Lake Powell shall balance the contents of Lake Mead and Lake Powell, but shall be not more than 9.0 MAF and not less than 7.0 MAF in the water year. <br>When operating in the Upper Elevation Balancing Tier, if the April 24-Month Study projects the September 30 Lake Powell elevation to be greater than the elevation in the Lake Powell Equalization Elevation Table, the Equalization Tier will govern the operation of Lake Powell for the remainder of the water year (through September). <br>When operating under the Upper Elevation Balancing Tier with an 8.23 MAF release, if the April 24-Month Study projects the September 30 Lake Mead elevation to be below 1,075 feet and the September 30 Lake Powell elevation to be at or above 3,575 feet, the releases from Lake Powell shall balance the contents of Lake Mead and Lake Powell, but shall not be more than 9.0 MAF and not less than 8.23 MAF in the water year. <br>Mid-Elevation Release Tier <br>If the August 24-Month Study projects the January 1 Lake Powell pool elevation to be less than 3,575 feet and greater than or equal to 3,525 feet, the operating tier is the Mid-Elevation Release Tier. Within this tier, if the August 24-Month Study projects the Lake Mead January 1 pool elevation to be greater than 1,025 feet, Lake Powell will release 7.48 MAF. If the August 24-Month Study projects the Lake Mead January 1 pool elevation to be less than or equal to 1,025 feet, Lake Powell will release 8.23 MAF. Once established in August, this Lake Powell annual release volume is set for the duration of the upcoming water year. <br>Lower Elevation Balancing Tier <br>If the August 24-Month Study projects the Lake Powell January 1 pool elevation to be less than 3,525 feet, the operating tier is Lower Elevation Balancing Tier. The release from Lake Powell is set to balance the contents of Lakes Powell and Mead by the end of the upcoming water year, but will not be greater than 9.5 MAF and not less than 7.0 MAF. ";
  BEGIN

    RULE                 "Set Lower Balancing Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Lower Elevation Balancing Tier. <br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND "TierIs"( "Lower", @"t", FALSE ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "AUTHOR, DATE: Unknown<br><br>TP 20171017: Removed Setting the volume for the first water year, only sets outyear volumes now<br>S.Baker, 20180924: Added new Execution Constraint that looks at TierIs(). This allows the removal of the IF statement.<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "For August timestep with Lower Balancing Release Tier in next outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t + 2" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{e337f335-de97-4570-b3be-44b2ff132897}";;

    RULE                 "Set Mid-Elevation Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Mid-Elevation Tier for Out Years. <br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND "TierIs"( "Mid", @"t", FALSE ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170718: Added &quot;OR StartMonthIsSeptember()&quot; to condition originally for August; Sarah B. discovered this error and proposed the fix<br><br>TP, 20171017: Removed any setting of the First water year from this Rule<br><br>S.Baker, 20180924: Added new Execution Constraint that looks at TierIs(). This allows the removal of the IF statement.<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation).<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "In August with Mid-elevation tier for the next outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Current Year" ) ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF;

      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{0842e232-37ba-4aec-a27b-581fe16ea9aa}";;

    RULE                 "Refine Equalization Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule refines the annual release volume from Powell when either the Equalization Tier or Upper Elevation Balancing Tier B3 branch is operative for setting the annual release from Powell.  The release needs to be refined by this rule because when it is originally set, it is a preliminary &quot;guess&quot; for the volume it will take to arrive at the appropriate final (end of water year) condition (Equalized storage volumes, or Powell at a specific pool elevation at the end of the year - see Equalization Tier logic for more details as to what the final eowy condition should be).  This volume is then released and the end of year condition is checked against what it is supposed to be.  The first guess will almost always be off by some amount because of the non-linear elements in the water balance in both Powell and Mead of Evaporation and Bank Storage.  So rather than trying to set up a calculation or mini-simulation to calculate the exact right release volume to hit the end of water year condtion the first time, the guess volume is actually released and then this rule, because it can see the results of the original release, adjusts the release volume to eliminate the deviation from the target that it observes as a result of the initial guess release.  This rule is allowed to fire multiple times in a timestep and may do so in order to hit exactly the end of water year target condition. - sc 06/21/12<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( WITH DATETIME eoyDate = IF ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
 THEN
  "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )
 ELSE
  "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )
 ENDIF COMMENTED_BY "Make sure using appropriate year value" DO
  ( "TierIs"( "Upper", @"t", TRUE ) OR "TierIs"( "Equalization", @"t", TRUE ) ) AND ( "GetRunCycleIndex"(  ) == 3.00000000 AND ( "HasRuleFiredSuccessfully"( "Set Equalization Release Volume" ) OR ( "HasRuleFiredSuccessfully"( "Set Upper Balancing Release Volume" ) AND $ "PowellData.UpperElevBalBranch" [eoyDate] == 1.30000000 ) ) ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
 ENDWITH );
    NOTES                "AUTHOR, DATE: SC, 06/21/2012<br><br>MC, 20171102: Added use of new slot PowellData.TARVTolerance to determine when refinement of TARV will stop.<br><br>S.Baker, 20180924: Added new Execution Constraint that looks at TierIs(). This allows the removal of the IF statement. Add time step run constraint to match IFs in rule.<br><br>S.Baker, 2018/10/17 & 2018/11/26: (edited #1 at later date)<br>(1) Added WITH statement to store TARV and use in IF statement to look if solved TARV was equal to previous TARV. Then, allow for setting of the PowellData.ReleaseVolumeSetFlag when TARV solved in the current iteration is equal to the previously set TARV. This is necessary for solving for the carryover release pattern from Powell. This occurs normally when TARV is not changed from 8.23 MAF. <br>(2) When calculating if the [ TARV - (CurrentAnnualRelease + VolumeDeviation) ] is within the TARV tolerance, carryover needs to be subtracted from the calculated volume. If there was a carryover volume calculated from the current year, the CurrentAnnualRelease would not account for this carryover volume that could not be released from Powell. <br>(3) When taking the MaxItem, the first IF statement needs to account for negative values for ReleaseAdjustment. This is done by taking the absolute value of ReleaseAdjustment. <br>(4) The calculation resulting from a true IF statement (in the MaxItem function) needs to account for carryover. The new TARV calculation should account be: [ CurrentAnnualRelease - Carryover(from last year if not UEB) + Release Adjust + Carryover(from current year) ] <br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      IF_STATEMENT (( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) ) COMMENTED_BY "At Start Timestep for initial water year when release tier is either Upper Elevation Balancing or Equalization") THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t" ) )) DO
            IF_STATEMENT ("Abs"( ReleaseAdjustment ) > $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            WITH_STATEMENT (NUMERIC PowellnewTARV = "MaxItem"( { $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] + ReleaseAdjustment , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } )) DO
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := PowellnewTARV;

          DESCRIPTION          "If TARV solved in this rule is equal to the previous TARV solved, then set the <br>ReleaseVolumeSetFlag. This allow carryover releases to be set if necessary.  <br>";
      IF_STATEMENT (PowellnewTARV == $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Check in August timestep or StartMonth of September with UEBT or Equalization for outyear";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  )) THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t + 2" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t + 2" ) )) DO
            IF_STATEMENT ("Abs"( VolumeDeviation ) > 0.00000000 "acre-feet") THEN
            WITH_STATEMENT (NUMERIC CurrentAnnualRelease = FOR ( DATETIME dates IN "GetDates"( "OffsetDate"( @"24:00:00 September Max DayOfMonth, Next Year", - 11.00000000, "1 months" ), @"24:00:00 September Max DayOfMonth, Next Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Outflow" [dates], dates )
 ENDFOR) DO
          DESCRIPTION          "MC, 20171102: This version added to handle carryover situation by setting ReleaseVolumeSetFlag <br>";
      IF_STATEMENT ("Abs"( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] - ( CurrentAnnualRelease + VolumeDeviation ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) + 1.00000000 "year" )] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) ) > ( $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) COMMENTED_BY "The tolerance of the TARV slot; if the proposed change is less than this value the slot value won't change <br>") THEN
            WITH_STATEMENT (NUMERIC PowellnewTARV = "MaxItem"( { IF ( "Abs"( ReleaseAdjustment ) > 0.00000000 "acre-ft" )
 THEN
  ( CurrentAnnualRelease - IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 999.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] )
  ENDIF COMMENTED_BY "Remove the Carryover That has been Added from last year Unless an Equalization Tier is the <br>current tier. <br>" ) + ReleaseAdjustment + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) + 1.00000000 "year" )] )
 ELSE
  $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] + ReleaseAdjustment
 ENDIF , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } )) DO
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := PowellnewTARV;

            IF_STATEMENT (PowellnewTARV == $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )]) THEN
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{004129ca-00d8-4c75-a919-5b276b24b972}";;

    RULE                 "Set Upper Balancing Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Upper Elevation Balancing Tier for out years. It also sets the Upper Elevation Balancing Branch, which indicates the conditions controlling the release volume, and resets the Release Tier and the Controlling Equalization Condition if necessary (UEB Branch = 1.3)<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.UpperElevBalBranch; PowellData.ReleaseTier; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "TierIs"( "Upper", @"t", FALSE ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "AUTHOR, DATE: Unknown<br><br>SB, 20190712: Added NaNToZero to PowelltoMead.Carryover() so rule doesnt fail. <br><br>MC, 20161215: In the conditional statement checking for EqualizationTeirCalculationForRelease, changed PowellToMeadData.AugEOYPowellPEProjection[meadProjectionDate] to Powell.Pool Elevation[DateToCheckEOWYElevation(@&quot;t&quot;,TRUE)]. The check needs to be on the EOWY pool elevation, not the previous year's projected EOY pool elevation, because this is checking to see if the decision tree should follow the branch from Upper Elevation Balancing to Equalization. I had incorrectly changed the date used when adding the carryover functionality.<br><br>MC, 20170511: The IsYearDemandVariabilityAndRunCycle4 condition will never be met because the rule does not execute in Run Cycle 4 due to the Execution Constraints<br><br>TP, 10/17/2017: Only allow out year to be set by this rule<br><br>MC, 20171102: This rule was changed by Tony to only operate on out years after the addition of two new rules that set WY1 only; I added IF-ELSE version to only set Release flag if NOT in EQ from UEB<br><br>S.Baker, 20180829: Added function 'GetMeadProjectedPoolElevation' instead of using Mead.Pool Elevation. Also, edited the function 'UpperEleavationBalancingBranchCalculation' to have the correct number of inputs. <br>S.Baker, 20180924: Added new Execution Constraint that looks at TierIs(). This allows the removal of the IF statement.<br>S.Baker, 20180925: Replaced function 'GetMeadProjectedPoolElevation' with function 'GetProjectedPoolElevation'.<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "In August or September start month with UEBT for outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", FALSE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) )
 THEN
  "MaxItem"( { ( GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "DateToCheckEOWYElevation"( @"t", FALSE ) )] ) , 8230000.00000000 "acre-feet" } )
 ELSE
  IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Current Year" ) ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1075.00000000 "ft" )
  THEN
   "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ELSE
   "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ENDIF COMMENTED_BY "Determine which branch of UEBT to follow"
 ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue...";

    DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", FALSE ) )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{a693c163-6bf2-41f9-b83f-93d706c536d3}";;

    RULE                 "Set Equalization Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for out years when the Release Tier is Equalization. It also calculates and sets the Controlling Equalization Condition slot, which indicates the equalization condition that dictated the volume to be released.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "TierIs"( "Equalization", @"t", FALSE ) AND $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 0.00000000 AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only executes in Run Cycle 3; at the Start Timestep in September or in any August; with <br>a timestep more than 2 away from the model run finish; and if the rule has not already fired <br>successfully for the timestep and only sets volumes in out years <br>" );
    NOTES                "AUTHOR, DATE: Unknown<br>Initial changes: sc 02/02/11;TP 08/20/2014; MC, 20170511; TP 10/17/2017  <br><br>S.Baker, 20180924: Added new Execution Constraint that looks at TierIs(). This allows the removal of the IF statement. Disabled PowellData.ReleaseVolumeSetFlag since this flag should be set in the Refine Equalization rule. <br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "MaxItem"( { GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , 8230000.00000000 "acre-feet" } );

      $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

    INACTIVE      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{9ba2115d-0379-411e-a5b3-c5ea3e72e673}";;

    RULE                 "Set Release Tier";
    DESCRIPTION          "DESCRIPTION: This rule fires at the Start Timestep and in August timesteps to set the Powell Release tier, as well as preliminarily setting the Upper Elevation Balancing Branch and Controlling Equalization Condition values to 999<br><br>SLOTS SET: PowellData.ReleaseTier; PowellData.UpperElevBalBranch; PowellData.ControllingEqualizationCondition<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination<br>S.Baker, 20180924: Added IsInput(TARV) constraint to execution constraints and removed from each IF statement in rule.<br>S.Baker, 20180925: Changed order of rules. Moved &quot;Set Release Tier&quot; to a higher priority than &quot;Preliminary Set Out Year Release Volume to 8.23MAF&quot;. This doesn't cause problems in the normal Powell policy group since the rule &quot;Set Release Tier&quot; doesn't have the EOCY Powell Pool Elevation. Therefore, the rule &quot;Set Release Tier&quot; is skipped until the rule &quot;Preliminary Set Out Year Release Volume to 8.23MAF&quot; has executed successfully. The rule priorities were changed to make the ruleset more efficiently. <br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Model needs to set the teir for the following water year if current timestep is August. <br>";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND @"t + 2" IN "WaterYearDatesByGroup"( 2.00000000 )) THEN
            WITH_STATEMENT (NUMERIC Carryover = NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] )) DO
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - Carryover )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( IF ( @"t" == @"Start Timestep" )
 THEN
  $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t + 2", TRUE )]
 ELSE
  EffectivePoolElevation
 ENDIF, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "The model will set the tier for the third year of the model run (second out year)";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 3.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Third out year of the model run";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 4.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Fourth out year of model run";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 5.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Fifth out year of model run if it exists in the forecast";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 6.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{f9011329-c1b8-44d2-af80-f51d7715c21e}";;

    RULE                 "Preliminary Set Out Year Release Volume To 8.23MAF";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "AUTHOR, DATE: SC, 03/25/2011<br>MC, 20160728: Changed the local variable &quot;watYearIndex&quot; name to &quot;waterYearNumber&quot; for consistency with the rule Set Powell Outflow; make a function to do the calculation?; added the setting of Powell.Outflow values for testing with new carryover functionality<br>MC, 20170405: Can add use of user-defined function GetWaterYearNumber in calculation of local varaible waterYearNumber<br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.<br>S.Baker, 20180925: Changed order of rules. Moved &quot;Set Release Tier&quot; to a higher priority than &quot;Preliminary Set Out Year Release Volume to 8.23MAF&quot;. This doesn't cause problems in the normal Powell policy group since the rule &quot;Set Release Tier&quot; doesn't have the EOCY Powell Pool Elevation. Therefore, the rule &quot;Set Release Tier&quot; is skipped until the rule &quot;Preliminary Set Out Year Release Volume to 8.23MAF&quot; has executed successfully. The rule priorities were changed to make the ruleset more efficiently. <br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      WITH_STATEMENT (NUMERIC waterYearNumber = ( "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF ) COMMENTED_BY "See notes on this calculation in Preliminarily Set Navajo Outflow to Desired Base Flow") DO
            WITH_STATEMENT (NUMERIC AvailablePowellWater = ( IF ( "GetMonth"( @"Start Timestep" ) == 9.00000000 )
 THEN
  $ "Powell.Storage" [@"t - 1"]
 ELSE
  $ "Powell.Storage" [@"t + 1"]
 ENDIF COMMENTED_BY "MC, 20170510: I don't understand the timesteps used for the <br>below condition" + FOR ( DATETIME date IN "WaterYearDatesByGroup"( waterYearNumber ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Inflow" [date], date )
 ENDFOR ) COMMENTED_BY "This is added to check that in years when Powell might go very low, the model won't bomb out <br>when setting the preliminary release when Powell is low. TP 1/22/2013<br>") DO
            WITH_STATEMENT (DATETIME WY_EndOfCalendarYearDate = "Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), waterYearNumber - 1.00000000, "1 years" ) )) DO
            WITH_STATEMENT (NUMERIC VolumeToRelease = "Min"( "MaxItem"( { 8230.00000000 "1000 acre-feet" , WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  "Min"( 8230.00000000 "1000 acre-feet", releaseTable ["AnnualTotal", "NumColumns"( releaseTable ) - 2.00000000] )
 ENDWITH COMMENTED_BY "Ensure release enough so Powell doesn't exceed max pool elevation" , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" [WY_EndOfCalendarYearDate] ) COMMENTED_BY "User input minimum annual release volume" } ), AvailablePowellWater )) DO
            IF_STATEMENT (NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", WY_EndOfCalendarYearDate )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" [WY_EndOfCalendarYearDate] := VolumeToRelease;

      END_IF_STATEMENT;

          INACTIVE    DESCRIPTION          "Set Powell.Outflow values based on preliminary Target Annual Release Volume";
      IF_STATEMENT (NOT IsNaN $ "Powell.Outflow" ["RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 AND @"t" == @"Start Timestep" )
 THEN
  waterYearNumber
 ELSE
  waterYearNumber - 1.00000000
 ENDIF ) )]) THEN
            FOREACH (LIST dateRelease IN "GetPowellReleasesCorrectedForBypass"( "Sort"( "GetPowellMonthlyReleases_v2"( "WaterYearDatesByGroup"( waterYearNumber ), VolumeToRelease ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{384fa5e9-52e1-4d86-8e40-4f9e0c257d01}";;

    RULE                 "Set WY1 Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for the first WY for any release Tier designation. It also calculates and sets the Controlling Equalization Condition slot, which indicates the condition that dictated the volume to be released based on which Tier has been set. <br><br>SLOTS SET: Some combination of the following - PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition; PowellData.UpperElevBalBranch<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only executes in Run Cycle 3; at the Start Timestep for only the first WY;  and if the rule <br>has not already fired successfully for the timestep <br>" );
    NOTES                "AUTHOR, DATE: Unknown<br>Initial changes: SC 02/02/11;TP 08/20/2014; MC, 20170511; TP 10/13/2017  <br><br>TP: 20171017: Added and set the rule to only set the first water year.<br><br>S.Baker, 20180829: Edited the function 'UpperEleavationBalancingBranchCalculation' to have the correct number of inputs. Edited setting of 'PowellData.UpperElevBalBranch to check if this value is input before trying to set it. This issue was initially causing this rule to exit without setting values. <br>S.Baker, 20180921: Removed run cycle constraint in rule (2nd IF). Removed IF @t = start timestep within rules since this is an execution constraint. Added IsInput(TARV) constraint to execution constraints and removed from each IF statement in rule.<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      IF_STATEMENT ("TierIs"( "Equalization", @"t", TRUE ) COMMENTED_BY "Initial water year, in an Equalization Condition in Start Year <br>") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , 8230000.00000000 "acre-feet" } );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep in Run Cycle 3 with UEBT in Start Year";
      IF_STATEMENT ("TierIs"( "Upper", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := WITH DATETIME meadProjectionDate = IF ( @"t" <= @"September 30" )
 THEN
  @"24:00:00 December 31, Previous Year"
 ELSE
  @"24:00:00 December 31, Current Year"
 ENDIF DO
  IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", TRUE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.30000000 ) )
  THEN
   GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
  ELSE
   IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" [meadProjectionDate] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) ) >= 1075.00000000 "ft" OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND NOT $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.20000000 ) )
   THEN
    "Max"( "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ELSE
    "Max"( "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ENDIF COMMENTED_BY "Determine which branch of UEBT to follow"
  ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue..."
 ENDWITH;

          DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = IF ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) )
 THEN
  $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]
 ELSE
  "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
 ENDIF) DO
          DESCRIPTION          "Check if branch is input before trying to set slot <br>";
      IF_STATEMENT (NOT "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := upperElevBranch;

      END_IF_STATEMENT;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

            IF_STATEMENT (NOT "IsInput"( $ "PowellData.ControllingEqualizationCondition", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep with Mid-Elevation tier in initial water year";
      IF_STATEMENT ("TierIs"( "Mid", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF, NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep with Lower Balancing Release Tier in initial water year";
      IF_STATEMENT ("TierIs"( "Lower", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

      END_IF_STATEMENT;

    END
    UUID "{7561a941-f58b-4338-99f6-5cf62ad5033d}";;

    RULE                 "Set WY1 Release Tier";
    DESCRIPTION          "DESCRIPTION: This rule fires at the Start Timestep and in August timesteps to set the Powell Release tier, as well as preliminarily setting the Upper Elevation Balancing Branch and Controlling Equalization Condition values to 999, for the First Water Year<br><br>SLOTS SET: PowellData.ReleaseTier; PowellData.UpperElevBalBranch; PowellData.ControllingEqualizationCondition";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" AND ( "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) AND IsNaN $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] );
    NOTES                "AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination<br>TP, 20171017: Added this rule and only allow it to execute in the start timestep for the first water year<br>S.Baker, 20180924: Added IsNaN(ReleaseTier) constraint to execution constraints. <br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Model needs to set the teir for the current year if at the start timestep, regardless of month. <br>";
      $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "PowellReleaseTier"( $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )], "RelativeEOWYDate"( @"t" ) );

      IF_STATEMENT (IsNaN $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

    END
    UUID "{ccd7a271-a9bc-435b-8ca2-afb3947b3e3b}";;

    RULE                 "Preliminary Set WY1 Release Volume To 8.23MAF";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) );
    NOTES                "AUTHOR, DATE: SC, 03/25/2011<br>MC, 20160908: Previously added SumFlowsToVolume(...) to MaxItem; added IF-ELSE to deal with October when no previous WY release would have occurred<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.<br>S.Baker, 20180924: Added IsInput(TARV) constraint to execution constraints. <br>S.Baker, 2018/10/17: Changed column number in releaseTable[AnnualVolume, Ncol - 3]<br>MTOM was failing in testbed runs in this rule in high inflow years when Powell was trying to release a large volume. In the historical run of 1983-06, the model aborted since it sets the initial TARV to 30 MAF based on the condition releaseTable[AnnualVolume, Ncol ? 2].  This caused the model to look for too high of upper bound in the function ?CalculatePowellMonthlyRelease?.  The upper bound was being reset in function 'FindRemainingReleaseUpperBoundColumn' by adding + 1 index which cause model to look for table index that didn?t exist. When we use Ncol ? 3, the TARV is initially set to 20 MAF and MTOM runs successfully finding a realistic TARV (18 MAF). <br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { 8230.00000000 "1000 acre-feet" , WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  "Min"( "CalcReleaseForMaxPoolElevation"( "WaterYearDatesByGroup"( 1.00000000 ) ), releaseTable ["AnnualTotal", "NumColumns"( releaseTable ) - 3.00000000] )
 ENDWITH COMMENTED_BY "Ensure enough water released so Powell does not exceed max pool elevation" , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) COMMENTED_BY "User input min annual volume was added to allow overriding automatic determination" , IF ( "GetMonth"( @"t" ) != 10.00000000 )
 THEN
  "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( @"t", "MonthsSinceEOWY"( @"t" ), "-1 months" ), @"Start Timestep - 1" )
 ELSE
  0.00000000 "acre-foot"
 ENDIF COMMENTED_BY "Ensure TARV is not less than volume already released in water year" } );

    END
    UUID "{9b30a316-5de8-44fc-88d2-411206e90a9d}";;

    RULE                 "Set Powell Outflow";
    DESCRIPTION          "DESCRIPTION: In most months, interpolate values from the monthly release table using the current value of annual release volume. In August and September the annual release volume has already been set for the subsequent water year, so use the previous water year's annual volume. <br><br>SLOTS SET: Powell.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetRunCycleIndex"(  ) >= 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" );
    NOTES                "AUTHOR, DATE: Unknown<br><br>SB, 20190712: Edited how carryover is set. Added IF so carryover is only set during EQ or UEBT. This is what is done in CRSS. Carryover was causing this rule to reach max executions when Powell and Mead were at very low pool elevations. <br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND NOT IsNaN $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )]) THEN
            WITH_STATEMENT (LIST PowellOutflowsAndCarryover = "GetPowellReleasesCorrectedForBypass"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( 1.00000000 ) ) )) DO
          DESCRIPTION          "Set the outflow for the initial water year, checking for the necessity of bypass based on pool elevations";
      FOREACH (LIST dateRelease IN PowellOutflowsAndCarryover) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

          DESCRIPTION          "Track carryover only if Powell is in UEBT or Equalization, not LEBR or MEBR  <br>";
      IF_STATEMENT ("TierIs"( "Equalization", @"t", TRUE ) OR "TierIs"( "Upper", @"t", TRUE )) THEN
            WITH_STATEMENT (NUMERIC iterMax = ( LENGTH PowellOutflowsAndCarryover ) - 1.00000000) DO
            WITH_STATEMENT (DATETIME CarryoverYear = "OffsetDate"( "Dec31ofYear"( GET @INDEX 0.00000000 FROM GET @INDEX iterMax FROM PowellOutflowsAndCarryover ), 12.00000000, "1 Months" )) DO
            $ "PowellToMeadData.CarryoverVolume" [CarryoverYear] := "Max"( "Floor"( GET @INDEX 3.00000000 FROM GET @INDEX iterMax FROM PowellOutflowsAndCarryover, 1.00000000 "acre-feet" ), 0.00000000 "acre-feet" );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      WITH_STATEMENT (NUMERIC waterYearNumber = ( "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF ) COMMENTED_BY "Calculate water year number for outyears") DO
            WITH_STATEMENT (DATETIME WaterYear = "Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            IF_STATEMENT ("IsInput"( $ "PowellData.TargetAnnualReleaseVolume", WaterYear )) THEN
            FOREACH (LIST dateRelease IN "Sort"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      ELSE
            IF_STATEMENT (( NOT IsNaN $ "PowellData.TargetAnnualReleaseVolume" [WaterYear] ) COMMENTED_BY "TARV for waterYearNumber has been set" AND ( NOT IsNaN $ "Powell.Outflow" ["RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( IF ( ( "GetMonth"( @"Start Timestep" ) > 9.00000000 AND @"t" == @"Start Timestep" ) COMMENTED_BY "in StartTimestep>Sep" )
 THEN
  waterYearNumber
 ELSE
  ( waterYearNumber - 1.00000000 ) COMMENTED_BY "in StartTimestep<=Sep OR non-StartTimestep August"
 ENDIF ) )] ) COMMENTED_BY "Outflow for Sep 30 of the current or prior water year is set (either by rule or as input)<br>MC, 20170510: I don't understand the necessity of this condition") THEN
            WITH_STATEMENT (LIST PowellOutflowsAndCarryover = "GetPowellReleasesCorrectedForBypass"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
          DESCRIPTION          "Set the monthly Powell Releases for the Water Year <br>";
      FOREACH (LIST dateRelease IN PowellOutflowsAndCarryover) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

          DESCRIPTION          "Track carryover only if Powell is in UEBT or Equalization, not LEBR or MEBR  <br>";
      IF_STATEMENT ("TierIs"( "Equalization", @"t", FALSE ) OR "TierIs"( "Upper", @"t", FALSE )) THEN
          DESCRIPTION          "If there is carryover volume in the last element of the PowellOutflowsAndCarryover List, then <br>add that to the next Water Year to be released in the next water year.  <br>";
      WITH_STATEMENT (DATETIME CarryoverYear = "Dec31ofYear"( WaterYear + 1.00000000 "year" )) DO
            $ "PowellToMeadData.CarryoverVolume" [CarryoverYear] := "Max"( "Floor"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH PowellOutflowsAndCarryover ) - 1.00000000 FROM PowellOutflowsAndCarryover, 1.00000000 "acre-feet" ), 0.00000000 "acre-feet" );

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{db2794b4-ad21-451b-99d5-cc1c1ccc2536}";;

  END
  UUID "{b598eb01-ae32-4ca3-b3e5-951d80941e68}";;

  POLICY_GROUP   "Navajo";
  DESCRIPTION    "Disclaimer: In 2016 the flow recommendations were updated and now the dam is operated to meet ?a reasonable alternative.? See the Flow Recommendations for the San Juan River (2016) prepared by the San Juan River Basin Recovery Implementation Program (SJRIP).  These operational changes have not yet been coded in CRSS?s RPL policy set. CRSS?s policy set represents operations under the earlier 2006 ROD.  <br><br>The main goals of the operations of Navajo Reservoir are to meet the diversion of NIIP water, the irrigators downstream, and other municipal and industrial uses throughout the San Juan Basin. Navajo Reservoir is operated to benefit the environmental needs of the San Juan River in accordance with the National Environmental Policy Act. The environmental requirements are detailed in the Record of Decision, 2006 (ROD). The operations target flows in a reach of the San Juan River deemed critical habitat for the endangered fish species (critical reach). Operations consist of two main periods: baseflow and spring flow.  <br><br>Navajo must always hit baseflow targets. In the spring additional water is released based on which of a set of hydrographs will get Navajo closest to its desired EOWY target elevation (6,065?; NavajoData.EOWYTargetPE[]). In very wet years, if these ?preset? hydrographs are not enough to hit the target Navajo will extend the spring peak either earlier in the year or later. In dry years, the spring flow may not occur, I.e., base flows continue through the spring flow period.   <br><br>The rules fist set the base release to the minimum release allowed by the ROD (Set Base Release rule). If baseflow release was not enough to meet the target baseflow or a user was shorted a supplemental release is added to the outflow (Supplement Base Release rule) in order to achieve the base flow target at the Bluff gage.   <br><br>Navajo has 5 peak release patterns (NavajoData.SpringPeakReleaseData[]), with the first being no peak release; each peak release pattern releases more water (higher/longer peak releases) than the previous pattern. The peak release pattern that results in the EOWY elevation closest to the desired elevation is set (Set Peak Release Level). The selected peak release pattern can vary month-to-month from January to May In June if a peak release has started then there will at least be some peak release so the pattern cannot change to no peak release, but any other changes are allowed. July?s pattern is always equal to June's.   <br><br>The current monthly baseflow release is increased by the spring release volume during the spring period April ? June (Spring Peak Release for Flow Recommendations rule).  Release are extended into March if the projected EOWY PE exceeds the EOWY Target PE even with the highest peak release pattern (Determine if Spring Peak Extension is Required and Extend Spring Peak Release for PE Control rules). In  June, if no peak release has started, and the projected EOWY elevation exceeds the EOWY Target elevation we must extend the spring peak release into June & July.   <br><br>If the calculated elevation exceeds the maximum elevation 6085? Navajo must release to elevation 6082?, if possible this is done without spilling (Flow Recommendation Covered Flood Control and Dam Protection Flood Control rules). <br><br><br><br>";
  ACTIVE         TRUE;
  NOTES          "SB, 20180501: Old 1999 spring peak release operational protocol. Need to impliment new spring peak release method.<br><br>The main goals of the operations of Navajo Reservoir are to benefit the environmental needs of the San Juan River, the irrigators downstream of Navajo Reservoir, the diversion of NIIP water from Navajo Reservoir, and other municipal and industrial uses throughout the San Juan Basin. The environmental requirements are detailed in Flow Recommendations for the San Juan River, May 1999 (1999 Flow Recommendations) prepared by the San Juan River Basin Recovery Implementation Program (SJRIP). A general overview of the 1999 Flow Recommendations from Chapter 8 of the document includes: <br>         Flows greater than 10,000 cfs during spring runoff must flow for a minimum of 5 days between March 1 and July 31 in 20% of the years with a maximum interval of 11 years. <br>         Flows greater than 8,000 cfs during spring runoff must flow for a minimum of 10 days between March 1 and July 31 in 33% of years with a maximum interval of 7 years. <br>         Flows greater than 5,000 cfs during spring runoff must flow for a minimum of 21 days between March 1 and July 31 in 50% of the years with a maximum interval of 5 years. <br>         Flows greater than 2,500 cfs during spring runoff must flow for a minimum of 10 days between March 1 and July 31 in 80% of the years with a maximum interval of 3 years. <br>         Peak flows must occur within 5 days of the historic mean peak date of May 31 (based on modeling for the period 1929 ? 1993). <br>         Weekly target base flows are 500 cfs but range between 500 and 1,000 cfs where the actual target flow is the average of the weekly base flow at three of four stream flow gaging stations on the San Juan River below Navajo in accordance with the Biological Opinion. <br>         Flood control releases will be handled as high magnitude, short duration spikes and releases when the flood control rules require except the release shall not occur earlier than September 1 unless necessary for protection of life and property. <br>The operations at Navajo Reservoir call for a spring peak flow to occur between April and July and base flow operations to occur the rest of the year. The spring peak is determined using the flow chart in Figure 8.1 of the 1999 Flow Recommendations document. The date of the spring peak release is determined by the flow from the Animas River downstream of Navajo Reservoir and is within the specified time range of the 1999 Flow Recommendations. <br>During base operations there is a weekly minimum flow target of an average of 500 cfs at each of four gaging stations downstream of the confluence with the Animas River: Farmington, Shiprock, Four Corners, and Bluff. The target flow range at each of the four gages is between 500 and 1,000 cfs; the modeled flows depend on the hydrologic conditions in the basin and the local inflows between Navajo Reservoir and the gaging stations. ";
  BEGIN

    RULE                 "Fall Peak Release ";
    DESCRIPTION          "DESCRIPTION: This Rule Uses the already set pool elevations for Navajo from the prevoius rule and uses the October Pool elevation to check if the elevation is above 6,065 ft.  If the volume at the beginning of October is above 6,065, then increase the September release so the pool elevation at the beginning of October is 6,065.  The reason we are looking at the October pool elevation is in the rare event that October is Wet, then the pool elevation in September will allow for the high flows in October to result in a Pool Elevation of 6,065 heading into the Winter months.  If we use the September Pool elevation and don' t release enough the system might have to release more the next spring than needed. <br><br>This rule only fires in months after the Spring Peak Release cannot be set (July - September) and only after the model has the opportunity to set outflows from Navajo at the maximum 1,000 cfs per day for the months of July - September. <br><br>SLOTS SET: Navajo.Outflow[September, Current Year]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetMonth"( @"t" ) >= 7.00000000 AND "GetMonth"( @"t" ) <= 9.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "AUTHOR, DATE: TP 9/13/2012<br><br>MC, 20170502: The description written by Tony suggests the rule is targeting an end of October pool elevation, but the rule is setting the September outflow to lead to a beginning of October (end of September) target pool elevation<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Retrieve the storage at the beginning of October (end of September)";
      WITH_STATEMENT (NUMERIC NavajoOctoberStorage = "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [@"24:00:00 September Max DayOfMonth, Current Year"] )) DO
          DESCRIPTION          "Retrieve the end of water year target pool elevation";
      WITH_STATEMENT (NUMERIC TargetPEStorage = "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" ["Dec31ofYear"( @"24:00:00 September Max DayOfMonth, Current Year" )] )) DO
          DESCRIPTION          "If the October storage is greater than that of the target, increase the release to meet the target";
      IF_STATEMENT (NavajoOctoberStorage > TargetPEStorage) THEN
            $ "Navajo.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"] := $ "Navajo.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"] + "VolumeToFlow"( NavajoOctoberStorage - TargetPEStorage, @"24:00:00 September Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{e13a04a1-4575-487e-91f0-7b70a7ada925}";;

    RULE                 "Dam Protection Flood Control";
    DESCRIPTION          "DESCRIPTION: If Navajo Pool Elevation is in threat of going above the maximum pool elevation (6,082 ft) then release the amount of outflow to reduce the pool elevation to the max pool elevation. This rule is a flood protection rule. <br><br>SLOTS SET: Navajo.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) );
    NOTES                "AUTHOR, DATE: Unknown<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      WITH_STATEMENT (DATETIME EndOfWY = @"24:00:00 September 30, Current Year") DO
            IF_STATEMENT ($ "Navajo.Pool Elevation" [] > $ "NavajoData.PostDamProtectionPE" []) THEN
          DESCRIPTION          "Calculate list of lists of form &lcub;Modified outflow, Outflow volume modification, Volume released to achieve dam protection&rcub;";
      WITH_STATEMENT (LIST damProtectionNavajo = "NavajoAboveMaxPEOperations"(  )) DO
          DESCRIPTION          "Update outflow";
      $ "Navajo.Outflow" [] := GET @INDEX 0.00000000 FROM damProtectionNavajo;

            $ "NavajoData.DamProtectionFlag" [@"t"] := 1.00000000;

          DESCRIPTION          "Store annual volume released for dam protection";
      $ "NavajoData.VolumeReleasedForDamProtection" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM damProtectionNavajo;

            IF_STATEMENT (@"t" < EndOfWY) THEN
            WITH_STATEMENT (NUMERIC lessRelFromNav = GET @INDEX 2.00000000 FROM damProtectionNavajo) DO
          DESCRIPTION          "Reduce remaining WY outflows to account for released volume, but not below base release value";
      FOREACH (DATETIME date IN @"t + 1" TO EndOfWY) DO
            WITH_STATEMENT (NUMERIC numberOfMonths = "GetMonth"( EndOfWY ) - "GetMonth"( @"t" )) DO
            $ "Navajo.Outflow" [date] := "Max"( $ "Navajo.Outflow" [date] - "VolumeToFlow"( lessRelFromNav / numberOfMonths, date ), $ "NavajoData.BaseRelease" [] );

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{252de405-ae8d-4e31-a66d-547d1115e403}";;

    RULE                 "Reduce Outflow and Diversions if Navajo is below Min Level";
    DESCRIPTION          "DESCRIPTION: If the reservoir is in threat of going below 5,990 ft, apply shortage sharing to the outflow of Navajo and NIIP diversions.<br><br>SLOTS SET: Navajo.Outflow; NavajoIndianIrrigationProjectNIIP.Diversion<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "IsLowFlowAdjustmentNecessary"(  ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) );
    NOTES                "AUTHOR, DATE: Unknown<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      FOREACH (LIST DateDiffR IN "DetermineLowFlowsatNavajo"(  )) DO
            $ "Navajo.Outflow" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 1.00000000 FROM DateDiffR;

            $ "NavajoIndianIrrigationProjectNIIP.Diversion" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 2.00000000 FROM DateDiffR;

          INACTIVE      $ "NavajoIndianIrrigationProjectNIIP.Depletion Requested" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 2.00000000 FROM DateDiffR;

      ENDFOREACH;

    END
    UUID "{c4aa7edc-31a4-4ac6-b8db-635f00f72db7}";;

    RULE                 "SumNavajoOutflowtoMonthly";
    DESCRIPTION          "DESCRIPTION: Solve Navajo Daily outflow on the data object and set the monthly outflow on the Reservoir simulation object.  This rule only on the start timestep and in March timesteps.<br><br>SLOTS SET: Navajo.Outflow<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "AUTHOR, DATE: TP 9/30/2015<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      WITH_STATEMENT (DATETIME endDate = IF ( "GetMonth"( @"t" ) < 3.00000000 )
 THEN
  @"24:00:00 February Max DayOfMonth, Current Year"
 ELSE
  @"24:00:00 February Max DayOfMonth, Current Year + 12"
 ENDIF) DO
            IF_STATEMENT (@"t" == @"Start Timestep") THEN
            FOREACH (DATETIME date IN "GetDates"( @"t", endDate, "1 months" )) DO
            $ "Navajo.Outflow" [date] := "VolumeToFlow"( "DetermineNavajoMonthlyFlowVolumeNew"( date ), date );

      ENDFOREACH;

      END_IF_STATEMENT;

            IF_STATEMENT ("MonthIs"( { "March" } )) THEN
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 31, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 months" )) DO
            $ "Navajo.Outflow" [date] := "VolumeToFlow"( "DetermineNavajoMonthlyFlowVolumeNew"( date ), date );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{95fb933b-6275-42ad-8e67-e8476f0e23ce}";;

    RULE                 "March through July Daily Release";
    DESCRIPTION          "DESCRIPTION: Calculate the Daily release given the policy constraints outlined by the Flow recomendation document from the San Juan Flow Recommendations and recommendations on the policy by the Bureau of Reclation.  These flows will be based on the policy from the release level calculated and not the actual available water. That will come after a scale value is applied. <br><br>SLOT SET: NavajoData.MarchThruJulyDaily<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP, 20120531 (?)<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Determine the Daily Releases from Navajo Reservoir for the release level and spring peak volumes";
      FOREACH (DATETIME date IN "GetDates"( @"t - 1", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.MarchThruJulyDaily" [date] := "DailyOutflowsForNavajo"( date, $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoData.NoseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoData.ExcessOfRelease" ["Dec31ofYear"( @"t" )] );

      ENDFOREACH;

    END
    UUID "{0193b39c-4e50-4bf7-bffc-f22637d74f87}";;

    RULE                 "DetermineReleaseLevelValues";
    DESCRIPTION          "DESCRIPTION: Determine the release level (0-4) for the spring release based on the calculated available flow to achieve the EOWYTargetPE. The determination of level is based on the values in the SpringPeakReleaseLevels table.  The Rule sets the Release Level, the Spring Peak Release Volume, the Nose Level (If Applicable), the Nose Volume (if Applicable), and the excess of a Nose Volume (If Applicable).<br><br>SLOTS SET: NavajoData.ReleaseLevel; NavajoData.SpringPeakRelease; NavajoData.NoseLevel; NavajoData.SpringPeakNose; NavajoData.ExcessOfRelease<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetRunCycleIndex"(  ) == 1.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "March" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) );
    NOTES                "AUTHOR, DATE: TP, 5/31/2012 (?)<br><br>MC, 20170717: Reorganized rule to combine the cases for Month == March and (Start Timestep AND Month < Oct)<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Determines the Release Levels, Nose Levels and Volumes to be set to meet the Navajo Target elevation <br>for the end of September.  This rule only executes on the start timestep or in March.";
      WITH_STATEMENT (LIST EoWYRelLevel = "DetermineNavajoEoWYReleaseLevel"( "Dec31ofYear"( @"t" ) )) DO
            IF_STATEMENT (@"t" == @"Start Timestep" AND "GetMonth"( @"t" ) >= 10.00000000) THEN
          DESCRIPTION          "Set all values to zero";
      IF_STATEMENT (NOT "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( @"t" ) )) THEN
            $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )] := 0.00000000;

      END_IF_STATEMENT;

            $ "NavajoData.SpringPeakRelease" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

            $ "NavajoData.NoseLevel" ["Dec31ofYear"( @"t" )] := 0.00000000;

            $ "NavajoData.SpringPeakNose" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

            $ "NavajoData.ExcessOfRelease" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

      ELSE
          DESCRIPTION          "Month is March or (Start Timestep AND Month < 10) <br>";
      IF_STATEMENT (NOT "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( @"t" ) )) THEN
            $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM EoWYRelLevel;

      END_IF_STATEMENT;

            $ "NavajoData.SpringPeakRelease" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM EoWYRelLevel;

            $ "NavajoData.NoseLevel" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM EoWYRelLevel;

            $ "NavajoData.SpringPeakNose" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM EoWYRelLevel;

            $ "NavajoData.ExcessOfRelease" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM EoWYRelLevel;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{ae014cdc-e3af-453b-a984-47582f24ec07}";;

    RULE                 "Preliminarily Set Navajo Outflow to Desired Base Flow";
    DESCRIPTION          "DESCRIPTION: This rule sets the outflow from Navajo for the current timestep to the end of February of the next year. The outflow is set to the greater of the Base Release or what is necessary, together with the Animas contribution, to meet the downstream flow targets. Doing this allows Navajo to solve for the Available water calculation.<br><br>SLOTS SET: Navajo.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "AUTHOR, DATE: Unknown<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "For the current timestep to the End of February of the next year, set the outflow from Navajo to the greater of <br>the Base Release from Navajo or what is necessary to meet the downstream flow targets with the Animas <br>contribution. Doing this will allow Navajo to solve for the Available water calculation";
      WITH_STATEMENT (NUMERIC waterYearNumber = ( "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF ) COMMENTED_BY "This variable is not used in the body, so delete it.") DO
            WITH_STATEMENT (LIST dateList = IF ( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( @"t" ) ) AND "GetMonth"( @"t" ) < 10.00000000 )
 THEN
  @"t" TO "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12 Month", @"Finish Timestep" )
 ELSE
  @"t" TO "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12 Month", @"Finish Timestep" )
 ENDIF COMMENTED_BY "MC, 20170508: Both conditions use the same calculation?") DO
            FOREACH (DATETIME date IN dateList) DO
            $ "Navajo.Outflow" [date] := "Max"( $ "NavajoData.MinTargetBaseflow" [] - $ "AnimasRiverInflow.Animas_at_Durango" [date], $ "NavajoData.BaseRelease" [] );

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{82e1f2ad-ebbe-420b-bec3-6d7762bef2ea}";;

    RULE                 "SetNavajoDiversions";
    DESCRIPTION          "DESCRIPTION: Sets the NIIPDiversions Requested slot, the SanJuanBelowNavajo.TotalDiversion Slot, and NIIP.Fractional Return Flow Slot values based on user input.  The Fractional Inflow values will at some point need to be changed in the future to the value that would be the fractional return flow. This rule fires so that the input values in the NavajoData.NIIPAnnualRequest and NavajoData.SJDownstreamDiversions slots  are assigned if input is provided for those two slots. <br><br>SLOTS SET: SanJuanBelowNavajo.Total Diversion; NavajoIndianIrrigationProjectNIIP.Fractional Return Flow; NavajoIndianIrrigationProjectNIIP.Diversion; Azotea Tunnel.Diversion<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetRunCycleIndex"(  ) == 1.00000000 AND @"t" == @"Start Timestep" );
    NOTES                "AUTHOR, DATE: TP, 8/5/2012 (?)<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Set the Diversions for the NIIP and Azotea Tunnel to the Diversion Requests so that the <br>appropriate water is allowed to be diverted.  For the Azotea Tunnel diversion make sure a <br>minimum flow is left in the Upper San Juan River above Navajo. ";
      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (IsNaN $ "SanJuanBelowNavajo.Total Diversion" [date]) THEN
            $ "SanJuanBelowNavajo.Total Diversion" [date] := $ "NavajoData.SJDownstreamDepletions" [date, 0.00000000];

      END_IF_STATEMENT;

            $ "NavajoIndianIrrigationProjectNIIP.Fractional Return Flow" [date] := 0.00000000;

            $ "NavajoIndianIrrigationProjectNIIP.Diversion" [date] := $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [date];

            $ "Azotea Tunnel.Diversion" [date] := IF ( "Is24MonthStudy"(  ) )
 THEN
  $ "Azotea Tunnel.Diversion Requested" [date]
 ELSE
  "Min"( $ "Azotea Tunnel.Diversion Requested" [date], "Max"( $ "UpperSanJuan.Inflow" [date] - $ "NavajoData.UpperSanJuanMinFlow" [date, 0.00000000], 0.00000000 "cfs" ) )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{c2a7d396-3fd7-4241-aff3-ade982c96f28}";;

  END
  UUID "{ace26fd8-670c-4d8a-b177-5911c12384ad}";;

  POLICY_GROUP   "Flaming Gorge ";
  DESCRIPTION    "The operations of Flaming Gorge Reservoir meet the requirements detailed in the 2006 Record of Decision for the Operation of Flaming Gorge Dam Final Environmental Impact Statement (EIS) that were designed to achieve the authorized purposes of the CRSP Act while addressing environmental requirements. The 2006 ROD outlines the operational guidelines of Flaming Gorge and implements, to the extent possible, recommendations to assist in the recovery of four endangered fish species, outlined in the 2000 Flow and Temperature Recommendations for Endangered Fish in the Green River Downstream of Flaming Gorge Dam (Recommendations). Operations were updated in 2012 and continue to evolve according to the recommendations of the Flaming Gorge Technical Work Group (FGTWG). The rules in this policy group aim to approximate these operations.  <br><br>Hydrologic Classification <br><br>Hydrologic classification of the current year, from dry to wet, determines flow requirements under the EIS. Hydrologic classification for the baseflow and spring flow periods are based on April - July unregulated inflow volume?s percentage exceedance of the historical inflows. For base flow operations this is the observed April ? July volume from the previous season. For spring flow operations this is the forecasted April ? July volume for the upcoming season.  <br><br>Base Flow Operations (January-April)  <br><br>Base flow releases are set to stay below the dam?s maximum pool elevation (PE), achieve minimum flow requirements at Jensen, stay within the base flow range based on the hydrologic classification and to achieve the May 1 safe operating Upper Limit Drawdown Elevation (ULDE). Hydrologic classification (Baseflow Hydrologic Classification rule) is based on April through July unregulated inflow forecast. Releases for dam safety given wet hydrology in the Upper Green can supersede endangered fish requested flows. The Base Flow Operations rule provides the basis for these operations during January ? February. March and April operations are mostly handled by the Release to meet ULDE rule.  <br><br> Spring Flow Operations (May-July)  <br><br>Flaming Gorge Dam spring releases are timed to coincide with the presence of larval razorback sucker downstream. This is approximated based on the Yampa peak magnitude and historic Julian days to larval presence. The Flaming Gorge peak flow release volume and duration is based on the hydrologic classification. (Spring Flow Hydrologic Classification rule). Releases ramp up to peak release capacity (bypass or powerplant capacity), maintain peak capacity for a given duration, and then ramp down to baseflow. A daily hydrograph of this pattern is generated in the Set Flaming Gorge Daily April to July Schedule rule; then the Sum Daily Flaming Gorge Release Schedule to Monthly rule sets the FlamingGorge.Outflow[] monthly slot to the sum of these daily values. <br><br>Base Flow Operations (August-December)  <br><br>Base flow releases are set to the steady outflow rate to meet the May 1 ULDE,  achieve minimum flow requirements at Jensen and stay within the base flow range based on the hydrologic classification while keeping the water level below the dam?s maximum pool elevation,  (Base Flow Operations rule). Hydrologic classification is based on observed April through July unregulated inflow (Baseflow Hydrologic Classification rule).  The monthly baseflow volume is represented as a constant daily baseflow. ";
  ACTIVE         TRUE;
  NOTES          "CF, 20180501: Operations have changed since 2012 and continue to evolve according to the FGTWG. <br><br>Old Description:<br>The operations of Flaming Gorge Reservoir meet the requirements detailed in the 2006 Record of Decision for the Operation of Flaming Gorge Dam Final Environmental Impact Statement (2006 ROD) that were designed to achieve the authorized purposes of the CRSP Act while addressing environmental requirements. The 2006 ROD outlines the operational guidelines of Flaming Gorge and implements, to the extent possible, recommendations to assist in the recovery of four endangered fish species, outlined in the 2000 Flow and Temperature Recommendations for Endangered Fish in the Green River Downstream of Flaming Gorge Dam (2000 Flow and Temperature Recommendations). This report outlines the peak flow magnitudes, high flow duration, and outflow temperature recommendations for three reaches of the Green River: <br><br>Reach 1<br>Reach 1 is 65 river miles long, beginning at Flaming Gorge Dam and ending at the confluence of the Green and Yampa Rivers. Flaming Gorge Dam releases comprise the primary component of Green River flow in this reach. The peak flow requirements for Reach 1 are compiled in Table 5.4 of the 2000 Flow and Temperature Recommendations and are summarized below. <br>Peak flow magnitude of at least 4,600 cfs each year and at least 8,600 cfs in wet years (0 to 10% Exceedance) <br>  <br>The peak flow period should coincide with the spring peak and immediate post peak flows of the Yampa River <br>  <br>Reach 1 Mean baseflow magnitude requirements are established for five hydrologic year classifications: <br>o   Wet (0-10% Exceedance): between 1,800 and 2,700 cfs <br>o   Moderately Wet (10-30% Exceedance): between 1,500 and 2,600 cfs <br>o   Average (30-70% Exceedance): between 800 and 2,200 cfs <br>o   Moderately Dry (70-90% Exceedance): between 800 and 1,300 cfs <br>o   Dry (90-100% Exceedance): between 800 and 1,000 cfs <br>  <br>The daily rate of decline from the peak flow period is limited as follows: <br>o   For Wet and Moderately Wet years (0-30% Exceedance):  approximately 1,000 cfs /day <br>o   For Average years (30-70% Exceedance):  approximately 500 cfs /day <br>o   For Dry and Moderately Dry years (70-100% Exceedance):  approximately 350 cfs /day <br>Where applicable, the historic unregulated Flaming Gorge inflow between the years of 1963 and 1996 are used to determine the respective percent exceedances for the criteria established. Hydrologic classifications and percent exceedances for the Yampa River basin are established using the historic record from 1922 to 1996. This is the case for all reaches. <br><br>Reach 2<br>Reach 2 is 99 river miles in length and extends from the confluence of the Green and Yampa Rivers to the confluence of the Green and White Rivers. In this reach, Flaming Gorge Dam releases and the Yampa River are the primary contributors to river flow. Flow recommendations establish peak flow and sustained high flow requirements at the Green River at the Jensen, Utah USGS stream gage for five hydrologic year types. These requirements are established in Table 5.5 of the 2000 Flow and Temperature Recommendations and are summarized below. <br>Peak releases should coincide with the annual spring peak and immediate post peak of the Yampa River <br>  <br>Peak flow magnitude recommendations measured on the Green River at Jensen are established for five hydrologic classifications as follows: <br>o   Wet (0-10% Exceedance): at least 26,400 cfs <br>o   Moderately Wet (10-30% Exceedance): at least 20,300 cfs <br>o   Average (30-70% Exceedance): at least 18,600 cfs in one of two average years and 8,300 cfs in other average years <br>o   Dry and Moderately Dry (70-100% Exceedance): at least 8,300 cfs <br>  <br>Recommendations for the duration of peak flows are established as follows: <br>o   Wet (0-10% Exceedance): maintain at least 22,700 cfs for at least 2 weeks and 18,600 cfs for at least 4 weeks <br>o   Moderately Wet (10-30% Exceedance): maintain at least 18,600 cfs for at least 2 weeks <br>o   Average (30-70% Exceedance): maintain at least 18,600 cfs for at least 2 weeks in 1 of 4 average years <br>o   Moderately Dry (70-90% Exceedance): maintain at least 8,300 cfs for at least 1 week <br>o   Dry (90-98% Exceedance): maintain at least 8,300 cfs for at least 2 days <br>o   Extremely Dry (98-100% Exceedance): no flow duration recommendations <br>  <br>Mean baseflow magnitudes are recommended for each hydrologic classification as follows: <br>o   Wet (0-10% Exceedance): between 2,800 and 3,000 cfs <br>o   Moderately Wet (10-30% Exceedance): between 2,400 and 2,800 cfs <br>o   Average (30-70% Exceedance): between 1,500 and 2,400 cfs <br>o   Moderately Dry (70-90% Exceedance): between 1,100 and 1,500 cfs <br>o   Dry (90-100% Exceedance): between 900 and 1,100 cfs <br><br>Rate of decline from the peak flow is regulated by the rate of decline in Reach 1 and the rate of decline of the Yampa River <br>  <br>Baseflow variation should be consistent with the variability observed in the pre-dam era <br><br>Reach 3 <br>Reach 3 is 246 river miles in length and extends from the confluence of the White and Green River to the confluence of the Green and Colorado Rivers. Flow in this reach is supplemented primarily by tributary flow from the White, Duchesne, Price, and San Rafael Rivers as well as releases from Flaming Gorge Dam and flow from the Yampa River. Although independent flow recommendations were outlined for Reach 3 as well as Reaches 1 and 2, it is assumed that meeting the flow requirements in Reach 1 and Reach 2 will result in the flow requirements for Reach 3 being adequately met. ";
  BEGIN

    RULE                 "Calculate Daily Jensen Flows";
    DESCRIPTION          "DESCRIPTION: Calculates the daily Jensen flow using daily FG releases and daily Yampa flows with the assumption that FG releases are lagged one day.<br><br>SLOTS SET: KNN_MTOM.JensenDaily<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Calculates the daily Jensen flow using daily FG releases and daily Yampa flows with the assumption <br>that FG releases are lagged one day.";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.JensenDaily" [date] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  $ "KNN_MTOM.FlamingGorgeDaily" [date]
 ELSE
  $ "KNN_MTOM.FlamingGorgeDaily" [date - 1.00000000 "day"]
 ENDIF + IF ( "GetMonth"( @"t" ) >= 4.00000000 AND "GetMonth"( @"t" ) <= 7.00000000 )
 THEN
  $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date]
 ELSE
  $ "YampaRiverInflow.Yampa_at_Deerlodge" []
 ENDIF;

      ENDFOREACH;

    END
    UUID "{e9b9f76f-9ace-456e-a4dc-bc831a6b7283}";;

    RULE                 "Min Flow in Extremely Dry Years with Low Storage";
    DESCRIPTION          "Execution Constraint: NA <br>  <br>Description: Flaming Gorge releases 800 cfs to protect the remaining water in storage if Flaming Gorge pool elevation is below MinReleaseTrigger and there is extremely low hydrology (.98 exceedance). This is reduce this further via funcion constraint when FG can't release 800 cfs without draining the live storage. <br><br>The rule sets the LowReleaseFlag when FG is releasing max water in FG (second IF) or MinFlow in HClass = 0 and PE < MinReleaseTrigger (first IF). <br><br>Slots Set: FlamingGorge.Outflow, FlamingGorgeData.LowReleaseFlag Execution Constraint: Not May, June or July ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "CF, 20210220: Change FGConstrainedOutflow() to UBConstrainedOutflow(). Change rule priority to highest. <br>HP: &quot;Leadership discussions would happen long before the reservoir dropped to those levels, but for a modeling exercise: yes, staying above 5890 ft would overrule spring or baseflow operations. &quot;<br><br>CF, 20181212: Exec Const removed, rule now fires in all timesteps. Rule moved earlier in priority than Sum Daily. Added a constraint on outflow via FGConstrainedOutflow() to MinFlow. AbsoluteMinRelease no longer needed since it was changed to MinFlow of 800 cfs based on the latest FEIS according to HP.  Rule sets the LowReleaseFlag when FG is releasing max water in FG or MinFlow in HClass = 0 and PE < MinReleaseTrigger. Fixes to allow running VIC. <br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      IF_STATEMENT ($ "FlamingGorge.Pool Elevation" [] < $ "FlamingGorgeData.MinReleaseTrigger" [] AND $ "KNN_MTOM.BaseFlowHClass" [] == 0.00000000 AND NOT "MonthIs"( { "May" , "June" , "July" } ) COMMENTED_BY "CF: Old Execution Constraint <br>") THEN
            $ "FlamingGorge.Outflow" [] := "UBConstrainedOutflow"( % "FlamingGorge", $ "FlamingGorgeData.MinFlow" [] );

            $ "FlamingGorgeData.LowReleaseFlag" [] := 1.00000000;

      END_IF_STATEMENT;

    END
    UUID "{f7fdf711-46e9-4b08-8415-e511284ba19f}";;

    RULE                 "Fill Daily Flaming Gorge Releases for Months Outside of April-July";
    DESCRIPTION          "DESCRIPTION: Sets the daily FG releases and daily Yampa releases to the average monthly FG outflow and Yampa gaged outflow, respectively.<br><br>SLOTS SET: KNN_MTOM.FlamingGorgeDaily; KNN_MTOM.YampaDailyDeerlodgeDepleted<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( NOT "MonthIs"( { "April" , "May" , "June" , "July" , "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [date] := $ "FlamingGorge.Outflow" [];

            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date] := $ "YampaRiverInflow.Yampa_at_Deerlodge" [];

      ENDFOREACH;

    END
    UUID "{5e8b6416-af1e-41f9-b6b7-1099b1a9c734}";;

    RULE                 "Sum Daily Flaming Gorge Release Schedule to Monthly";
    DESCRIPTION          "Execution Constraint: April-August <br>  <br>Description: Sets FG outflow to the aggregated daily release volume.<br><br>IF daily flow summation is greater than the amount of water that is in FG reassign daily flows to only release as much water as is in FG (constant value).<br><br> <br>Slots Set: FlamingGorge.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "MonthIs"( { "April" , "May" , "June" , "July" , "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000 );
    NOTES                "CF, 20210220: Change FGConstrainedOutflow() to UBConstrainedOutflow()<br><br>CF, 20181212: Added a constraint on outflow via FGConstrainedOutflow() to allow running VIC hydrology. Change to include an IF daily flow summation is greater than the amount of water that is in FG reassign daily flows to only release as much water as is in FG (constant value).   <br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      $ "FlamingGorge.Outflow" COMMENTED_BY "Sets FG outflow to the aggregated daily release volume." [] := "UBConstrainedOutflow"( % "FlamingGorge", "VolumeToFlow"( "SumFlowsToVolume"( $ "KNN_MTOM.FlamingGorgeDaily", @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ), @"t" ) );

      IF_STATEMENT ("VolumeToFlow"( "SumFlowsToVolume"( $ "KNN_MTOM.FlamingGorgeDaily", @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ), @"t" ) > "SolveOutflow"( % "FlamingGorge", $ "FlamingGorge.Inflow" [@"t"], $ "UBRuleCurveData.ReservoirData" ["FlamingGorge", "inactiveCapacityStorage"], $ "FlamingGorge.Storage" [@"t - 1"], @"t" )) THEN
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [date] := "UBConstrainedOutflow"( % "FlamingGorge", "VolumeToFlow"( "SumFlowsToVolume"( $ "KNN_MTOM.FlamingGorgeDaily", @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ), @"t" ) );

      ENDFOREACH;

      END_IF_STATEMENT;

    END
    UUID "{7c3f5e96-c79a-44f0-a2d6-d715ed73c0f0}";;

    RULE                 "Adjust Daily for August Base Flow";
    DESCRIPTION          "DESCRIPTION: Determines if July releases were at power plant or bypass capacity during moderately wet and wet hydrology and ramps down in August.  Rule sets August releases at steady base flows or downramps from high FG releases through July 31st to August base flows. August ramp down is contained in the Flow Recommendations. <br><br>SLOTS SET: KNN_MTOM.FlamingGorgeDaily; KNN_MTOM.YampaDailyDeerlodgeDepleted<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "MonthIs"( { "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000 ) AND NOT "HasRuleFiredSuccessfully"( "ThisRule" );
    NOTES                "CF,20200104: TargetHWGivenInflowOneMonth() replaced by FGTargetHWGivenInflowOneMonth()<br><br>20201218 CF: Added NOT HasRuleFiredSuccessfully() on 'Adjust Daily for August Base Flow' rule. What happens is the Rule 95 (August Daily) is dependent on FlamingGorge.Outflow which has been solved previously by Rule 99 (Baseflow).  Rule 95 creates a daily flow list which is summed up by Rule 3 (Sum Daily) which sets FlamingGorge.Outflow which causes 95, which depends on this, to go back on the que. However this time 95 runs the Outflow is different enough that it solves a different way (first time requires August down ramping, second time does not) then we go back to rule 93 which sums something new and ad nauseam  <br><br>20191018, CF: The August rule considers if down ramping needs to occur or not. If it does then AugustDownRamp() is called which has a provision that sets the outflow required to avoid MaxPE but only after downramping has occurred. This was modified to have daily outflow to avoid MaxPE checked for to all days in August (regardless of where FG is in the down ramp). Additionally add GetFGBaseFlowMagnitude() to Aug1 max check. If down ramping does not need to occur in August than the rule set daily outflow equal to the baseflow. This was modified to have a max avoid MaxPE check. I've <br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode<br><br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH_STATEMENT (NUMERIC RampRate = $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs") DO
            WITH_STATEMENT (NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] - $ "FlamingGorge.Outflow" [] ) / RampRate * 1.00000000 "day" )) DO
            IF_STATEMENT ($ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] > $ "FlamingGorge.Outflow" [] + RampRate) THEN
          DESCRIPTION          "Multiple days of downramping required";
      FOREACH (LIST AugustFlows IN "AugustDownRamp"(  )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [GET @INDEX 0.00000000 FROM AugustFlows] := GET @INDEX 1.00000000 FROM AugustFlows;

      ENDFOREACH;

      ELSE
          DESCRIPTION          "Downramping not required";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [date] := "Max"( "GetFGBaseFlowMagnitude"(  ), "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) );

      ENDFOREACH;

      END_IF_STATEMENT;

          DESCRIPTION          "Set Daily Deerlodge Depleted";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date] := $ "YampaRiverInflow.Yampa_at_Deerlodge" [];

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{6e882952-c21d-4313-bcb3-1e3209553e31}";;

    RULE                 "Set Flaming Gorge Daily April to July Schedule";
    DESCRIPTION          "Execution Constraint: April-July <br>  <br>Description: Makes the daily date and flow list using function MakeDailyFlamingGorgeReleaseDateandFlowList and assigns it to the data object.<br><br>SLOTS SET: KNN_MTOM.FlamingGorgeDaily<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "MonthIs"( { "April" , "May" , "June" , "July" } ) AND "GetRunCycleIndex"(  ) == 2.00000000 ) COMMENTED_BY "CF,20190129: Changed to match CRSS. MTOM was only executing this in April or at start <br>timestep which wasn't setting dailyflows in later months.   <br>" );
    NOTES                "CF,20190129: Changed to match CRSS. MTOM was only executing this in April or at start timestep which wasn't setting dailyflows in later months.  <br><br>AUTHOR, DATE: Unknown<br>MC, 20170503: Should the rule fire for an August Start Timestep? No consideration for August date in rule, but will use July 1 based on logic<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      FOREACH (LIST dateandflow IN "MakeDailyFlamingGorgeReleaseDateandFlowList_LTSP"( IF ( "MonthIs"( { "April" } ) )
 THEN
  @"24:00:00 April 1, Current Year"
 ELSE
  IF ( "MonthIs"( { "May" } ) )
  THEN
   @"24:00:00 May 1, Current Year"
  ELSE
   IF ( "MonthIs"( { "June" } ) )
   THEN
    @"24:00:00 June 1, Current Year"
   ELSE
    @"24:00:00 July 1, Current Year" COMMENTED_BY "CF: July  <br>"
   ENDIF
  ENDIF
 ENDIF )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [GET @INDEX 0.00000000 FROM dateandflow] := GET @INDEX 1.00000000 FROM dateandflow;

      ENDFOREACH;

    END
    UUID "{24d265a0-4531-4f3d-9a46-1799d67e85bf}";;

    RULE                 "Release to Meet ULDE";
    DESCRIPTION          "Execution Constraint: March, April <br>  <br>Description: Release at whatever rate is necessary to meet the May 1 upper limit draw-down elevation (ULDE) from the EIS.  Note that if the reservoir is already below the ULDE, then the outflow will be constrained to the minimum base flow for the current year type. <br><br>HP: March-April are the only months that do not have BC constraints regulated by the ROD. The constraint here is a physical constraint, no magnitude constraints are applied to Mar-Apr unlike other months (Baseflow Operations Rule) <br>  <br>Slots Set: FlamingGorge.Outflow ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "MonthIs"( { "March" , "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000 );
    NOTES                "CF, 20210220: Change FGConstrainedOutflow() to UBConstrainedOutflow()<br><br>CF, 20181212: Added a constraint on outflow via FGConstrainedOutflow() to allow running VIC hydrology.<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "If it is March or April, then release whatever necessary to meet the May 1 ULDE";
      $ "FlamingGorge.Outflow" [] := "UBConstrainedOutflow"( % "FlamingGorge", "GetFGBaseFlowMagnitudeUnconstrained"(  ) );

    END
    UUID "{6fff01bb-f66b-467b-8c81-3ede4a955404}";;

    RULE                 "Spring Flow Hydrologic Classification";
    DESCRIPTION          "DESCRIPTION: Sets the spring flow classification based on ROD percent exceedance ranges.  Hydrologic class exceedance percentile limits: Dry (0) = 100-90%; ModDry (1) = 90-70%; Average (2) = 70-30%; ModWet (3) = 30-10%; Wet (4) = 10-0%<br><br>SLOTS SET: KNN_MTOM.SpringHClass<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetMonthAsString"( @"t" ) IN { "March" , "April" , "May" , "June" , "July" , "August" } AND "GetRunCycleIndex"(  ) == 2.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Sets the spring hydrologic classification based on the forecasted April-July volume.";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "KNN_MTOM.SpringHClass" []) THEN
            $ "KNN_MTOM.SpringHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    DESCRIPTION          "Yampa";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "FlamingGorgeData.YampaAprJulPercentExceedance" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "FlamingGorgeData.YampaHClass" []) THEN
            $ "FlamingGorgeData.YampaHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END
    UUID "{f3f1fef7-d6f9-43e9-82f4-fd7dec0b0ddd}";;

    RULE                 "Base Flow Operations";
    DESCRIPTION          "Execution Constraint: Not March, April <br>  <br>Description: Sets the base flows for all months except March and April.  Base flow releases are set to stay below maximum pool elevation (PE), minimum flows or stay within the base flow range based on the hydrologic classification.  <br><br>Slots Set: FlamingGorge.Outflow ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( NOT "MonthIs"( { "March" , "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000 );
    NOTES                "CF, 20210220: Change FGConstrainedOutflow() to UBConstrainedOutflow()<br><br>CF, 20190128: MaxPE and MinFlow applied at the rule level to match CRSS.  <br><br>CF, 20181212: Added a constraint on outflow via FGConstrainedOutflow() to allow running VIC hydrology.<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      $ "FlamingGorge.Outflow" COMMENTED_BY "Sets the base flows for all months except March and April.  Base flow releases are set to stay<br>below maximum pool elevation (6039 ft), minimum flows or stay within the base flow range <br>based on the hydrologic classification." [] := "UBConstrainedOutflow"( % "FlamingGorge", "Max"( "Max"( "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) COMMENTED_BY "This will only be positive if PE @t-1 is > than MaxPE and will only control if release needed to get <br>back to MaxPE is greater than MinFlow and BaseFlow.  <br>", $ "FlamingGorgeData.MinFlow" [] ), "GetFGBaseFlowMagnitude"(  ) ) );

    END
    UUID "{cb796919-89ab-491b-a325-89b2425caddb}";;

    RULE                 "Base Flow Hydrologic Classification";
    DESCRIPTION          "DESCRIPTION: Sets the base flow classification based on ROD percent exceedance ranges.  Under ROD compliance, base flows can change one classification higher or lower depending upon the previous month's observed unregulated inflow. Hydrologic class exceedance percentile limits: Dry (0) = 100-90%; ModDry (1) = 90-70%; Average (2) = 70-30%; ModWet (3) = 30-10%; Wet (4) = 10-0%<br><br>SLOTS SET: KNN_MTOM.BaseFlowHClass<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "KNN_MTOM.AprJulPercentExceedanceBaseFlow" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "KNN_MTOM.BaseFlowHClass" []) THEN
            $ "KNN_MTOM.BaseFlowHClass" [] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  index
 ELSE
  IF ( ( index > $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] + 1.00000000 ) COMMENTED_BY "If index is at least 2 greater than previous timestep's, then increase" )
  THEN
   $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] + 1.00000000
  ELSE
   IF ( ( index < $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] - 1.00000000 ) COMMENTED_BY "If index is at least 2 less than previous timestep's, then decrease" )
   THEN
    $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] - 1.00000000
   ELSE
    index
   ENDIF
  ENDIF
 ENDIF;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END
    UUID "{7ba18385-6e1b-4617-bfe9-e24266438389}";;

    RULE                 "Calc Percent Exceedance";
    DESCRIPTION          "DESCRIPTION: Calculate the percent exceedance for the April-July Base and Spring flow volumes, and the Yampa April-July flow volume<br><br>SLOTS SET: KNN_MTOM.AprJulPercentExceedanceSpringFlow; KNN_MTOM.AprJulPercentExceedanceBaseFlow; FlamingGorgeData.YampaAprJulPercentExceedance<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170725: Modified some date calculations to remove use of CONCAT in favor of more recent RW capabilities (e.g., &quot;Previous Year&quot;)<br>MC, 20160913: Calculate exceedance percentages for April to July Spring and Base flow volumes; is the UpdateHistoricRecord flag still necessary after the changes to the HDB DMI and automating the HydrologicClassificationEndYear dates?<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
 THEN
  @"24:00:00 December Max DayOfMonth, Previous Year" COMMENTED_BY "Use the end of the previous year"
 ELSE
  "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ) ) ) COMMENTED_BY "Use the end year specified on the KNN_MTOM object"
 ENDIF ), $ "KNN_MTOM.AprJulVolSpringFlow" [] );

      $ "KNN_MTOM.AprJulPercentExceedanceBaseFlow" [] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
 THEN
  @"24:00:00 December Max DayOfMonth, Previous Year" COMMENTED_BY "Use the end of the previous year"
 ELSE
  "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ) ) ) COMMENTED_BY "Use the end year specified on the KNN_MTOM object"
 ENDIF ), $ "KNN_MTOM.AprJulVolBaseFlow" [] );

      $ "FlamingGorgeData.YampaAprJulPercentExceedance" [] := 1.00000000 - "PercentRank"( IF ( "GetYear"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) < "GetYear"( "RunStartDate"(  ) ) - 1.00000000 AND $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
 THEN
  IF ( "GetYear"( @"t" ) == "GetYear"( "RunStartDate"(  ) ) )
  THEN
   "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) ) COMMENTED_BY "Use Hydrologic Classification Start and End years"
  ELSE
   WITH LIST futureData = "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "RunStartDate"(  ) ) ), @"24:00:00 December Max DayOfMonth, Previous Year" ) COMMENTED_BY "From end of Start Year to end of year prior to current year" DO
    FOR ( NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH futureData ) - 1.00000000, 1.00000000 ) ) WITH LIST result = "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) ) DO
     ( APPEND GET @INDEX i FROM futureData ONTO result ) COMMENTED_BY "Add futureData values to YampaHydrologicClassification data list values"
    ENDFOR
   ENDWITH
  ENDIF
 ELSE
  "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
  THEN
   @"24:00:00 December Max DayOfMonth, Previous Year" COMMENTED_BY "Use end of previous year"
  ELSE
   "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) COMMENTED_BY "Use year specified as HydrologicClassificationEndYear"
  ENDIF )
 ENDIF, $ "FlamingGorgeData.YampaAprJulVol" [] );

    END
    UUID "{2efe4d7c-3ce5-4382-b362-be90e40af1a3}";;

    RULE                 "Calc April July Volume Monthly";
    DESCRIPTION          "DESCRIPTION: This rule calculates the April-July unregulated inflow volumes for Flaming Gorge for Base Flow and Spring Flow purposes, and the April-July volume for the Yampa at the Deerlodge gage.<br><br>SLOTS SET: KNN_MTOM.AprJulSpringFlow; KNN_MTOM.AprJulVolBaseFlow; FlamingGorgeData.YampaAprJulVol<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "For spring flow operations we are interested in the april - july volume for the upcoming season beginning in January through April. <br>The May official forecast is used for spring operations through July. <br>This number is needed in march to determine releases to meet the ULDE. ";
      $ "KNN_MTOM.AprJulVolSpringFlow" [] := "SpringFlowA-JVolumeUpdate"(  );

    DESCRIPTION          "For base flow operations we are interested in the available observed volume in the previous april - july season. <br>Since base flow may actually start in june calculate this number then. <br>The August - December base flows use the observed A-J volume.  Jan-Feb use forecast A-J and ULDE and base flow range.<br>";
      $ "KNN_MTOM.AprJulVolBaseFlow" [] := "BaseFlowA-JVolumeUpdate"(  );

      $ "FlamingGorgeData.YampaAprJulVol" [] := IF ( "MonthIs"( { "April" } ) )
 THEN
  "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"t" COMMENTED_BY "CF: shouldn't this be April 1 <br>", @"t + 3" )
 ELSE
  IF ( IsNaN $ "FlamingGorgeData.YampaAprJulVol" [@"t - 1"] )
  THEN
   "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) COMMENTED_BY "CF: Replace IF @t = startrun, 0 ac-ft   <br>"
  ELSE
   $ "FlamingGorgeData.YampaAprJulVol" [@"t - 1"]
  ENDIF
 ENDIF;

    END
    UUID "{0cd3036c-c59a-4808-a8fe-b6dc0e0c72f2}";;

    RULE                 "Update Historic Record";
    DESCRIPTION          "DESCRIPTION: If necessary (i.e., the April-July Volume is NaN), the most recent April to July volume (previous year if earlier than August, current year if later) is calculated. <br><br>SLOTS SET: FlamingGorgeData.YampaAprJulVolAnnual; FlamingGorgeData.AprJulVolAnnual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "MonthIs"( { "August" } ) OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 2.00000000 );
    NOTES                "AUTHOR, DATE: Unkinown<br><br>MC, 20160913: Was this made unnecessary by automating the HydrologicClassificationEndYear slots for FG and Yampa?<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "If earlier than August, use the previous year's data";
      IF_STATEMENT ("GetMonth"( @"t" ) < 8.00000000) THEN
            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] := "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Previous Year", @"24:00:00 July Max DayOfMonth, Previous Year" );

      END_IF_STATEMENT;

            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] := "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Previous Year", @"24:00:00 July Max DayOfMonth, Previous Year" );

      END_IF_STATEMENT;

      ELSE
          DESCRIPTION          "Othewise, use the current year";
      IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] := "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] := "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{7b8ad7a9-1a01-458b-9c98-344bda546984}";;

    RULE                 "Calculate April To July Volume Annual Slot";
    DESCRIPTION          "DESCRIPTION: Calculates the Flaming Gorge Unregulated Inflow and Yampa River at Deerlodge April to July volumes for each year between the classification Start Year and End Year<br><br>SLOTS SET: FlamingGorgeData.AprJulVolAnnual; FlamingGorgeData.YampaAprJulVolAnnual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == "RunStartDate"(  ) AND "GetRunCycleIndex"(  ) == 2.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20160908: Changed variable reference in calculation of FlamingGorgeData.YampaAprJulVolAnnual from KNN_MTOM.HistoricYampaAtDeerlodge to YampaRiverInflow.Yampa_at_Deerlodge; <br><br>S.Baker June 2018 EDITS: update where the historic data is located for MTOM Testbed Hindcast vs Operational MTOM Runs<br><br>S.Baker 07/08/2019: changed the order of IF statemetns for historical testbed data. This allows the rules to work for new development RunType. <br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Flaming Gorge Unregulated Apr-Jul Inflow volume";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ), "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ), "1 years" )) DO
            $ "FlamingGorgeData.AprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := "SumFlowsToVolume"( IF ( $ "MTOMRunType.RunType" [] == 1.00000000 )
 THEN
  $ "HistoricData.FlamingGorgeUnregulatedInflow"
 ELSE
  $ "FlamingGorgeInflow.Unregulated"
 ENDIF COMMENTED_BY "For operational runs, use unregulated forecast slot; otherwise, use historical data slot <br>", "GetDate"( "April, " CONCAT "GetYearAsString"( time ) ), "GetDate"( "July, " CONCAT "GetYearAsString"( time ) ) );

      ENDFOREACH;

    DESCRIPTION          "Yampa Apr-Jul Inflow Vol";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ), "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ), "1 years" )) DO
            $ "FlamingGorgeData.YampaAprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := "SumFlowsToVolume"( IF ( $ "MTOMRunType.RunType" [] == 1.00000000 )
 THEN
  $ "HistoricData.Yampa_at_Deerlodge"
 ELSE
  $ "YampaRiverInflow.Yampa_at_Deerlodge"
 ENDIF COMMENTED_BY "For operational runs, use unregulated forecast slot; otherwise, use historical data slot  <br>", "GetDate"( "April, " CONCAT "GetYearAsString"( time ) ), "GetDate"( "July, " CONCAT "GetYearAsString"( time ) ) );

      ENDFOREACH;

    END
    UUID "{916568d9-180b-4440-8650-ca2940fcb8f8}";;

  END
  UUID "{bcb5d346-8b73-41a4-97b1-8d33805678d8}";;

  POLICY_GROUP   "KNN Yampa Daily Flow";
  DESCRIPTION    "Description: Flaming Gorge operations, under the 2006 Record of Decision for the Operation of Flaming Gorge Dam Final Environmental Impact Statement (EIS), rely on both reservoir releases and unregulated tributary flow from the Yampa to meet the flow targets. Certain EIS targets are stated as a desired number of days requiring a disaggregation of monthly flows to daily. The KNN rules create a daily hydrograph for the Yampa River at Deerlodge. CRSS employs a K-nearest neighbor (KNN) daily disaggregation technique (Nowak et al., 2010) to obtain daily natural flow values by selecting neighbors that have similar monthly hydrograph shapes (Set Index Year-Ratios rule). This incorporates our knowledge of the monthly natural flow volumes provided by CRSS. The new neighbor selection preserves the daily statistics, such as mean, variance and daily maximums and minimums, while also capturing flow threshold statistics. After disaggregating to daily, natural flows (Set Yampa Daily Natural Flow from KNN-primary disagg rule), monthly demands are applied to the disaggregated time series resulting in a depleted, daily time series (Set Yampa Daily Depleted Flow at Deerlodge rule). Since the monthly demands must be able to be met in each month the demands may need to be redistributed in each month (Re-distribute Daily Demands within Month-Iterative rule) or a second-stage flow disaggregation could be necessary (3 rules ending in ?Second Stage Disagg?). The second-stage disaggregation ensures that the monthly volume of water can fulfill the monthly demand. Flow continuity between months was addressed because it is an issue in the second-stage disaggregation. The disaggregation technique provides a framework for obtaining daily natural flows from monthly natural flows and a historical, daily gage record (Butler, 2011). ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Peak Yampa Flow";
    DESCRIPTION          "DESCRIPTION: This rule finds the maximum daily flow of Deerlodge Depleted for the current year's KNN StartMonth to EndMonth period (currently April - July)<br><br>SLOTS SET: KNN_MTOM.YampaPeakDailyFlow[Current year]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode<br>";
    BEGIN

      $ "KNN_MTOM.YampaPeakDailyFlow" [@"24:00:00 December Max DayOfMonth, Current Year"] := "MaxItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", "GetDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ) CONCAT " 1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ), "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT "," ) CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ) ) );

    END
    UUID "{5a19ce60-15da-4a76-9226-d3573cf8a329}";;

    RULE                 "Set Yampa Daily Depleted Flow at Deerlodge For Second Stage Disagg";
    DESCRIPTION          "DESCRIPTION: Sets the daily depleted flow value at Deerlodge equal to the daily natural flow after the second stage disaggregation<br><br>SLOTS SET: KNN_MTOM.YampaDailyDeerlodgeDepleted[Current year's spring period]<br><br>";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "HasRuleFiredSuccessfully"( "Set Yampa Daily Natural - Second Stage Disagg" ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] == 1.00000000 );
    NOTES                "CF,20181010: Disabled. This is only needed for CRSS since MTOM isn't in natural flow space. <br><br>AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode<br>";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )];

      ENDFOREACH;

    END
    UUID "{a77dc1ca-6bd0-45b7-8837-b0e1ccfbd36c}";;

    RULE                 "Set Yampa Daily Natural - Second Stage Disagg";
    DESCRIPTION          "DESCRIPTION: This rule calculates a daily flow rate for each day in the current year's period based on the volume proportion for the day in the historical index year's monthly volume<br><br>SLOTS SET: KNN_MTOM.YampaDailyNatural[Current year's dates]; KNN_MTOM.SecondStageDisaggFlag[Current year]<br>";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "MinItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) ) < 0.00000000 "cfs" AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "CF,20181010: Disabled. This is only needed for CRSS since MTOM isn't in natural flow space. <br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode<br><br><br>AUTHOR, DATE: Unknown<br><br><br><br>";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := ( ( GET @INDEX i FROM "GetSecondStageProportionVector"(  ) ) * "GetCurrentMonthlyNaturalInflow"( GET @INDEX i FROM "GetCurrentYearDailyList"(  ) ) ) COMMENTED_BY "Multiply daily proportion by monthly volume" / 24.00000000 "hour";

      ENDFOREACH;

    DESCRIPTION          "Set flag for current year";
      $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] := 1.00000000;

    END
    UUID "{86446b6a-4f7a-46df-b6b4-7d728d9b7139}";;

    RULE                 "Set Yampa Daily Depleted Flow at Deerlodge";
    DESCRIPTION          "DESCRIPTION: Sets the daily depleted flow value at Deerlodge equal to the daily natural flow<br><br>SLOTS SET: KNN_MTOM.YampaDailyDeerlodgeDepleted[Current year's spring period]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode<br>";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )];

      ENDFOREACH;

    END
    UUID "{a71b74d2-2e2c-48d0-a4db-d570bd911990}";;

    RULE                 "Set Yampa Daily Natural Flow from KNN - primary disagg";
    DESCRIPTION          "DESCRIPTION: This function calcluates a daily flow vector that represents a disaggregation of the current spring volume based on the daily volume proportions of the historical index year and sets the second stage disaggregation slot flag to a value of 0.<br><br>SLOTS SET: KNN_MTOM.YampaDailyNatural[Current year's spring period]; KNN_MTOM.SecondStageDisaggFlag[Dec 31, Current Year]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode<br>";
    BEGIN

    DESCRIPTION          "Loop over the historical proportions vector and multiply the current year's spring volume by each daily proportion";
      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetProportionVector"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := "VolumeToFlow"( ( GET @INDEX i FROM "GetProportionVector"(  ) ) * "GetSpringVolume"(  ), GET @INDEX i FROM "GetCurrentYearDailyList"(  ) );

      ENDFOREACH;

    DESCRIPTION          "Initialize the flag to 0";
      $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000;

    END
    UUID "{d98dbbfe-0032-4078-ac78-5551cfa26ebd}";;

    RULE                 "Set Index Year- Ratios";
    DESCRIPTION          "DESCRIPTION: This rule sets the value of the index year chosen from the K nearest neighbors of the current year. The K nearest neighbors are calculated based on the seasonal volume proportions of each month in the April-July period<br><br>SLOTS SET: KNN_MTOM.IndexYear[Current Year]<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode<br>";
    BEGIN

      $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] := WITH NUMERIC seasonalVol = "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) DO
  "ChooseIndexYearRatio"( "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 April Max DayOfMonth, Current Year"], @"24:00:00 April Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 May Max DayOfMonth, Current Year"], @"24:00:00 May Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 June Max DayOfMonth, Current Year"], @"24:00:00 June Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 July Max DayOfMonth, Current Year"], @"24:00:00 July Max DayOfMonth, Current Year" ) / seasonalVol ) COMMENTED_BY "Select the index year"
 ENDWITH;

    END
    UUID "{ed25973f-ccd8-4fff-9a8f-00e8a772df67}";;

    RULE                 "Set Random Number";
    DESCRIPTION          "DESCRIPTION: This rule generates a random number between 0 and 1 used in selecting a nearest neighbor historical year to use as an index year<br><br>SLOTS SET: KNN_MTOM.randomNum[Current Year]";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000 ) COMMENTED_BY "Changing the month this rule executes will change the random number generated <br>by the funciton call as the random number index is different for every month/year.<br>" );
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode<br>";
    BEGIN

      $ "KNN_MTOM.randomNum" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Random"( "GetRandSeed"(  ), $ "KNN_MTOM.randomIndex" [], 0.00000000 );

    END
    UUID "{c8a7fb58-f313-4e85-93ac-48558d6afad4}";;

  END
  UUID "{de4834ef-d1df-4dbb-874d-362d8ee2cfd7}";;

  POLICY_GROUP   "Aspinall Ops";
  DESCRIPTION    "The Aspinall Unit on the Gunnison River was authorized as part of the Colorado Storage Project Act (1956). The unit is made up of Blue Mesa Dam, Morrow Point Dam, and Crystal Dam. Primary water storage occurs in the uppermost and largest reservoir, Blue Mesa. The Aspinall Unit is operated for water storage, hydropower production, releases for water rights and agreements, flood control and for downstream endangered fish species. Reclamation works with other government agencies, public and special interest groups in setting the operations of the Aspinall Unit via the Aspinall Unit Working Group. <br><br>The Aspinall Unit is upstream of the Black Canyon of the Gunnison National Park. The park holds a federal reserved water right (2008 Decree). CRSS calculates the daily flow targets which satisfy the water right, based on the Blue Mesa Unregulated Inflow for April-July, and then aggregates these to monthly releases. <br><br>Endangered fish are found in the lower Gunnison River approximately 50 miles downstream of the Aspinall Unit reservoirs. The Record of Decision for the Aspinall Unit Operations Final Environmental Impact Statement (2012) specifies spring peak and base flow targets for the Gunnison River Near Grand Junction Gage (USGS 09152500, a.k.a. the Whitewater Gage) to benefit the endangered fish species. Target flows depend on the hydrologic year type which is determine to be between Dry and Wet based on the Blue Mesa Unregulated Inflow for April-July. CRSS calculates daily flow targets at the Whitewater Gage and then aggregates these to monthly release targets.   <br><br>CRSS determines the outflow as the greater of the flow necessary to meet the Whitewater Target Flow, the Black Canyon Target Flow, or the flow necessary to meet the target pool elevation for Blue Mesa (rule curve). This is subject to the constraints that those flows are not greater than the maximum release to prevent an overflow at Crystal, the maximum release to avoid the minimum pool elevation, the maximum possible outflow for Blue Mesa Reservoir, and the maximum outflow to the absolute bottom (top of dead pool), but no less than the amount to prevent flood control. <br><br>Blue Mesa?s releases is passed down stream to the critical reaches through Morrow Point and Crystal Reservoirs. Both reservoirs maintain a constant storage by passing the inflow minus enough water to offset their evaporation.  <br><br><br>";
  ACTIVE         TRUE;
  NOTES          "The April 2012 Record of Decision for the Aspinall Unit Operations Final Environmental Impact Statement (2012 Aspinall ROD) and the decree quantifying the Federal Reserved Water Right for the Black Canyon of the Gunnison specify the spring peak outflow hydrograph and base flow for the rest of the year based on the hydrologic conditions upstream of Blue Mesa Reservoir, specifically the forecasted inflow to Blue Mesa Reservoir for April through July in the year of interest.  The 2012 Aspinall ROD provides specifications to avoid jeopardizing the continued existence of fish listed under the Endangered Species Act and to ensure the dam's operations do not result in the destruction or adverse modification of critical habitat in the Gunnison and Colorado rivers. <br><br>Data used to calculate the peak flow and duration targets are on the BlueMesaData object in the slots GunnisonDurationTargets, CanyonFlowCalcData, PeakFlowCalcData";
  BEGIN

    RULE                 "Crystal Outflow";
    DESCRIPTION          "Execution Constraint: Only fires if the rule has not successfully fired yet. <br>  <br>Description: Crystal and Morrow Point Reservoirs just need to pass inflow which Blue Mesa is sending down to meet flow requirements while accounting for evaporation in order to maintain a constant storage. Blue Mesa releases do not attempt to get Crystal to its storage target if it not already there. Instead Crystal holds back/releases more water in the first timestep to meet this goal. This logic should be revisited later. UBConstrainedOutflow() prevents this from exceeding min/max constraints.  <br>  <br>Slots Set: Crystal.Outflow ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "ThisRule" ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "Is24MonthStudy"(  );
    NOTES                "CF,20190403: Moved in from Apr 2019 Offc CRSS. <br><br>CF,20190409: Get Crystal to target Elevation by holding back water.<br><br>CF,20190405: Created to replace old rule Set Morrow Point and Crystal Storage which did not allow for Morrow Point and Crystal to respond to Blue Mesa operations. <br><br>APivarnik 20200706: Added execution contraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort";
    BEGIN

      $ "Crystal.Outflow" [@"t"] := "UBConstrainedOutflow"( % "Crystal", "VolumeToFlow"( "ElevationToStorage"( % "Crystal", $ "Crystal.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t" ) + $ "Crystal.Inflow" [@"t"] - "VolumeToFlow"( "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ), @"t" ) );

    END
    UUID "{1ee9a8f7-5d21-45a4-b979-5200956076d9}";;

    RULE                 "Morrow Point Outflow";
    DESCRIPTION          "Execution Constraint: Only fires if the rule has not successfully fired yet. <br>  <br>Description: Crystal and Morrow Point Reservoirs just need to pass inflow which Blue Mesa is sending down to meet flow requirements while accounting for evaporation in order to maintain a constant storage. Blue Mesa also releases to get Morrow Point to its storage target if it not already there. UBConstrainedOutflow() prevents this from exceeding min/max constraints.  <br>  <br>Slots Set: MorrowPoint.Outflow ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "ThisRule" ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "Is24MonthStudy"(  );
    NOTES                "CF,20190403: Moved in from Apr 2019 Offc CRSS. <br><br>CF,20190405: Created to replace old rule Set Morrow Point and Crystal Storage which did not allow for Morrow Point and Crystal to respond to Blue Mesa operations. <br><br>APivarnik 20200706: Added execution contraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort";
    BEGIN

      $ "MorrowPoint.Outflow" [@"t"] := "UBConstrainedOutflow"( % "MorrowPoint", $ "MorrowPoint.Inflow" [@"t"] - "VolumeToFlow"( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) COMMENTED_BY "CF: MP should reach target by end of timestep. <br>", @"t", @"t" ) + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "CF: Vol to get MP to target. <br>", @"t" ) );

    END
    UUID "{f0b98f34-c4e9-4d6b-bb2c-96ae74d26131}";;

    RULE                 "Blue Mesa Operations";
    DESCRIPTION          "DESCRIPTION: This rule uses the function BlueMesaOutflowCalc to determine monthly releases from Blue Mesa Reservoir<br><br>SLOTS SET: BlueMesa.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "BlueMesa.Outflow" [] AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      $ "BlueMesa.Outflow" [] := "BlueMesaOutflowCalc"(  );

    END
    UUID "{c9154d16-9c94-4c9c-8e8d-4ff3bc17ddf6}";;

    RULE                 "Calculate May Release Volume";
    DESCRIPTION          "DESCRIPTION: Sets the Total May release volume by summing the daily flow requirements necessary to meet the 2012 ROD Flows for the Whitewater Gage and the Federal Reserve Water Right flows through the Black Canyon.  This rule also calculates the daily outflow from Blue Mesa necessary to meet those two flow requirements.  That data is written to the Blue Mesa Data object and is for informative purposes only.  TP 9/25/2015<br><br>SLOTS SET: BlueMesaData.MayReleaseVolume; BlueMesaData.TargetDailyOutflowFromBlueMesa<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170705: In calculation of MayReleaseVolume, conditional statement was IF (date < @&quot;Start Timestep&quot; AND NOT GetMonth(date) == 5.00), and was changed to just IF (date < @&quot;Start Timestep&quot;) because all dates being considered are in May, so second part of Boolean was never true and past outflows were not being used for May dates prior to Start Timestep<br><br>MC, 20170712: Added DateMin(..., @&quot;Finish Timestep&quot;) to calculation of BMD.TargetDailyOutflowFromBlueMesa; without it, the final year of the run could not calculate completely, and the rule was finishing ineffectively meaning the MayReleaseVolume did not get populated for the final year of the run<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] := FOR ( DATETIME date IN "GetDates"( @"24:00:00 May 1, Current Year", @"24:00:00 May 31, Current Year", "1 days" ) ) STAT_AVE
  IF ( date < @"Start Timestep" AND ( NOT "GetMonth"( date ) == 5.00000000 ) COMMENTED_BY "MC, 20170725: This doesn't make sense because all dates being considered <br>are in May. Should current year May use the previously determined outflow, <br>or should all dates, whether prior to Start Timestep or not calculate outflow?  <br>" )
  THEN
   $ "BlueMesa.Outflow" ["MaxDayOfMonth"( date )]
  ELSE
   "SolveBlueMesaReleaseForDownstreamTargets"( $ "BlueMesaData.TargetDailyWhitewaterFlows" [date], "MaxDayOfMonth"( date ), $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date] )
  ENDIF
 ENDFOR COMMENTED_BY "Calculate average daily flow in May" * 31.00000000 "day";

    DESCRIPTION          "Set daily flows for remainder of current year";
      FOREACH (DATETIME date IN "GetDates"( "DateMax"( @"24:00:00 January 1, Current Year", "MinDayOfMonth"( @"Start Timestep" ) ), "DateMin"( @"24:00:00 December 31, Current Year", @"Finish Timestep" ), "1 days" )) DO
            $ "BlueMesaData.TargetDailyOutflowFromBlueMesa" [date] := "Max"( "SolveBlueMesaReleaseForDownstreamTargets"( $ "BlueMesaData.TargetDailyWhitewaterFlows" [date], "MaxDayOfMonth"( date ), $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date] ), 0.00000000 "cfs" );

      ENDFOREACH;

    END
    UUID "{ec8b29c0-33e2-4ee1-a85b-804a593b83d0}";;

    RULE                 "Annual Daily Black Canyon Flow Determination";
    DESCRIPTION          "DESCRIPTION: This rule calculates the preliminary daily flow targets for the flow through the Black Cayone that satisfies the Federal Reserve Water Right for the entire year of a model run.  The ramp up and down to the peak date are included.   This rule will set each day to either the ramp up or down value, the peak flow (as determined on the algorithm to satisfy the Water Right) or the base flow value for any day outside of this range for the Flow through the Black Canyon.  Though the model is monthly, these values are written to a daily slot on BlueMesaData that will be aggregated and converted to a monthly release from Blue Mesa Res in a subsequent rule (Blue Mesa Operations). - sc 12/27/10<br><br>SLOTS SET: BlueMesaData.TargetDailyBlackCanyonFlows<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "Black Canyon Target Peak Flow";
      WITH_STATEMENT (NUMERIC peakCanyonFlow = $ "BlueMesaData.CanyonPeakFlowTarget" [@"24:00:00 December 31, Current Year"]) DO
          DESCRIPTION          "May Base Flow Value";
      WITH_STATEMENT (NUMERIC mayCanyonBaseFlow = $ "BlueMesaData.MinimumBlackCanyonFlow" [@"24:00:00 May 31, Current Year"]) DO
          DESCRIPTION          "Number of days to ramp up<br>Solve for x = no. days in &lcub;BaseFlow*(1+UpRate)^x >= PeakFlow&rcub;";
      WITH_STATEMENT (NUMERIC daysOfRampUp = "Ceiling"( "Ln"( peakCanyonFlow / mayCanyonBaseFlow, 0.00000000 ) / "Ln"( 1.00000000 + $ "BlueMesaData.CanyonRampUpRateToPeak" [], 0.00000000 ), 1.00000000 ) * 1.00000000 "day") DO
          DESCRIPTION          "Number of days to ramp down";
      WITH_STATEMENT (NUMERIC daysOfRampDown = "Ceiling"( "Ln"( mayCanyonBaseFlow / peakCanyonFlow, 0.00000000 ) / "Ln"( 1.00000000 - $ "BlueMesaData.CanyonRampDownRateFromPeak" [], 0.00000000 ), 1.00000000 ) * 1.00000000 "day") DO
          DESCRIPTION          "Calculate peak date, and dates on which to begin and end ramping";
      WITH_STATEMENT (DATETIME peakDate = "CompletePartialDate"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" )) DO
            WITH_STATEMENT (DATETIME startRampUpDate = peakDate - daysOfRampUp) DO
            WITH_STATEMENT (DATETIME endRampDownDate = peakDate + daysOfRampDown) DO
          DESCRIPTION          "Set daily flow rates for current calendar year";
      FOREACH (DATETIME date IN "GetDates"( "DateMax"( @"24:00:00 January 1, Current Year", "GetStartDayOfMonth"(  ) ), @"24:00:00 December 31, Current Year", "1 days" )) DO
            WITH_STATEMENT (NUMERIC baseFlow = $ "BlueMesaData.MinimumBlackCanyonFlow" [date]) DO
            $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date] := IF ( date >= @"April 1" AND date <= @"July 25" )
 THEN
  IF ( date >= startRampUpDate AND date < peakDate )
  THEN
   WITH NUMERIC nDaysUp = ( date - startRampUpDate + 1.00000000 "day" ) / 1.00000000 "day" DO
    baseFlow * ( 1.00000000 + $ "BlueMesaData.CanyonRampUpRateToPeak" [] ) ^ nDaysUp
   ENDWITH COMMENTED_BY "Flows during ramp up period"
  ELSE
   IF ( date == peakDate )
   THEN
    peakCanyonFlow
   ELSE
    IF ( date > peakDate AND date <= endRampDownDate - 1.00000000 "day" )
    THEN
     WITH NUMERIC nDaysDown = ( date - peakDate ) / 1.00000000 "day" DO
      peakCanyonFlow * ( 1.00000000 - $ "BlueMesaData.CanyonRampDownRateFromPeak" [] ) ^ nDaysDown
     ENDWITH COMMENTED_BY "Flows during ramp down period"
    ELSE
     baseFlow
    ENDIF
   ENDIF
  ENDIF
 ELSE
  baseFlow
 ENDIF;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{3847fb08-6f07-4dc8-ae0b-95289d2ea75b}";;

    RULE                 "Annual Daily Whitewater Flow Determination";
    DESCRIPTION          "DESCRIPTION: This rule calculates the preliminary daily flow targets for the Whitewater Gage for the entire year of a model run. They are preliminary in that the ramp up and ramp down from the peak flow target are not included yet. This rule will set each day to either the shoulder flow, the peak flow (as determined on the Spring Peak And Duration Canyon Targets slot) or the base flow value for any day outside of this range for the Whitewater Gage. Though the model is monthly, these values are written to a daily slot on BlueMesaData.TargetDailyWhitewaterFlows that will be aggregated and converted to a monthly release from Blue Mesa Res in a subsequent rule (Blue Mesa Operations). <br><br>SLOTS SET: BlueMesaData.TargetDailyWhitewaterFlows<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>CF, 20190512: Annual Daily Whitewater Flow Determination rule add FEIS 2.3.6.3 drought requirements when solving for baseflow. Looks at Dry and Mod Dry and sets outflow to 900 cfs <br><br>MC, 20170705: Added BlueMesaData.WhitewaterOpsAssurance value to the peak and shoulder flows per Rick C.'s recommendation to improve probability of achieving ROD Whitewater targets. The daily flows are then averaged into the local variable MonthlyWhitewaterTarget in the function BlueMesaOutflowCalc<br><br>CF, 5/5/2017:  This rule was restructured so that new slots  Peak & ShoulderFlowDuration. The shoulder flow function was removed since shoulder/half-bank flow is now fixed by the ROD to 8,070. This value is stored in slot BlueMesaData.ShoulderFlowTarget. - CF 5/5/2017<br><br>TP/MC, 9/25/2015: This rule calculates the may peak flow target for the Whitewater Gage, the shoulder flow is set to 8,070 cfs as part of the 2012 ROD, the May Peak Flow Level which is a value between 0 adn 5 that is based on the 2012 ROD for the Aspinall Unit which is calculated with the Blue Mesa Unregulated Inflow for April through July.  The rule also determines the Black Canyon Peak flow that will meet the Federal Reserve Water Right and the April through July volume for Blue Mesa Reservoir unregulated inflow. This rule only fires on the first day of the year or first day of the run.<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

    DESCRIPTION          "ROD peak flow Target";
      WITH_STATEMENT (NUMERIC peakFlow = $ "BlueMesaData.WhitewaterPeakFlowTarget" [@"24:00:00 December 31, Current Year"]) DO
          DESCRIPTION          "ROD Shoulder Flow Target";
      WITH_STATEMENT (NUMERIC shoulderFlow = $ "BlueMesaData.HalfBankFlow" []) DO
          DESCRIPTION          "ROD Peak Flow Hydrologic Year classification,";
      WITH_STATEMENT (NUMERIC level = $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"]) DO
          DESCRIPTION          "Number of Days at Peak Flow based on the ROD Target";
      WITH_STATEMENT (NUMERIC daysOfPeak = $ "BlueMesaData.PeakFlowDuration" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (NUMERIC daysOfShoulder = $ "BlueMesaData.ShoulderFlowDuration" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (DATETIME peakDate = "CompletePartialDate"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" )) DO
            WITH_STATEMENT (DATETIME startShoulderFlowDate = peakDate - daysOfShoulder / 2.00000000) DO
            WITH_STATEMENT (DATETIME endShoulderDate = startShoulderFlowDate + daysOfShoulder - 1.00000000 "day") DO
            WITH_STATEMENT (DATETIME startPeakFlowDate = peakDate - daysOfPeak / 2.00000000) DO
            WITH_STATEMENT (DATETIME endPeakFlowDate = startPeakFlowDate + daysOfPeak - 1.00000000 "day") DO
            FOREACH (DATETIME date IN "GetDates"( "DateMax"( @"24:00:00 January 1, Current Year", "GetStartDayOfMonth"(  ) ), @"24:00:00 December 31, Current Year", "1 days" )) DO
            WITH_STATEMENT (NUMERIC baseFlow = IF ( "GetMonth"( @"t" ) == 6.00000000 OR "GetMonth"( @"t" ) == 7.00000000 AND ( $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] IN { 0.00000000 , 1.00000000 } AND $ "BlueMesa.Storage" [@"t - 1"] < 600000.00000000 "acre-feet" ) )
 THEN
  900.00000000 "cfs"
 ELSE
  $ "BlueMesaData.BaseFlowTarget" [date, level]
 ENDIF) DO
            $ "BlueMesaData.TargetDailyWhitewaterFlows" [date] := IF ( date >= @"April 1" AND date <= @"July 25" )
 THEN
  IF ( date >= startShoulderFlowDate )
  THEN
   IF ( date >= startPeakFlowDate AND date <= endPeakFlowDate )
   THEN
    ( peakFlow + $ "BlueMesaData.WhitewaterOpsAssurance" [] ) COMMENTED_BY "This is the period of time to ramp up to the Peak flow, this is assuming that the ramp up will only <br>be for about one day, this can be edited if this logic needs to be more precise. TP 9/19/2015"
   ELSE
    IF ( date <= endShoulderDate )
    THEN
     $ "BlueMesaData.HalfBankFlow" [] + $ "BlueMesaData.WhitewaterOpsAssurance" []
    ELSE
     baseFlow
    ENDIF
   ENDIF
  ELSE
   baseFlow
  ENDIF
 ELSE
  baseFlow
 ENDIF;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{fecfb05f-0915-4705-a990-e3f109c4fec8}";;

    RULE                 "Calculate Gunnison Flow Targets";
    DESCRIPTION          "DESCRIPTION: This rule calculates: <br>- The peak flow target for the Whitewater Gage. <br>- The hydrologic year classification which is a value between 0 (Dry) and 5 (Wet) that is based on the 2012 ROD which is calculated with the Blue Mesa Unregulated Inflow for April-July. <br>- The Black Canyon peak flow that will meet the Federal Reserve Water Right <br>- The April through July volume for Blue Mesa Reservoir unregulated inflow.  <br>- The WW peak and shoulder flow durations acording to the ROD.  <br><br>SLOTS SET: BlueMesaData.WWPeakFlowTarget; BlueMesaData.GunnisonHClass; BlueMesaData.CanyonPeakFlowTarget; BlueMesaData.BlueMesaAprilThroughJulyVolume <br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br><br>TP/MC, 20150925: This rule calculates the may peak flow target for the Whitewater Gage, the shoulder flow is set to 8,070 cfs as part of the 2012 ROD, the May Peak Flow Level which is a value between 0 adn 5 that is based on the 2012 ROD for the Aspinall Unit which is calculated with the Blue Mesa Unregulated Inflow for April through July.  The rule also determines the Black Canyon Peak flow that will meet the Federal Reserve Water Right and the April through July volume for Blue Mesa Reservoir unregulated inflow. This rule only fires on the first day of the year or first day of the run.<br><br>CF, 5/5/2017: This rule and the accompanying functions were restructured so that AprilThoughJulyVolume and  Gunnison Hydroglogic year class (GunnisonHClass), previously called MayFlowLevel, are calculated only once and then passed as arguments to the functions rather than being recalculated by each function. The shoulder flow function was removed since shoulder/half-bank flow is now fixed by the ROD to 8,070. This value is stored in slot BlueMesaData.ShoulderFlowTarget. - The WW peak and shoulder flow durations are now calculated and set to seperate slots for reference by later rules. <br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode<br><br><br>";
    BEGIN

      WITH_STATEMENT (NUMERIC currentForecast = "SumFlowsToVolume"( $ "BlueMesaInflow.Unregulated", @"24:00:00 April 30, Current Year", @"24:00:00 July 31, Current Year" )) DO
            $ "BlueMesaData.BlueMesaAprilThroughJulyVolume" [@"24:00:00 December 31, Current Year"] := currentForecast;

            WITH_STATEMENT (NUMERIC HClass = "CalcGunnisonHClass"( currentForecast )) DO
            $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] := HClass;

            $ "BlueMesaData.WhitewaterPeakFlowTarget" [@"24:00:00 December 31, Current Year"] := "CalcGunnisonWWPeakFlowTarget"( HClass, currentForecast );

            $ "BlueMesaData.CanyonPeakFlowTarget" [@"24:00:00 December 31, Current Year"] := "CalcCanyonPeakFlowTarget"( currentForecast );

            $ "BlueMesaData.ShoulderFlowDuration" [@"24:00:00 December 31, Current Year"] := $ "BlueMesaData.GunnisonDurationTargets" [HClass, 1.00000000];

            $ "BlueMesaData.PeakFlowDuration" [@"24:00:00 December 31, Current Year"] := $ "BlueMesaData.GunnisonDurationTargets" [HClass, 2.00000000];

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{302768b5-b051-4b14-8eaf-ae66980ad7e7}";;

  END
  UUID "{58d25a58-3b97-4339-9183-7a33ff77e4cd}";;

  POLICY_GROUP   "Vallecito Ops";
  DESCRIPTION    "The operations of Vallecito Reservoir are based on analysis of the historic record in which a target pool elevation curve was created (VallecitoData.VallecitoGuide). A flow of 2,000 cfs is the maximum target outflow for Vallecito Reservoir to minimize downstream bank damage, but in times of flood control, outflow can be greater than the maximum release target. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "VallecitoFloodControlProtection";
    DESCRIPTION          "DESCRIPTION: Determines the Vallacito outflow when the pool elevation exceeds the target elevation for the given month. The Vallecito outflow is increased until either the maximum outflow is reached, or the Vallecito pool elevation is equal to the end of month target elevation for Vallecito. -ce 6/6/13<br><br>SLOTS SET: Vallecito.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND $ "Vallecito.Pool Elevation" [] > "GetEOMTargetElevation"( % "Vallecito", @"t" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE, 6/6/2013 (?)<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      WITH_STATEMENT (NUMERIC previousPoolElevation = $ "Vallecito.Pool Elevation" [@"t - 1"]) DO
            $ "Vallecito.Outflow" [@"t"] := "Min"( "GetReservoirMaxConstraint"( % "Vallecito", @"t", previousPoolElevation ), "VolumeToFlow"( "ElevationToStorageAtDate"( % "Vallecito", $ "Vallecito.Pool Elevation" [], @"t" ) - "ElevationToStorageAtDate"( % "Vallecito", "GetEOMTargetElevation"( % "Vallecito", @"t" ), @"t" ), @"t" ) + $ "Vallecito.Outflow" [@"t"] );

      END_WITH_STATEMENT;

    END
    UUID "{7d7b30d5-e8b7-4677-86ef-78d2e5bc32ee}";;

    RULE                 "Vallecito Guide Release";
    DESCRIPTION          "DESCRIPTION: This rule sets the Vallecito Reservoir releases for the entire run on the first timestep.  The ability to do this is predicated on the fact that Vallecito operations only need to know the inflow to the reservoir and nothing else about the state of the system.  If this changes, then it will have be done each timestep.<br><br>SLOTS SET: Vallecito.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE:  SC, 12/15/2010<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode";
    BEGIN

      FOREACH (LIST dateOutflowElevation IN "SimulateHeadwaterRes"( % "Vallecito" )) DO
            $ "Vallecito.Outflow" [GET @INDEX 0.00000000 FROM dateOutflowElevation] := GET @INDEX 1.00000000 FROM dateOutflowElevation;

      ENDFOREACH;

    END
    UUID "{f754bebd-258b-43e4-8736-0e46494ab34b}";;

  END
  UUID "{f6314f3c-2895-4538-96d6-eb510aec3bcf}";;

  POLICY_GROUP   "Taylor Park Ops";
  DESCRIPTION    "Taylor Park is operated to a simple storage rule curve or releases to meet downstream demands (between Taylor Park and Blue Mesa), whichever is greater. ";
  ACTIVE         TRUE;
  NOTES          "The operational guide curves for Taylor Park in MTOM are based on an analysis of the historic record which served as the foundation for developing target pool elevations for each month (TaylorParkData.TaylorParkGuide). The target pool elevation is used to set an outflow for a specific month where the outflow is bound by a minimum monthly flow and a maximum monthly flow depending on the pool elevation of the previous month. At Taylor Park, the maximum flow is constrained by the outlet works based on the data in the TaylorPark.Max Release table. Minimum flows are reduced if they would cause the reservoir to go below its minimum pool elevation.";
  BEGIN

    RULE                 "Taylor Park Guide Release";
    DESCRIPTION          "DESCRIPTION: This rule sets the Taylor Park Reservoir releases for the entire run on the first timestep.  The ability to do this is predicated on the fact that Taylor Park operations only need to know the inflow to the reservoir and nothing else about the state of the system.  If this changes, then it will have be done each timestep<br><br>SLOTS SET: TaylorPark.Outflow<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: SC, 12/31/2010<br><br>SB, 20190709: Taylor Park needed lower release for very dry scenarios. Added a max statement to release only the available water in Taylor Park. <br><br>MC, 20170720: Wrote modifed version of reduced MinFlow situation to adaptively reduce MinFlow values so that MinElevation is avoided; not active yet because haven't run it by USBR<br><br>MC, 20170621: (a) Changed reference  in local variable ToSpillway from 9,330 feet to TaylorParkData.SpillwayElevation; (b) Changed reference in first IF statement from TaylorParkData.TaylorPark_LowestFlow to TaylorParkData.MinFlow * TaylorParkData.MinFlowReductionFactor. (b) will allow more flexibility in flow reductions due to low pool elevations than hard-coding new min flow values.<br><br>MC, 20170508: Added conditional logic and LowestFlow slot to address problems Sarah B. was having with her model runs; changes developed by Sarah and confirmed with Erik K.<br><br>MC, 20170124: With midmonth ensembles, situation occurred in which the maximum release constraint in SimulateHeadwaterRes prevented use of spillway and led to storage greater than maximum in storage-volume table and aborted runs. I rewrote the rule so now TP only solves one timestep at a time but utilizes spill possibility. Three possibilities for relative size of outflows calculated:<br>1. ToSpillway < ToTarget < MaximumControlled: release to hit target<br>2. ToSpillway < MaximumControlled < ToTarget: release maximum and end of month elevation will be lower than spillway but higher than target<br>3. MaximumControlled < ToSpillway < ToTarget: release to spillway, which will require spill, but not excessive spill that would be required to reach target<br><br>Need Minimum Flow in case inflow is insufficient to reach Target<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode. ";
    BEGIN

      WITH_STATEMENT (DATETIME EndDate = "DateMin"( "GetWaterYearEndDate"( @"t" ), @"Finish Timestep" )) DO
            $ "TaylorPark.Outflow" [@"t"] := IF ( ( $ "TaylorPark.Pool Elevation" [@"t - 1"] < ( $ "TaylorParkData.TaylorParkGuide" [@"t - 1"] - 70.00000000 "ft" ) ) COMMENTED_BY "Previous pool elevation is more than 70ft below guide curve OR (more than 20ft below AND inflows less than lowest outflows)" OR ( $ "TaylorPark.Pool Elevation" [@"t - 1"] < ( $ "TaylorParkData.TaylorParkGuide" [@"t - 1"] - 20.00000000 "ft" ) AND "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) < "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) * $ "TaylorParkData.MinFlowReductionFactor" [] ) )
 THEN
  "VolumeToFlow"( "Min"( "FlowToVolume"( $ "TaylorParkData.MinFlow" [@"t"], @"t" ) * $ "TaylorParkData.MinFlowReductionFactor" [], $ "TaylorPark.Storage" [@"t - 1"] + "FlowToVolume"( $ "TaylorPark.Inflow" [@"t"], @"t" ) ), @"t" )
 ELSE
  WITH NUMERIC MaximumControlled = $ "TaylorPark.Maximum Controlled Release" [0.00000000, 0.00000000] DO
   WITH NUMERIC ToTarget = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.TaylorParkGuide" [@"t"] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the pool elevation target" DO
    WITH NUMERIC ToSpillway = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.SpillwayElevation" [] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the spillway" DO
     "Max"( "Max"( "Min"( ToTarget, MaximumControlled ), ToSpillway ), $ "TaylorParkData.MinFlow" [@"t"] )
    ENDWITH
   ENDWITH
  ENDWITH
 ENDIF;

      END_WITH_STATEMENT;

    INACTIVE      WITH_STATEMENT (DATETIME EndDate = "DateMin"( "GetWaterYearEndDate"( @"t" ), @"Finish Timestep" )) DO
          DESCRIPTION          "MC, 20170720: I added this prospective change because I thought the conditions for reducing the Min Flow <br>and the reduction factor (0.67) were too arbitrary. Haven't run this by USBR yet, though.   <br>";
      $ "TaylorPark.Outflow" [@"t"] := IF ( ( $ "TaylorPark.Storage" [@"t - 1"] + "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) - "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) < "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ) ) COMMENTED_BY "Min outflows lead to EOWY PE less than minimum <br>" )
 THEN
  WITH NUMERIC FlowReductionFactor = ( ( "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) + $ "TaylorPark.Storage" [@"t - 1"] - "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ) ) / "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) * 1.00000000 ) COMMENTED_BY "Scale MinFlow either to reach MinElevation (multiply by 1) or reduce coefficient for factor of safety <br>" DO
   "VolumeToFlow"( "FlowToVolume"( $ "TaylorParkData.MinFlow" [@"t"], @"t" ) * FlowReductionFactor, @"t" )
  ENDWITH
 ELSE
  WITH NUMERIC MaximumControlled = $ "TaylorPark.Maximum Controlled Release" [0.00000000, 0.00000000] DO
   WITH NUMERIC ToTarget = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.TaylorParkGuide" [@"t"] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the pool elevation target" DO
    WITH NUMERIC ToSpillway = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.SpillwayElevation" [] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the spillway" DO
     "Max"( "Max"( "Min"( ToTarget, MaximumControlled ), ToSpillway ), $ "TaylorParkData.MinFlow" [@"t"] )
    ENDWITH
   ENDWITH
  ENDWITH
 ENDIF;

      END_WITH_STATEMENT;

    END
    UUID "{86f6a5d5-3ec7-4cd4-901c-3041d0db3ee5}";;

  END
  UUID "{eefa021d-c2c5-4714-9e1d-babdcd14fcbf}";;

  POLICY_GROUP   "Fontenelle";
  DESCRIPTION    "Fontenelle operations target a July 1st reservoir elevation. Additional April 1st and August 1st target elevations model an operational ?rule of thumb.? Operations are also subject to a minimum baseflow, the safe channel capacity, and not going into flood control. <br><br>";
  ACTIVE         TRUE;
  NOTES          "Old Description:<br>The Fontenelle Reservoir operational policies implemented in MTOM were developed based on operator experience and analysis of historic operations. In general, releases are set to meet various target elevations throughout the year while staying within practical and authorized limits. The target elevations for various months are as follows: <br>         October through March outflows are controlled by the April 1 target elevation of 6,468 feet <br>         April and June outflows are controlled by the July 1 target elevation of 6,500 feet ; May outflow is controlled by an intermediate target of 6,480 ft.<br>         July outflow is controlled by the August 1 target elevation of 6,505.5 feet <br>         The maximum release is about 11,500 cfs (Safe Channel Capacity)<br>         Minimum releases are set to 400 cfs during the months Sep-Mar and to 600 cfs during the months Apr-Aug<br>  <br>Maximum and minimum releases take precedence over releases required to meet a specific month?s target elevation. A release that will cause the pool elevation to drop below 6,465 feet will be reduced such that the minimum elevation will not be violated except for minimum releases required to maintain flow in the reach below Fontenelle. Spills may occur as necessary to limit the pool elevation to 6,506 feet or to meet the target pool elevation in August. The spill algorithm releases the entire volume necessary to enforce the maximum pool elevation in a single month. ";
  BEGIN

    RULE                 "Min Flow";
    DESCRIPTION          "DESCRIPTION: This rule ensurs that the minimum instream flow requirements are met. If a lower priority rule sets the flow lower than the min flow then this rule resets the flow. <br><br>SLOTS SET: Fontenelle.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: 20201210,CF: Fontenelle constraints changed to rules to make differencing runs easier. New rules match CRSS: Safe Channel Capacity, Min Elevation, Max Elevation, Min Flow. Removed from FontenelleMonthlyOutflow() but old function saved FontenelleMonthlyOutflow_Constrained()";
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Outflow" [] < $ "FontenelleData.PeriodicMinFlow" []) THEN
            $ "Fontenelle.Outflow" [] := "Min"( "Max"( $ "FontenelleData.PeriodicMinFlow" [], "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) ), "AvailableWaterInStorage"( % "Fontenelle" ) );

      END_IF_STATEMENT;

    END
    UUID "{ed8de897-373f-4a20-9f8f-c2efc56c26af}";;

    RULE                 "Max Elevation";
    DESCRIPTION          "DESCRIPTION: This rule prevents overtopping. If a previous rule sets the outflow such that the elevation would overtop the dam, this rule will set the outflow to prevent this.  <br><br>SLOTS SET: Fontenelle.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: 20201210,CF: Fontenelle constraints changed to rules to make differencing runs easier. New rules match CRSS: Safe Channel Capacity, Min Elevation, Max Elevation, Min Flow. Removed from FontenelleMonthlyOutflow() but old function saved FontenelleMonthlyOutflow_Constrained()";
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Pool Elevation" [] > $ "FontenelleData.MaxElevation" []) THEN
            $ "Fontenelle.Outflow" [] := $ "Fontenelle.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), @"t" );

      END_IF_STATEMENT;

    END
    UUID "{33f41897-a20b-49ab-8fb3-cb170bd4929a}";;

    RULE                 "Min Elevation";
    DESCRIPTION          "DESCRIPTION:  If a previous rule sets the outflow such that its less than minimum elevation, this rule will set the outflow to prevent this.  <br><br>SLOTS SET: Fontenelle.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: 20201210,CF: Fontenelle constraints changed to rules to make differencing runs easier. New rules match CRSS: Safe Channel Capacity, Min Elevation, Max Elevation, Min Flow. Removed from FontenelleMonthlyOutflow() but old function saved FontenelleMonthlyOutflow_Constrained()";
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Pool Elevation" [] < $ "FontenelleData.MinElevation_FullRecord" []) THEN
            $ "Fontenelle.Outflow" [] := "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MinElevation_FullRecord" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" );

      END_IF_STATEMENT;

    END
    UUID "{cd28fcf7-91c9-452a-a116-19dbfc6b9df5}";;

    RULE                 "Safe Channel Capacity";
    DESCRIPTION          "DESCRIPTION: Prevents outflow from exceeding safe channel capacity unless there is a chance of overtopping, in which case, the &quot;Max Elevation&quot; rule will take precedence. <br><br>SLOTS SET: Fontenelle.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: 20201210,CF: Fontenelle constraints changed to rules to make differencing runs easier. New rules match CRSS: Safe Channel Capacity, Min Elevation, Max Elevation, Min Flow. Removed from FontenelleMonthlyOutflow() but old function saved FontenelleMonthlyOutflow_Constrained()";
    BEGIN

      IF_STATEMENT ($ "Fontenelle.Outflow" [] > $ "FontenelleData.SafeChannelCapacity" []) THEN
            $ "Fontenelle.Outflow" [] := $ "FontenelleData.SafeChannelCapacity" [];

      END_IF_STATEMENT;

    END
    UUID "{193f7fd5-27d2-439e-8d44-f0997f793c66}";;

    RULE                 "Set Fontenelle Outflow";
    DESCRIPTION          "DESCRIPTION: This rule uses a more in depth function that replaces 11 rules that previously set the Fontenelle outflow.  The rule uses the function to set the Fontenelle outflow for the current timestep.<br><br>SLOTS SET: Fontenelle.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: TP, 5/11/2015<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode. ";
    BEGIN

      $ "Fontenelle.Outflow" [] := "Min"( "FontenelleMonthlyOutflow"(  ), "AvailableWaterInStorage"( % "Fontenelle" ) );

    END
    UUID "{133be1ab-b7bd-4a13-9381-5453d74aaa1c}";;

    RULE                 "Set Unset Outflow";
    DESCRIPTION          "DESCRIPTION: Sets the outflow equal to inflow so that  spillCalc and power methods can execute, registering dependencies so that higher priority rules can set values. <br><br>SLOTS SET: Fontenelle.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode. ";
    BEGIN

      $ "Fontenelle.Outflow" [] := $ "Fontenelle.Inflow" [];

    END
    UUID "{48c935bf-7af4-4a02-aa8d-fbb9fd70490b}";;

    RULE                 "ForecastFutureFGInflow";
    DESCRIPTION          "DESCRIPTION: Determines the projected inflow for Flaming Gorge based on the sum of the projected outflow from Fontenelle and the local inflows between Fontenelle and Flaming Gorge.<br><br>SLOTS SET: FlamingGorgeData.ProjectedInflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: ce 6/6/13 (?)<br><br>APivarnik 20200706: Added execution constraint for rule to fire only in MTOM mode. No other changes made to rule in the integration effort<br>APivarnik 20200827: Removed execution constraint for rule to fire only in MTOM mode. ";
    BEGIN

      FOREACH (NUMERIC index IN "GetNumbers"( 1.00000000, IF ( ( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) < 0.00000000 ) COMMENTED_BY "Next month is greater than April, forecast to April of next year" )
 THEN
  12.00000000 - "Abs"( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) ) + 1.00000000
 ELSE
  ( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) + 1.00000000 ) COMMENTED_BY "Forecast to April of current year"
 ENDIF, 1.00000000 )) DO
            $ "FlamingGorgeData.ProjectedInflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] := ( GET @INDEX index - 1.00000000 FROM GET @INDEX 1.00000000 FROM "ForecastFontenelleRelease"( @"t + 1", @"24:00:00 April Max DayOfMonth, Next Year" ) ) + $ "GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow" ["OffsetDate"( @"t", index, "1 MONTHS" )];

      ENDFOREACH;

    END
    UUID "{f3b8d2cf-5fb7-4ee1-8f49-cc2b4eb4874f}";;

  END
  UUID "{7a873760-5a4f-477c-9bc5-253bd2d64401}";;

  POLICY_GROUP   "Set LB Outflows";
  DESCRIPTION    "This policy group contains rules that pertain to Lake Mead operations. Lake Mead has 2 basic modes of operation - meeting downstream demands or flood control.<br><br>There are two primary modes of operation at Lake Mead: Flood Control, and meet downstream demand. Flood Control operations are the highest priority, and are consistent with the 1984 Field Working Agreement between Reclamation and the U.S. Army Corps of Engineers (USACE Flood Control Manual). When Lake Mead is not in Flood Control, the system is operated to meet downstream water demands. In this mode of operation, releases from Lake Mead are currently governed by the 2007 Interim Guidelines. These guidelines specify conditions for determining when the Lower Basin water supply is under the Surplus, Normal, or Shortage Conditions. The guidelines also specify that when certain conditions exist, equalization or balancing of the contents of Lake Powell and Lake Mead shall be achieved. The coordinated operations of the reservoirs are consistent with the described methodology for Lake Powell operations in the previous section and follow the Lake Powell annual release flow chart. Other factors in setting Lake Mead operations are the 1944 Treaty with Mexico and International Boundary and Water Commission (IBWC) Minutes. <br><br>Lake Mohave<br>Lake Mead outflow takes into consideration the amount of water needed to be stored or released from Lake Mohave. The release from Lake Mohave is set to meet the downstream water demands while retaining the end of month target storage (see LBRuleCurveData.Mohave Target Storage).<br><br>Lake Havasu<br>As stated above, Lake Mead outflow takes into consideration the amount of water needed to be stored or released from Lake Mohave and Lake Havasu. The release from Lake Havasu is set with the objectives of meeting the downstream water demands while retaining the end of month target storage (see LBRuleCurveData.Havasu Target Storage). ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Flow To Mexico (flow at NIB) exp";
    DESCRIPTION          "DESCRIPTION: This rule computes the flow to Mexico as the scheduled diversion requested plus the excess and stores it on the Lower Basin Output data object in the slot NIBFlow for subsequent write to hdb<br><br>SLOTS SET: Lower Basin Output.NIBFlow<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>A. Pivarnik, 07062020: No changes made to the rule during the integration effort. This rule matched the 24 MS rule";
    BEGIN

    DESCRIPTION          "Calculate the NIB Flow based on any calculated excess to Mexico less the scheduled request for Mexico. ";
      $ "Lower Basin Output.NIBFlow" [] := $ "Lower Basin Output.MexicoExcessFlow" [] + $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [];

    END
    UUID "{f513418f-ed37-4b6c-9b46-826cf5092a9c}";;

    RULE                 "Set Mexico Excess";
    DESCRIPTION          "DESCRIPTION:  This rule determines the excess flow to Mexico which is just the actual Mead release minus the release determined to meet downstream requirements <br><br>SLOTS SET: Lower Basin Output.MexicoExcessFlow<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>A. Pivarnik, 20200706: No changes made to the rule during the integration effort.";
    BEGIN

    DESCRIPTION          "If the Mead outflow is greater than the sum of the downtream demands, then Mexico gets the excess";
      $ "Lower Basin Output.MexicoExcessFlow" [] := $ "Mead.Outflow" [] - "VolumeToFlow"( $ "Lower Basin Output.DownstreamReq" [], @"t" );

    END
    UUID "{ebcafa4d-1d82-481b-ab17-51b9b4033083}";;

    RULE                 "Set DownStream Requirement exp";
    DESCRIPTION          "DESCRIPTION: This rule calculates the demand downstream of Lake Mead. It should get reset if shortage or surplus schedules are applied.<br><br>SLOTS SET: Lower Basin Output.DownstreamReq<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>S. Baker, 20180620: Added constraint to not use HavasuOutflow.BHOPSParkerOutflow slot prior during Testbed simulations.<br>A. Pivarnik, 20200706: Added California_CU_Schedules.MWD Returns to match the rule in the 24 MS. No other changes made to rule in integration effort";
    BEGIN

    DESCRIPTION          "Set the data object that reports the necessary water required downstream of Mead to meet all demands. ";
      $ "Lower Basin Output.DownstreamReq" [] := IF ( @"t" <= @"Start Timestep" AND ( $ "MTOMRunType.RunType" [] == 0.00000000 ) COMMENTED_BY "For operational MTOM only <br>" )
 THEN
  "FlowToVolume"( $ "HavasuOutflow.BHOPSParkerOutflow" [], @"t" )
 ELSE
  $ "HavasuOutflow.ParkerRequirement" [] COMMENTED_BY "Use in 24 MS mode <br>"
 ENDIF + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - ( "SumAllGainsBelowVolume"( % "Mead", @"t", @"t" ) + $ "California_CU_Schedules.MWDReturns" [@"t"] ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation" [] + $ "Havasu.Evaporation" [];

    END
    UUID "{3e563966-f875-4a72-9b74-d19d15d4a098}";;

    RULE                 "Set Parker Final Requirement";
    DESCRIPTION          "DESCRIPTION: This rule sets the data object slot HavasuOutflow.ParkerRequirement to the difference between the diversions and the local inflows below Havasu<br><br>SLOTS SET: HavasuOutflow.ParkerRequirement<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>S.Baker 06/20/2018: Added time constraint to use historical Gila flows during the testbed simulation during high Gila flows.<br><br>A. Pivarnik 20200706: No changes to this ruleset during the integration. The if statement is not in the 24 MS rule but it does not effect the results of the 24 MS run since it should evaluate to 0";
    BEGIN

      $ "HavasuOutflow.ParkerRequirement" [] := "SumAllDiversionsBelowVolume"( % "Havasu", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Havasu", @"t", @"t" ) + IF ( "GetDate"( "January 31, 1993" ) <= @"t" AND @"t" <= "GetDate"( "April 30, 1993" ) )
 THEN
  "FlowToVolume"( $ "BelowImperialDam:Gila River.Local Inflow" [@"t"], @"t" )
 ELSE
  0.00000000 "acre-ft"
 ENDIF COMMENTED_BY "Testbed Hindcasts - for historical period when Gila had large inflows to the Colorado <br>";

    END
    UUID "{ad06f8d1-9152-457d-bd20-cb2228db89fe}";;

    RULE                 "Havasu Rule Curve";
    DESCRIPTION          "DESCRIPTION: In any month except the Start Timestep, set the Havasu outflow such that the reservoir pool elevation target is met. For testbed hindcasts, this rule executes in the Start Timestep to solve for outflow which is not input using the slot HavasuOutflow.BHOPSParkerOutflow.<br><br>SLOTS SET: Havasu.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000 AND ( ( ( @"t" > @"Start Timestep" AND $ "MTOMRunType.RunType" [] == 0.00000000 ) COMMENTED_BY "Operational MTOM Mode  <br>" ) OR ( ( ( $ "MTOMRunType.RunType" [] == 1.00000000 OR $ "MTOMRunType.RunType" [] == 2.00000000 ) AND @"t" >= @"Start Timestep" ) OR ( "Is24MonthStudy"(  ) AND @"t" > @"Start Timestep + 1" ) COMMENTED_BY "24 MS mode<br>" ) COMMENTED_BY "For testbed hindcasts or dev testing tool, this rule solves for Havasu.Outflow in Start Timestep  <br>" );
    NOTES                "AUTHOR, DATE: Unknown<br>Unknown Commenter, Unknown Date: This rule could just as easily use a target elevation rather than a storage. It would probably be safer to do so.<br><br>S.Baker 06/20/2018: Added execution constraint to solve this rule at start timestep for Testbed simulations.<br>SB 07/08/2019: Updated constraints to have Run Type not equal to 0 (allows for no dependence on BHOPS during development testing). <br>A. Pivarnik, 20200706: There was no change to this rule in the integration effort. The rule in 24 MS and MTOM were the same. Added execution constraing to fire in 24 MS mode<br>A. Pivarnik, 20200731: Adjusted eecution constraints to fire correctly depending on model run type";
    BEGIN

      $ "Havasu.Outflow" [] := "SolveOutflow"( % "Havasu", $ "Havasu.Inflow" [], "GetTargetStorage"( % "Havasu", @"t" ), $ "Havasu.Storage" [@"t - 1"], @"t" );

    END
    UUID "{0375c354-2ed5-4241-9eca-df876c536bc8}";;

    RULE                 "Set Havasu Outflow Exp";
    DESCRIPTION          "DESCRIPTION: If the Havasu outflow is not set at the Start Timestep, set it to the BHOPS Parker Outflow, which is a user input value and comes from the 24 MS. <br><br>SLOTS SET: Havasu.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Havasu.Outflow" [] AND ( ( $ "MTOMRunType.RunType" [] == 0.00000000 AND @"t" <= @"Start Timestep" ) OR ( "Is24MonthStudy"(  ) AND @"t" <= @"Start Timestep + 1" ) ) COMMENTED_BY "For operational MTOM and 24 MS only  <br>" AND "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>MC, 20160426: LC changed this from setting the first 2 months of the run to just the first month<br><br>S.Baker 06/20/2018: Added execution constraint to not use HavasuOutflow.BHOPSParkerOutflow slot prior during Testbed simulations.<br>A. Pivarnik 20200706: There was no change to this rule in the integration effort. The rule in 24 MS and MTOM were the same. Added execution constraint to fire in 24 MS mode";
    BEGIN

      $ "Havasu.Outflow" [] := $ "HavasuOutflow.BHOPSParkerOutflow" [];

    END
    UUID "{33b3442f-e3fe-4cc1-bf0d-3e91221f5a39}";;

    RULE                 "Mohave Rule Curve";
    DESCRIPTION          "DESCRIPTION: Set the Outflow from Mohave to what is necesary to hit the Mohave Target Storages. This rule passes the inflow necessary to meet downstream demands and preserve the target storage for Mohave.<br><br>SLOTS SET: Mohave.Outflow<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>Unknown Commenter, Unknow Date: This rule could just as easily use a target elevation rather than a storage. It would probably be safer to do so.<br><br>A. Pivarnik 20200706: There was no change to this rule in the integration effort. The rule in 24 MS and MTOM were the same";
    BEGIN

      $ "Mohave.Outflow" [] := "SolveOutflow"( % "Mohave", $ "Mohave.Inflow" [], "GetTargetStorage"( % "Mohave", @"t" ), $ "Mohave.Storage" [@"t - 1"], @"t" );

    END
    UUID "{eb9fe1ff-9f68-4273-9f41-8671b11fb9b9}";;

    RULE                 "Set Mead Outflow To Demands";
    DESCRIPTION          "DESCRIPTION: Set the Lake Mead outflow to the smaller of the sum of the lower basin demands OR the water available in Mead (if Run Cycle >=3; otherwise use 9,999,999 acre-ft/month). This rule can execute as many times as necessary to set releases to meet demands. <br><br>SLOTS SET: Mead.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>S.Baker, 20200326: Edited IF ELSE statement to reduce redundancy. <br>S.Baker 06/20/2018: Added constraint to not use HavasuOutflow.BHOPSParkerOutflow slot prior during Testbed simulations.<br>S.Baker 2018/10/17: Replace SumAllDiversionsBelowVolume(Havasu) - SumAllGainsBelowVolume(Havasu) with HavasuOutflow.ParkerRequirement. This change was made because this calculation was already performed in rule &quot;Set Parker Final Requirement&quot;, so it was repetative and problematic to recalculate them. This change is important during hindcast runs when the Gila River has ver high local inflows (Jan-Apr 1993). <br>A. Pivarnik 20200706: No change to the rule logic in the integration effort. This rule logic should provide the same result as the old 24 MS logic";
    BEGIN

      $ "Mead.Outflow" [] := "Min"( IF ( "GetRunCycleIndex"(  ) >= 3.00000000 )
 THEN
  "CheckResPhysicalConstraint"( % "Mead", @"t" )
 ELSE
  9999999.00000000 "acre-ft/month"
 ENDIF, "VolumeToFlow"( IF ( @"t" <= @"Start Timestep" AND $ "MTOMRunType.RunType" [] == 0.00000000 )
 THEN
  "FlowToVolume"( $ "HavasuOutflow.BHOPSParkerOutflow" [], @"t" ) COMMENTED_BY "Operational MTOM runs only  <br>"
 ELSE
  $ "HavasuOutflow.ParkerRequirement" [@"t"] COMMENTED_BY "Hindcast MTOM runs <br>"
 ENDIF + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - ( "SumAllGainsBelowVolume"( % "Mead", @"t", @"t" ) + $ "California_CU_Schedules.MWDReturns" [@"t"] ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Mohave", "GetTargetStorage"( % "Mohave", @"t" ) ) + "StorageToArea"( % "Mohave", $ "Mohave.Storage" [@"t - 1"] ) ) / 2.00000000 ) * 1.00000000 "month" + $ "Havasu.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Havasu", "GetTargetStorage"( % "Havasu", @"t" ) ) + "StorageToArea"( % "Havasu", $ "Havasu.Storage" [@"t - 1"] ) ) / 2.00000000 ) * 1.00000000 "month", @"t" ) );

    END
    UUID "{5a2f1e38-f3a3-4800-9a33-a26b907141e7}";;

  END
  UUID "{586ddaa3-719a-454a-a6a5-6f7dae3e56c7}";;

  POLICY_GROUP   "Set Future Uses - SNWP, CAP, MWD";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Reset Monthly Forecast Use CAP - Nov and Dec, Cur Year";
    DESCRIPTION          "DESCRIPTION: Reset the CAP Diversion requests based on the estimated available to CAP from the state apportionment and the other user diversion requests and the forecast scheduled volume for CAP.  This rule will only execute in the start timestep and set values for November and December.  This is so that if CAP sets a schedule in a timestep prior to November, the schedule can be adjusted in the last two months of the year such that there are no Arizona overruns. <br><br>SLOTS SET: CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik, 20200702: Added assignment for CAP Depeletion requested to match the 24 MS. Rewrote rule using with statment and used temporary variable to set both CAP depletion and diversion since the values are the same. Made call to December of current year consistant throughout the rule";
    BEGIN

    DESCRIPTION          "reset the CAP Diversion requests based on the estimated available to CAP from the state apportionment and the other user diversion requests and the forecast scheduled volume for CAP.  This <br><br>rule will only execute in the start timestep and set values for November and December.  This is so that if CAP sets a schedule in a timestep prior to November, the schedule can be adjusted in <br><br>the last two months of the year such that there are no Arizona overruns. ";
      FOREACH (DATETIME date IN @"24:00:00 November Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC CAPMonthlyDiv = ( ( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"], date ) - "VolumeToFlow"( $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December Max DayOfMonth, Current Year"], date ) ) / 2.00000000 + "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date ) )) DO
            $ "CAPDiversion.Total Diversion Requested" [date] := CAPMonthlyDiv;

            $ "CAPDiversion.Total Depletion Requested" [date] := CAPMonthlyDiv;

      END_WITH_STATEMENT;

      ENDFOREACH;

    END
    UUID "{46c06ffb-507e-4fc1-bc8d-a98cd4cb34ac}";;

    RULE                 "Reset Monthly Forecast Use CAP - All Months Outyears";
    DESCRIPTION          "DESCRIPTION: Reset the CAP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests). <br><br>SLOTS SET: CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>AP, 9/18/2018: Moved CAP logic to function called CAP_Outyear_Schedules. Referenced function in rule.<br>APivarnik, 20200702: This rule is written differently than in the 24 MS ruleset but accomplishes the same goal. Added assignment for CAP total depletion to match 24 MS rule";
    BEGIN

    DESCRIPTION          "Reset the CAP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests). ";
      FOREACH (DATETIME date IN "GetFirstDate"( @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := "CAP_Outyear_Schedules"( date );

            $ "CAPDiversion.Total Depletion Requested" [date] := "CAP_Outyear_Schedules"( date );

      ENDFOREACH;

    END
    UUID "{21db1fa6-6df2-4b18-9acf-f722210fb9b7}";;

    RULE                 "Reset Monthly Forecast Use SNWP All Years";
    DESCRIPTION          "DESCRIPTION: Reset the SNWP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests).  Sets LBDV.ScehduleCheck value to 0 (normal operating condition)<br><br>SLOTS SET: PumpingFromLakeMead:SNWP.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>AP, 9/18/2018: Moved SNWP logic to function called SNWP_Schedules. Referenced function in rule. Changed logic in SNWP Schedules function to refernce Nevada_CU_Schedules instead of PumpingfromMead. Added LBDV.Schedule check inital set up value<br><br>APivarnik, 20200702: Added if conditional to set the LBDV schedule check if running in MTOM mode only.While written slightly different than the rule by the same name in the 24 MS, this rule accomplishes the same goal with different logic. No changes to the logic made which sets PumpingfromMead values";
    BEGIN

    DESCRIPTION          "Reset the SNWP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests).  ";
      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" }) DO
            slot [date] := "SNWP_Schedules"( date );

      ENDFOREACH;

      ENDFOREACH;

      IF_STATEMENT (NOT "Is24MonthStudy"(  )) THEN
            $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] := 0.00000000;

      END_IF_STATEMENT;

    END
    UUID "{d8c940fe-8ff1-4a07-89c2-08629557ebd0}";;

    RULE                 "Redistribute MWD Nov & Dec Div Request";
    DESCRIPTION          "DESCRIPTION: This rule redistributes Nov and Dec MWD requests that may be over the canal capacity.  This can occur when LBDV is initiated below Parker and there is additional supply available to MWD.<br><br>SLOTS SET: MWDDiversion:MWD.Diversion Requested; ICS Credits.AnnualCreationEC_CA<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 ) AND NOT "Is24MonthStudy"(  );
    NOTES                "AUTHOR, DATE: MC/JR, Unknown<br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed, also changing ForecastUse.MWDResetAnnualFC, because creation of EC ICS (an Input value) is not allowed in that case (Shortage).<br><br>MC, 20180125: Removed Shortage as condition for Execution Constraint based on USBR changes to rules<br><br>CH, 4/25/18: Removed run cycle == 3.0 constraint since rule only fires in start year (therefore should not refire in run cycle 3 for any reason, even in shortage conditions - causes the rule to add twice the amount of water available)<br><br>GCAA, 20181030: Changed reference from MWDDiversionData.MWDCanal_DailyCapacity slot to MWDAndCAPRech: MWDDiversion. Diversion Capacity slot<br><br>APivarnik, 20200702: This rule is in MTOM only. Added execution constraint to prevent rule from firing in 24 MS mode";
    BEGIN

      WITH_STATEMENT (NUMERIC InitialTotalRequest = FOR ( DATETIME date IN "GetDates"( @"t", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "MWDDiversion.Total Diversion Requested" [date], date )
 ENDFOR) DO
          DESCRIPTION          "<br>If Nov or Dec diversion request exceeds canal capacity, redistribute the excess request to months between the current month and October of the current year.<br>";
      WITH_STATEMENT (NUMERIC NovExcessRequest = "Max"( $ "MWDDiversion.Total Diversion Requested" [@"24:00:00 November Max DayOfMonth, Current Year"] - $ "MWDDiversionData.MWDCanal_DailyCapacity" [], 0.00000000 "acre-feet/month" )) DO
            WITH_STATEMENT (NUMERIC DecExcessRequest = "Max"( $ "MWDDiversion.Total Diversion Requested" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "MWDDiversionData.MWDCanal_DailyCapacity" [], 0.00000000 "acre-feet/month" )) DO
            IF_STATEMENT (NovExcessRequest + DecExcessRequest > 0.00000000 "acre-feet/month") THEN
          DESCRIPTION          "Redistribute excess diversion requests";
      FOREACH (DATETIME date IN "GetDates"( @"t", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" )) DO
            $ "MWDDiversion:MWD.Diversion Requested" [date] := ( GET @INDEX "GetMonth"( date ) - 1.00000000 FROM "CheckAndAdjustToCapacity"( $ "MWDDiversion.Total Diversion Requested", $ "MWDDiversionData.MWDCanal_DailyCapacity" [] ) ) - $ "MWDDiversion:Tijuana.Diversion Requested" [date];

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC FinalTotalRequest = FOR ( DATETIME date IN "GetDates"( @"t", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "MWDDiversion.Total Diversion Requested" [date], date )
 ENDFOR) DO
          DESCRIPTION          "If the request excess is more than available capacity, assign the remainder to <br>ICS EC credits";
      WITH_STATEMENT (NUMERIC ICSAddition = "Max"( InitialTotalRequest - FinalTotalRequest, 0.00000000 "acre-feet" )) DO
            $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] := NaNToZero ( $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] ) + ICSAddition;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{5e060dc1-bbce-4060-af25-f6f7b749b1a6}";;

    RULE                 "Reset Monthly Forecast Use MWD - Nov and Dec, Cur Year";
    DESCRIPTION          "DESCRIPTION: Reset the MWD DIversion and depletion requests based on the estimated available to MWD from the state apportionment and the other user diversion requests and the forecast scheduled volume for MWD.  This rule will only execute in the start timestep and set values for November and December.  This is so that if MWD sets a schedule in a timestep prior to November, the schedule can be adjusted in the last two months of the year such that there are no California overruns. <br><br>SLOTS SET: MWDDiversion:MWD.Depletion Requested; MWDDiversion:MWD.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed, also changing ForecastUse.MWDResetAnnualFC, because creation of EC ICS (an Input value) is not allowed in that case.<br><br>MC, 20180125: Removed Shortage as condition for Execution Constraint based on USBR changes to rules<br><br>CH, 3/18: Removed run cycle == 3.0 constraint since rule only fires in start year (therefore should not refire in run cycle 3 for any reason, even in shortage conditions - causes the rule to add twice the amount of water available)<br><br>APivarnik, 20200702: While written slightly different than the rule by the same name in the 24 MS, this rule accomplishes the same goal with different logic. No changes to the rule made in the integration effort <br><br>APivarnik, 07302020: Changed slot reference from MWD Depletion requested to CU schedule.MWD";
    BEGIN

    DESCRIPTION          "reset the MWD Diversion and depletion requests based on the estimated available to MWD from <br>the state apportionment and the other user diversion requests and the forecast scheduled <br>volume for MWD.  <br><br>This rule will only execute in the start timestep and set values for November and December.  This <br>is so that if MWD sets a schedule in a timestep prior to November, the schedule can be adjusted <br>in the last two months of the year such that there are no California overruns.  <br>";
      FOREACH (DATETIME date IN @"24:00:00 November Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC mwdDepletionAmount = "Max"( 0.00000000 "acre-ft/month", ( "VolumeToFlow"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "California_CU_Forecast1.MWD" ["Dec31ofYear"( date )], date ) ) / 2.00000000 + "VolumeToFlow"( $ "California_CU_Schedules.MWD" [date], date ) )) DO
            $ "MWDDiversion:MWD.Depletion Requested" [date] := mwdDepletionAmount;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := mwdDepletionAmount + "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

      END_WITH_STATEMENT;

      ENDFOREACH;

    END
    UUID "{efcb9e54-8d56-452f-b9f7-d8a6b6402d05}";;

    RULE                 "Reset Monthly Forecast Use MWD - All Months Outyears";
    DESCRIPTION          "DESCRIPTION: Reset the MWD Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests).  This calculation gives the amount of water that California can take as a consumptive use amount so the diversion needs to be set to that amount plus the estimated return flow that is returned at the diversion location. <br><br>SLOTS SET: MWDDiversion:MWD.Depletion Requested; MWDDiversion:MWD.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "IsJANofOutyear"(  ) AND ( ( "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) OR ( ( "GetRunCycleIndex"(  ) == 3.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 ) COMMENTED_BY "LC CHECK: Is this constraint needed <br>" ) );
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed, also changing ForecastUse.MWDResetAnnualFC, because creation of EC ICS (an Input value) is not allowed in that case.<br><br>APivarnik, 20180918: Moved MWD  logic to function called MWD_Outyear_Schedules. Referenced function in rule.<br><br>APivarnik, 20200702: While written slightly different than the rule by the same name in the 24 MS, the rule accomplishes the same goal with different logic. No changes to the rule made in the integration effort <br><br>APivarnik, 20201222: Added set negative to 0 function to prevent setting MWD diversion/depletion to negative value";
    BEGIN

    DESCRIPTION          "Reset the MWD Diversion request based on the reset annual forecast use (difference in state apportionment and the other <br>diversion requests).  This calculation gives the amount of water that California can take as a consumptive use amount so <br>the diversion needs to be set to that amount plus the estimated return flow that is returned at the diversion location. ";
      FOREACH (DATETIME date IN "GetFirstDate"( @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC mwdDepletionAmount = "MWD_Outyear_Schedules"( date )) DO
            $ "MWDDiversion:MWD.Depletion Requested" [date] := "SetNegativeToZero"( mwdDepletionAmount );

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "SetNegativeToZero"( mwdDepletionAmount ) + "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

      END_WITH_STATEMENT;

      ENDFOREACH;

    END
    UUID "{563dc57a-88df-4805-b064-14156d08eab3}";;

    RULE                 "SumAnnualStateUse - Div Req";
    DESCRIPTION          "DESCRIPTION: Sum the Annual State Use based on the monthly orders for AZ without CAP, NV, and CA without MWD<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalAnnual; AnnualWaterUse.NvTotalAnnual; AnnualWaterUse.CaNoMWDTotalAnnual";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik, 20200702: Integration effort. Added with and if statement to choose between the different lists that were use in the MTOM vs the 24 MS ruleset<br>APivarnik, 20200730: Integration effort. Rmeoved if/with statements added previously. ";
    BEGIN

    DESCRIPTION          "Sum the Annual State Use based on the Monthly orders for AZ without CAP, Nevada, and <br><br>California with no MWD considered. ";
      FOREACH (STRING state IN { "AzNoCAP" , "Nv" , "CaNoMWD" }) DO
            "AnnualWaterUse." CONCAT state CONCAT "TotalAnnual" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
 THEN
  "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyOrder" ), @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" ) + "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyActual" ), @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" )
 ELSE
  "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyOrder" ), @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{83e8f68d-0c6d-4521-975e-289b72ece3e4}";;

    RULE                 "SumStateMonthlyOrders - DivReq";
    DESCRIPTION          "DESCRIPTION: Sum the monthly AZ no CAP, NV, and CA no MWD orders based on the set diversion request for each state's diversion locations.<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalMonthlyOrder; AnnualWaterUse.NvTotalMonthlyOrder; AnnualWaterUse.CaNoMWDTotalMonthlyOrder";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik, 20200501: Replaced non SNWP water users individually listed with function call<br><br>APivarnik, 20200702: Integration effort. Added if conditional statement to set assignment only when running in an MTOM mode. This slot assignment was not in the 24 MS<br><br>APivarnik, 20200730: Removed if conditional statement.<br>";
    BEGIN

    DESCRIPTION          "Sum the Monthly AZ no CAP, Nevada, and CA no MWD orders based on the set diversion request <br><br>for each state's diversion locations. ";
      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "AnnualWaterUse.AzNoCAPTotalMonthlyOrder" [date] := "FlowToVolume"( $ "AzPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaGravityMainCanal.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaAndYumaUsers.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR:CRIRAz.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:BlmPumpersBlwImp.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:SouthernPacific.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:YAO.Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:AZ.Diversion Requested" [date], date ) + "FlowToVolume"( $ "AzDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "PumpingFromLakeMead:LMNRA Az Mead.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Az Mohave.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:Ft Yuma.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:DavisDamProject.Diversion Requested" [date], date );

            $ "AnnualWaterUse.NvTotalMonthlyOrder" [date] := "FlowToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date], date ) + "Monthly Sum Non SNWP Nevada Users"( date );

            $ "AnnualWaterUse.CaNoMWDTotalMonthlyOrder" [date] := "FlowToVolume"( $ "AAC.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR:CRIRCa.Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:CA.Diversion Requested" [date], date ) + "FlowToVolume"( $ "PaloVerde.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:YumaIsland.Diversion Requested" [date], date );

      ENDFOREACH;

    END
    UUID "{7764ff99-7df7-485a-b1de-8bf3e55a4fab}";;

    RULE                 "Reset Annual MWD Forecast Use - Force to CA Apportionment";
    DESCRIPTION          "DESCRIPTION: Set the MWD Forecast annual diversion to the state apportionment (in the deterministic run or in the first year of the run, use the input state apportionment, in an outyear use the adjusted state apportionment), less any senior users to MWD diversion requested. <br><br>SLOTS SET: ForecastUse.MWDResetAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000 OR ( "GetRunCycleIndex"(  ) == 3.00000000 AND ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed because creation of EC ICS (an Input value) is not allowed in that case.<br><br>APivarnik, 20200702: Added if conditional statement for different calculations between MTOM and 24 MS ruleset. Renamed rule to match AZ and NV naming convention for similar rules. ";
    BEGIN

    DESCRIPTION          "Set the MWD Forecast annual diversion to the state apportionment (in the deterministic run or in <br><br>the first year of the run, use the input state apportionment, in an outyear use the adjusted state <br><br>apportionment), less any senior users to MWD diversion requested. For 24 MS, use input state <br>apportionment <br>";
      $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] := "Min"( $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [], IF ( "IsMRM"(  ) )
 THEN
  IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" )
  THEN
   $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
  ELSE
   $ "AnnualWaterUse.California_PreliminaryAdjustedApportionment" [@"24:00:00 December 31, Current Year"]
  ENDIF
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF - FOR ( DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 January Max DayOfMonth, Current Year" ) TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  FOR ( OBJECT diversionSite IN "ListSubbasin"( "California nonMWD WaterUsers" ) ) STAT_SUM
   IF ( diversionSite == % "PaloVerde" )
   THEN
    "FlowToVolume"( diversionSite & "Total Diversion Requested" [date], date )
   ELSE
    "FlowToVolume"( diversionSite & "Diversion Requested" [date], date )
   ENDIF
  ENDFOR
 ENDFOR COMMENTED_BY "Sum all Non MWD Diversion Requests" );

    END
    UUID "{544ed018-d60e-4aad-acb5-dd4c656bc465}";;

    RULE                 "Reset Annual CAP Forecast Use - Force to AZ Apportionment";
    DESCRIPTION          "DESCRIPTION: Set the CAP annual diversion to the AZ state apportionment less the more senior Arizona diversions. <br><br>SLOTS SET: ForecastUse.CAPResetAnnualFC<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br><br>APivarnik, 20200702: Added if conditional statement to choose between 24 MS calculation and MTOM calulaction. This is for the integration effort<br>APivarnik, 20200730: removed if conditional statment for 24 MS calculation method. The two calculation methods would evaluate to the same value";
    BEGIN

    DESCRIPTION          "Set the CAP annual diversion to the AZ state apportionment less the more senior Arizona <br>diversions.  <br>";
      $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.Arizona_Apportionment" [@"24:00:00 December 31, Current Year"] - FOR ( DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year" ) STAT_SUM
  FOR ( OBJECT nonCAPUser IN "ListSubbasin"( "ArizonaNonCAPWaterUsers" ) ) STAT_SUM
   "FlowToVolume"( nonCAPUser & "Diversion Requested" [date], date )
  ENDFOR
 ENDFOR COMMENTED_BY "Sum all Non CAP Diversion Requests";

    END
    UUID "{668578ea-2770-4bda-80d5-476c189e9839}";;

    RULE                 "Reset Annual SNWP Forecast Use - Force to NV Apportionment";
    DESCRIPTION          "DESCRIPTION: Set the SNWP Forecast value to the difference between the Nevada State Apportionment and the other Nevada users. <br><br>SLOTS SET: ForecastUse.SNWPResetAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>APivarnik, 20200501: Replaced non SNWP water users individually listed with function call<br>Apivarnik, 20200702: Added if statement for 24 MS calculation vs MTOM calculation for integration effort<br>APivarnik, 20200730: removed if conditional statment for 24 MS calculation method. The two calculation methods would evaluate to the same value<br>";
    BEGIN

    DESCRIPTION          "Set the SNWP Forecast value to the difference between the Nevada State Apportionment and <br>the other Nevada users.  <br>";
      $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"] - FOR ( DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year" ) STAT_SUM
  "Monthly Sum Non SNWP Nevada Users"( date )
 ENDFOR COMMENTED_BY "Sum all Non SNWP Nevada Diversion Requests";

    END
    UUID "{6b824f48-1616-4d21-8f3e-816e455c3b3e}";;

  END
  UUID "{7e173aff-9bcd-40e6-b773-b139658bd9bb}";;

  POLICY_GROUP   "LC WaterUse Data Setup";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Operational GainLoss";
    DESCRIPTION          "DESCRIPTION: Set the Operational Gain loss on the Havasu to Imperial Reach object by taking the difference between what is scheduled on the reach objects and what is input to the model as the Scheduled outflow from Havasu. <br><br>SLOTS SET: HavasuToImperial:DailyOperationalGainLoss.LocalInflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker 06/20/2018: Added constraint to not use HavasuOutflow.BHOPSParkerOutflow slot prior during Testbed simulations.<br>APivarnik, 20200701: Added constraint to fire the rule in 24 MS mode for integration effort. The date constraint is different for MTOM and 24 MS in the if statement.<br>APivarnik, 20200731: Changed if conditional statement to only calculate in 24 MS mode else 0. Added RC = 1 in execution constraint";
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "HavasuToImperial:DailyOperationalGainLoss.Local Inflow" [date] := IF ( ( date <= @"24:00:00 December Max DayOfMonth, Current Year" AND "Is24MonthStudy"(  ) ) COMMENTED_BY "For 24 MS <br>" )
 THEN
  ( "VolumeToFlow"( $ "HavasuOutflow.ParkerScheduleRequirement" [date], date ) - $ "HavasuOutflow.BHOPSParkerOutflow" [date] )
 ELSE
  0.00000000 "acre-ft/month"
 ENDIF;

      ENDFOREACH;

    END
    UUID "{04bca818-17f0-4220-96b3-05d37ba74ece}";;

    RULE                 "Set Parker Schedule Requirement";
    DESCRIPTION          "DESCRIPTION: Sum the diversion requests that were set in a previous rule and set the slot value for the total required release from Havasu for the model run period.<br><br>SLOTS SET: HavasuOutflow.ParkerScheduleRequirement<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND IsNaN $ "HavasuOutflow.ParkerScheduleRequirement" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200701: No changes made during the integration effort, rule is the same in the 24 MS and MTOM";
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "HavasuOutflow.ParkerScheduleRequirement" [date] := "FlowToVolume"( $ "AAC.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "AzPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaAndYumaUsers.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaGravityMainCanal.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "PaloVerde.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "MexicanTreatyDelivery.Total Diversion Requested" [date], date ) - ( "FlowToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date], date ) + "FlowToVolume"( $ "BelowImperialDam:Forbeared Return Flow Credits.Local Inflow" [date], date ) + "FlowToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date], date ) + "FlowToVolume"( $ "BelowImperialDam:Gila River.Local Inflow" [date], date ) );

      ENDFOREACH;

    END
    UUID "{dfdd7d1f-c7ac-4df0-9c43-f80279333e84}";;

    RULE                 "Sum State Monthly Actual CU";
    DESCRIPTION          "DESCRIPTION: Calculate the Annual Consumptive Use values for all users in each of the lower basin states less the junior priority users, if applicable, for the beginning of the current year to the timestep prior to the run start. For Arizona, calculate the consumptive use forecast without CAP considered. For Nevada calculate the total Consumptive use forecast. For California, calculate the consumptive use forecast without MWD being considered.<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalMonthlyActual; AnnualWaterUse.NvTotalMonthlyActual; AnnualWaterUse.CaNoMWDTotalMonthlyActual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200701:  This rule covers the &quot;SumStateMonthlyActualCU-noP123b or IID&quot; from the 24 MS. ";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
            $ "AnnualWaterUse.AzNoCAPTotalMonthlyActual" [date] := $ "Arizona_CU_Actual.CRIRAz" [date] + $ "Arizona_CU_Actual.CibolaNWR" [date] + $ "Arizona_CU_Actual.CibolaValleyIID" [date] + $ "Arizona_CU_Actual.City of Parker" [date] + $ "Arizona_CU_Actual.ImperialNWR" [date] + $ "Arizona_CU_Actual.BrookeWater" [date] + $ "Arizona_CU_Actual.Ehrenberg" [date] + $ "Arizona_CU_Actual.AzPumpersAbvImp" [date] + $ "Arizona_CU_Actual.AzPumpersBlwImp" [date] + $ "Arizona_CU_Actual.BlmPumpersAbvImp" [date] + $ "Arizona_CU_Actual.BlmPumpersBlwImp" [date] + $ "Arizona_CU_Actual.NGVIDD" [date] + $ "Arizona_CU_Actual.WMIDD" [date] + $ "Arizona_CU_Actual.YCWUA" [date] + $ "Arizona_CU_Actual.MCAirStation" [date] + $ "Arizona_CU_Actual.YMIDD" [date] + $ "Arizona_CU_Actual.YID" [date] + $ "Arizona_CU_Actual.UnitB" [date] + $ "Arizona_CU_Actual.City of Yuma" [date] + $ "Arizona_CU_Actual.UofA" [date] + $ "Arizona_CU_Actual.LakeHavasuCity" [date] + $ "Arizona_CU_Actual.YumaUnionHighScl" [date] + $ "Arizona_CU_Actual.YumaProvingGround" [date] + $ "Arizona_CU_Actual.Cocopah Indian Res" [date] + $ "Arizona_CU_Actual.Gila Monster Farms" [date] + $ "Arizona_CU_Actual.DesertLawnMemorial" [date] + $ "Arizona_CU_Actual.SouthernPacific" [date] + $ "Arizona_CU_Actual.YAO" [date] + $ "Arizona_CU_Actual.BullheadCity" [date] + $ "Arizona_CU_Actual.FtMohaveAz" [date] + $ "Arizona_CU_Actual.DavisDamProject" [date] + $ "Arizona_CU_Actual.MohaveValleyIID" [date] + $ "Arizona_CU_Actual.MohaveWaterConsDist" [date] + $ "Arizona_CU_Actual.HavasuNWR" [date] + $ "Arizona_CU_Actual.GoldenShores" [date] + $ "Arizona_CU_Actual.LMNRA Az Mead" [date] + $ "Arizona_CU_Actual.LMNRA Az Mohave" [date] + $ "Arizona_CU_Actual.Ft Yuma" [date] + $ "Arizona_CU_Actual.AzPumpersDvsToPkr" [date];

            $ "AnnualWaterUse.NvTotalMonthlyActual" [date] := $ "Nevada_CU_Actual.SNWP" [date] + $ "Nevada_CU_Actual.FtMohaveNv" [date] + $ "Nevada_CU_Actual.BigBend" [date] + $ "Nevada_CU_Actual.SCE" [date] + $ "Nevada_CU_Actual.LMNRA Mohave" [date];

            $ "AnnualWaterUse.CaNoMWDTotalMonthlyActual" [date] := $ "California_CU_Actual.CaPumpersAbvImp" [date] + $ "California_CU_Actual.Chemehuevi" [date] + $ "California_CU_Actual.Coachella" [date] + $ "California_CU_Actual.CRIRCa" [date] + $ "California_CU_Actual.FtMohaveCa" [date] + $ "California_CU_Actual.IID" [date] + $ "California_CU_Actual.Needles" [date] + $ "California_CU_Actual.OtherLCWSP" [date] + $ "California_CU_Actual.PaloVerde" [date] + $ "California_CU_Actual.Ranch5" [date] + $ "California_CU_Actual.SaltonSea" [date] + $ "California_CU_Actual.Winterhaven" [date] + $ "California_CU_Actual.YumaIsland" [date] + $ "California_CU_Actual.YumaProject" [date];

      ENDFOREACH;

    END
    UUID "{074e3a35-f288-4627-9263-86bb45d7b920}";;

    RULE                 "Overruns Based on State Apportionments";
    DESCRIPTION          "DESCRIPTION: Estimate each lower basin state's Overrun based on the forecast values and the state apportionment values<br><br>SLOTS SET: California_CU_Overrun.California_Overrun_State_Ap;Arizona_CU_Overrun.Arizona_Overrun_State_Ap; Nevada_CU_Overrun.Nevada_Overrun_State_Ap;<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200701: No changes made to rule in the 24 MS/MTOM integration effort";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            "GetObject"( state CONCAT "_CU_Overrun" ) & ( state CONCAT "_Overrun_State_Ap" ) [] := % "AnnualWaterUse" & ( state CONCAT "_Forecast1" ) [@"24:00:00 December 31, Current Year"] - % "AnnualWaterUse" & ( state CONCAT "_Apportionment" ) [@"24:00:00 December 31, Current Year"];

      ENDFOREACH;

    END
    UUID "{ba177302-b731-43b6-8149-bf9008564815}";;

    RULE                 "Sum Annual Approvals for Lower Basin States";
    DESCRIPTION          "DESCRIPTION: Sum the monthly Annual Approval input values to Annual Approval values calculated from the input consumptive use schedules at the beginning of the run. <br><br>SLOTS SET: AnnualWaterUse.California_AnnualApproval; AnnualWaterUse.Nevada_AnnualApproval; AnnualWaterUse.Arizona_AnnualApproval;<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200701: No change in the rule for the 24 MS integration effort. This rule matches the 24 MS";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "AnnualWaterUse" & ( state CONCAT "_AnnualApproval" ) [@"24:00:00 December 31, Current Year"] := IF ( state == "Nevada" )
 THEN
  $ "Nevada_CU_AnnualApproval.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.BigBend" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.FtMohaveNv" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.LMNRA Mohave" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.SCE" [@"24:00:00 December 31, Current Year"]
 ELSE
  IF ( state == "California" )
  THEN
   "SumSlotListDates"( "GetObject"( state CONCAT "_CU_AnnualApproval" ), @"24:00:00 December 31, Current Year" ) - $ "California_CU_AnnualApproval.MWDDiversion" [@"24:00:00 December 31, Current Year"] - $ "California_CU_AnnualApproval.MWDReturns" [@"24:00:00 December 31, Current Year"]
  ELSE
   "SumSlotListDates"( "GetObject"( state CONCAT "_CU_AnnualApproval" ), @"24:00:00 December 31, Current Year" )
  ENDIF
 ENDIF;

      ENDFOREACH;

    END
    UUID "{3c7abdfe-ad66-44e1-bea0-7bb0c3e018fa}";;

    RULE                 "Sum Annual Forecast1 for Lower Basin States";
    DESCRIPTION          "DESCRIPTION: Sum the various components for each state forecast and set and Annual Forecast estimation for each state<br><br>SLOTS SET: AnnualWaterUse.California_Forecast1; AnnualWaterUse.Nevada_Forecast1; AnnualWaterUse.Arizona_Forecast1<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200701: No changes to this ruleset in the integration effort. This rule matches whats in the 24 MS.";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "AnnualWaterUse" & ( state CONCAT "_Forecast1" ) [@"24:00:00 December 31, Current Year"] := IF ( state == "Nevada" )
 THEN
  $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.BigBend" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.FtMohaveNv" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.LMNRA Mohave" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.SCE" [@"24:00:00 December 31, Current Year"]
 ELSE
  IF ( state == "California" )
  THEN
   "SumSlotListDates"( % "California_CU_Forecast1", @"24:00:00 December 31, Current Year" ) - $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"] - $ "California_CU_Forecast1.MWDReturns" [@"24:00:00 December 31, Current Year"]
  ELSE
   "SumSlotListDates"( % "Arizona_CU_Forecast1", @"24:00:00 December 31, Current Year" )
  ENDIF
 ENDIF;

      ENDFOREACH;

    END
    UUID "{a0c88090-f56a-4e20-8edf-bea9a8bd42c1}";;

    RULE                 "Set Forecast1";
    DESCRIPTION          "DESCRIPTION: Determine the Annual Demand for each user in each &quot;State_CU_Forecast1&quot; object by summing the actual and consumptive use schedules for each user. <br><br>SLOTS SET: <state>_CU_Forecast1.<user><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND ( @"t" == @"Start Timestep" OR "IsJANofOutyear"(  ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200701: No changes to ruleset in 24 MS/MTOM integration effort. This rule matches whats in the 24 <br>APivarnik, 20200730: Adjusted execution constraint to only fire in start timestep";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" , "Mexico" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Forecast1" ) )) DO
            "GetObject"( state CONCAT "_CU_Forecast1" ) & user [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
 THEN
  "SumSlot"( "GetObject"( state CONCAT "_CU_Actual" ) & user, @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" ) + "SumSlot"( "GetObject"( state CONCAT "_CU_Schedules" ) & user, @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" )
 ELSE
  "AnnualVolumeSlot"( "GetObject"( state CONCAT "_CU_Schedules" ) & user )
 ENDIF;

      ENDFOREACH;

      ENDFOREACH;

    END
    UUID "{9d1216c4-ec52-4468-a32d-0b92fff6e234}";;

    RULE                 "Below Parker Hydrologic Demand Variability";
    DESCRIPTION          "DESCRIPTION: Allow the senior users in the Lower Basin to take additional water or decrease their demand based on the Below Parker Hydrologic Demand Variability.  If the local inflows below Parker are greater than the historic 90th percentile (wet) observed value, then decrease the diversion requests by 10%. If the local inflows are less than the 10th percentile (dry) observed value, then increase the diversion requests by 5%. <br><br>SLOTS SET: PaloVerde.Total Diversion Requested; CRIR:CRIRAz.Diversion Requested; AAC:IID.Diversion Requested; AAC:Coachella.Diversion Requested; GilaGravityMainCanal:WMIDD.Diversion Requested; GilaGravityMainCanal:YCWUA.Diversion Requested; GilaGravityMainCanal:YMIDD.Diversion Requested; LowerBasinDemandVariability.BlwParkerTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) AND "IsMRM"(  ) AND NOT "Is24MonthStudy"(  );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200701: Added run constraint to not run in 24 MS mode";
    BEGIN

      FOREACH (DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "PaloVerde.Total Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.PaloVerde" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" );

            $ "CRIR:CRIRAz.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.CRIRAz" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CRIRaz" );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.IID" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "IID" );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.Coachella" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CVWD" );

            $ "GilaGravityMainCanal:WMIDD.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.WMIDD" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "WMIDD" );

            $ "GilaGravityMainCanal:YCWUA.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.YCWUA" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "YCWUA" );

            $ "GilaGravityMainCanal:YMIDD.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.YMIDD" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "YMIDD" );

            $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := IF ( "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" ) == 1.00000000 )
 THEN
  0.00000000
 ELSE
  IF ( "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" ) == 0.90000000 )
  THEN
   1.00000000
  ELSE
   - 1.00000000
  ENDIF
 ENDIF;

      ENDFOREACH;

    END
    UUID "{4a2b56f7-5971-4b70-9d9b-c299bd8286dc}";;

    RULE                 "Set Schedules Volume to Flow";
    DESCRIPTION          "DESCRIPTION: For Each user in California, Arizona and Nevada, set the Reach Simulation Diversion request as this will allow the simulation of the Basin for the RiverWare model.  Setting these diversion requests so early in the ruleset allows for this initial setting of Lower Basin Demands that will ultimately sum to be the outflow from Lake Mead.  This step and the following rules will allow for the MTOM model to simulate in a somewhat realistic way and help in the Lake Powell Tier determination that occurs later in the policy. This rule sets the monthly diversion requests for lower basin diversion for each timestep in the run period. - CE 9/17/13<br><br>SLOTS SET:<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200701: 2 extra rule assignments not in 24 MS ruleset. Extra assignments were the TJ Depletion and MWD Return flow.";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December 31, Finish Year") DO
            $ "PaloVerde.Total Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.PaloVerde" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.PaloVerde" [date], date )
 ENDIF;

            $ "CAPDiversion.Total Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CAP" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date )
 ENDIF;

            $ "CAPDiversion.Total Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CAP" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date )
 ENDIF;

            $ "CRIR:CRIRAz.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CRIRAz" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CRIRAz" [date], date )
 ENDIF;

            $ "CRIR:CRIRCa.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.CRIRCa" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.CRIRCa" [date], date )
 ENDIF;

            $ "CaPkrToImp:Winterhaven.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Winterhaven" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Winterhaven" [date], date )
 ENDIF;

            $ "CaPkrToImp:CaPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.CaPumpersAbvImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.CaPumpersAbvImp" [date], date )
 ENDIF;

            $ "AzPkrToImp:AzPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersAbvImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersAbvImp" [date], date )
 ENDIF;

            $ "AzPkrToImp:BlmPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BlmPumpersAbvImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BlmPumpersAbvImp" [date], date )
 ENDIF;

            $ "AzPkrToImp:BrookeWater.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BrookeWater" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BrookeWater" [date], date )
 ENDIF;

            $ "AzPkrToImp:CibolaNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CibolaNWR" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CibolaNWR" [date], date )
 ENDIF;

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CibolaValleyIID" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CibolaValleyIID" [date], date )
 ENDIF;

            $ "AzPkrToImp:Ehrenberg.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Ehrenberg" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Ehrenberg" [date], date )
 ENDIF;

            $ "AzPkrToImp:ImperialNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.ImperialNWR" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.ImperialNWR" [date], date )
 ENDIF;

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.City of Parker" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.City of Parker" [date], date )
 ENDIF;

            $ "AAC:SaltonSea.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.SaltonSea" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.SaltonSea" [date], date )
 ENDIF;

            $ "AAC:IID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.IID" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.IID" [date], date )
 ENDIF;

            $ "AAC:Coachella.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Coachella" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Coachella" [date], date )
 ENDIF;

            $ "AAC:YumaProject.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.YumaProject" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.YumaProject" [date], date )
 ENDIF;

            $ "AAC:Ranch5.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Ranch5" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Ranch5" [date], date )
 ENDIF;

            $ "GilaAndYumaUsers:CocopahIndRes.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Cocopah Indian Res" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Cocopah Indian Res" [date], date )
 ENDIF;

            $ "GilaAndYumaUsers:DesertLawnMemorial.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.DesertLawnMemorial" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.DesertLawnMemorial" [date], date )
 ENDIF;

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Gila Monster Farms" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Gila Monster Farms" [date], date )
 ENDIF;

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersBlwImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersBlwImp" [date], date )
 ENDIF;

            $ "OthersBlwImp:BlmPumpersBlwImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BlmPumpersBlwImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BlmPumpersBlwImp" [date], date )
 ENDIF;

            $ "OthersBlwImp:SouthernPacific.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.SouthernPacific" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.SouthernPacific" [date], date )
 ENDIF;

            $ "OthersBlwImp:YAO.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YAO" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YAO" [date], date )
 ENDIF;

            $ "OthersBlwImp:YumaIsland.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.YumaIsland" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.YumaIsland" [date], date )
 ENDIF;

            $ "OthersBlwImp:Ft Yuma.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Ft Yuma" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Ft Yuma" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:CityOfYuma.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.City of Yuma" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.City of Yuma" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:MCAirStation.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.MCAirStation" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.MCAirStation" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:NGVIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.NGVIDD" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.NGVIDD" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:UnitB.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.UnitB" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.UnitB" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:UofA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.UofA" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.UofA" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:WMIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.WMIDD" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.WMIDD" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YCWUA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YCWUA" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YCWUA" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YID" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YID" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YMIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YMIDD" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YMIDD" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YumaProvingGround.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YumaProvingGround" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YumaProvingGround" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YumaUnionHighScl.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YumaUnionHighScl" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YumaUnionHighScl" [date], date )
 ENDIF;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.MWDDiversion" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.MWDDiversion" [date], date )
 ENDIF;

            $ "MWDDiversion:MWD.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.MWD" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.MWD" [date], date )
 ENDIF;

            $ "MWDDiversion:Tijuana.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoTJ" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoTJ" [date], date )
 ENDIF;

            $ "MWDDiversion:Tijuana.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoTJ" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoTJ" [date], date )
 ENDIF;

            $ "MWDDiversion.Total Return Flow" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.MWDReturns" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date )
 ENDIF;

            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoSched" [date] - $ "Mexico_CU_Actual.MexicoTJ" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date], date )
 ENDIF;

            $ "MexicanTreatyDelivery:MexicoBypass.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoBypass" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoBypass" [date], date )
 ENDIF;

            $ "MexicanTreatyDelivery:MexicoExcess.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoExcess" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoExcess" [date], date )
 ENDIF;

            $ "FtMohaveIndRes:NV.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.FtMohaveNv" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.FtMohaveNv" [date], date )
 ENDIF;

            $ "FtMohaveIndRes:CA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.FtMohaveCa" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.FtMohaveCa" [date], date )
 ENDIF;

            $ "FtMohaveIndRes:AZ.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.FtMohaveAz" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.FtMohaveAz" [date], date )
 ENDIF;

            $ "NvDvsToPkr:SCE.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.SCE" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.SCE" [date], date )
 ENDIF;

            $ "NvDvsToPkr:BigBend.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.BigBend" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.BigBend" [date], date )
 ENDIF;

            $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.LMNRA Mohave" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.LMNRA Mohave" [date], date )
 ENDIF;

            $ "AzDvsToPkr:BullheadCity.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BullheadCity" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BullheadCity" [date], date )
 ENDIF;

            $ "CaDvsToPkr:Chemehuevi.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Chemehuevi" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Chemehuevi" [date], date )
 ENDIF;

            $ "CaDvsToPkr:Needles.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Needles" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Needles" [date], date )
 ENDIF;

            $ "CaDvsToPkr:OtherLCWSP.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.OtherLCWSP" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.OtherLCWSP" [date], date )
 ENDIF;

            $ "OthersMeadToMohave:DavisDamProject.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.DavisDamProject" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.DavisDamProject" [date], date )
 ENDIF;

            $ "AzDvsToPkr:GoldenShores.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.GoldenShores" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.GoldenShores" [date], date )
 ENDIF;

            $ "AzDvsToPkr:HavasuNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.HavasuNWR" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.HavasuNWR" [date], date )
 ENDIF;

            $ "AzDvsToPkr:LakeHavasuCity.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LakeHavasuCity" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LakeHavasuCity" [date], date )
 ENDIF;

            $ "AzDvsToPkr:MohaveValleyIID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.MohaveValleyIID" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.MohaveValleyIID" [date], date )
 ENDIF;

            $ "AzDvsToPkr:MohaveWaterConsDist.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.MohaveWaterConsDist" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.MohaveWaterConsDist" [date], date )
 ENDIF;

            $ "AzDvsToPkr:AzPumpersDvsToPkr.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersDvsToPkr" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersDvsToPkr" [date], date )
 ENDIF;

            $ "PumpingFromLakeMead:LMNRA Az Mead.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mead" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mead" [date], date )
 ENDIF;

            $ "PumpingFromLakeMead:LMNRA Az Mead.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mead" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mead" [date], date )
 ENDIF;

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.SNWP" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.SNWP" [date], date )
 ENDIF;

            $ "PumpingFromLakeMead:SNWP.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.SNWP" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.SNWP" [date], date )
 ENDIF;

            $ "OthersMeadToMohave:LMNRA Az Mohave.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mohave" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mohave" [date], date )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{4dd9099d-3e6d-4111-a897-474da814c0ed}";;

    RULE                 "Set LC Actuals";
    DESCRIPTION          "DESCRIPTION: This rule sets the historical flows for California MWD and Nevada SNWP for January of the start year to the month before the start timestep. - CE, 9/17/13<br><br>SLOTS SET: California_CU_Actual.MWD; Nevada_CU_Actual.SNWP<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200630: This rule was not changed in the integration process. This rule substitues from Set SNWP/MWD Actual rules in the 24 MS ruleset";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
          DESCRIPTION          "Set the MWD Consumptive Use actual values based on the input MWDDiversion actual values and <br>the Actual MWD Return input values. <br><br>This assginment covers the &quot;Set MWD CU Actual&quot; rule from the 24 MS ruleset<br>";
      $ "California_CU_Actual.MWD" [date] := IF ( IsNaN $ "California_CU_Actual.MWD" [date] AND NOT IsNaN $ "California_CU_Actual.MWDDiversion" [date] )
 THEN
  $ "California_CU_Actual.MWDDiversion" [date] - $ "California_CU_Actual.MWDReturns" [date]
 ENDIF;

          DESCRIPTION          "Set the SNWP Actuals to the Actual input party values for SNWP<br><br>This assignment covers the &quot;Set SNWP Actual Depletion&quot; rule in the 24 MS <br>";
      $ "Nevada_CU_Actual.SNWP" [date] := IF ( IsNaN $ "Nevada_CU_Actual.SNWP" [date] )
 THEN
  $ "Nevada_CU_Actual.SNWADiversion" [date] + $ "Nevada_CU_Actual.BasicManagement" [date] + $ "Nevada_CU_Actual.LMNRA Mead" [date] + $ "Nevada_CU_Actual.BoulderCanyonProject" [date] + $ "Nevada_CU_Actual.NvDeptFishGame" [date] + $ "Nevada_CU_Actual.PacificCoastBuilding" [date] + $ "Nevada_CU_Actual.City of Henderson" [date] - $ "Nevada_CU_Actual.LVWashReturns" [date]
 ENDIF;

      ENDFOREACH;

    END
    UUID "{581b1aba-ee47-4881-8442-d91bc7410d1d}";;

    RULE                 "Set Actuals to Zero In Future";
    DESCRIPTION          "DESCRIPTION: This rule sets the actual water use to zero over the run period for the each user in the lower basin. This rule fires at the start timestep of the first runcycle. -CE 9/17/13<br><br>SLOTS SET: <state>_CU_Actual.<user><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Actual" ) )) DO
            "GetObject"( state CONCAT "_CU_Actual" ) & user [date] := 0.00000000 "acre-ft";

      ENDFOREACH;

      ENDFOREACH;

      ENDFOREACH;

    END
    UUID "{3f121043-d655-4942-b140-865ea1fbb2a9}";;

    RULE                 "Set NaN Actuals To Schedule";
    DESCRIPTION          "DESCRIPTION: This rule sets the Acutal schedules for each state to the Consumptive use schedule if the Actual schedule was not input to the MTOM Model. This step is done to prevent any model failure if data does not exist due to that data not being entered or imported into the MTOM model. This rule fires only on the start timestep of the first run cycle<br><br>SLOTS SET: <state>_CU_Actual.<user><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200630: No changes done to this rule in the integration effort";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
            FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" , "Mexico" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Actual" ) )) DO
            "GetObject"( state CONCAT "_CU_Actual" ) & user [date] := IF ( user != "SNWP" )
 THEN
  IF ( IsNaN "GetObject"( state CONCAT "_CU_Actual" ) & user [date] )
  THEN
   "GetObject"( state CONCAT "_CU_Schedules" ) & user [date]
  ENDIF
 ENDIF;

      ENDFOREACH;

      ENDFOREACH;

      ENDFOREACH;

    END
    UUID "{1f5051b8-0547-4455-9dea-c362fee8881d}";;

    RULE                 "Set LC Annual Schedules";
    DESCRIPTION          "DESCRIPTION: This rule calculates the annual consumptive use (CU) schedules for Nevada and California. This rule fires for all run cycles. -CE 9/17/13<br><br>SLOTS SET: Nevada_CU_AnnualApproval.SNWP; California_CU_AnnualApproval.MWDReturns; California_CU_AnnualApproval.MWD<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND ( @"t" == @"Start Timestep" OR "IsJANofOutyear"(  ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200630: Addded if statement for AnnualApprovalMWD Returns slot assignment<br>APivarnik, 20200730: Deleted slot assignment for MWD returns. Adjusted execution constriant to only fire in start timestep in RC 1";
    BEGIN

    DESCRIPTION          "Thist rule sets the data slots for Annual Consumptive Use Approval for SNWP and MWD<br><br>The Nevada Annual Approval slot assignment covers the &quot;Set SNWP CU Schedule - annual&quot; rule <br>from the 24 MS <br>";
      $ "Nevada_CU_AnnualApproval.SNWP" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "Nevada_CU_Schedules.SNWP" );

    DESCRIPTION          "This slot assignment covers the &quot;Set MWD CU Schedule - annual&quot; rule in the 24 MS Ruleset<br>";
      $ "California_CU_AnnualApproval.MWD" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "California_CU_Schedules.MWD" );

    END
    UUID "{e46bc22b-0366-4b38-9701-e0f53fd53a09}";;

    RULE                 "Set LC Monthly Schedules";
    DESCRIPTION          "DESCRIPTION: This rule sets the consumptive use schedules for Nevada and California. -CE 9/17/13. Set the SNWP and MWD schedules based on the input consumptive use schedules for the various entities listed.  For SNWP this includes all groups with schedules for which the SNWP diversion delivers water.  For MWD, the return flow schedule is assumed to be constant at 8.5 acre-feet per day.  The MWDDiversion slot is input and so the returns schedule and the MWD (consumptive use portion) is set by this rule. <br><br>SLOTS SET: Nevada_CU_Schedules.SNWP; California_CU_Schedules.MWDReturns; California_CU_Schedules.MWD<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>GCAA, 20181030: Removed statement solving for California_CU_Schedules.MWDReturns and removed the part of the statement solving for MWDReturns from the California_CU_Schedules.MWD calculation.<br><br>APivarnik, 20200630: No changes to this rule in the integration effort<br>APivarnik, 20200730: Changed run constraint to RC = 1";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO "Dec31ofYear"( @"Finish Timestep" ) COMMENTED_BY "This is for testing purposes, this should be Finish timestep<br>when the model is actually moved forward and all input<br>is taken care of") DO
          DESCRIPTION          "This slot assignment covers the &quot;Set SNWP CU schedule - monthly&quot; rule in the 24 MS  <br>";
      $ "Nevada_CU_Schedules.SNWP" [date] := $ "Nevada_CU_Schedules.SNWADiversion" [date] + $ "Nevada_CU_Schedules.BasicManagement" [date] + $ "Nevada_CU_Schedules.LMNRA Mead" [date] + $ "Nevada_CU_Schedules.BoulderCanyonProject" [date] + $ "Nevada_CU_Schedules.NvDeptFishGame" [date] + $ "Nevada_CU_Schedules.PacificCoastBuilding" [date] + $ "Nevada_CU_Schedules.City of Henderson" [date] - $ "Nevada_CU_Schedules.LVWashReturns" [date];

          DESCRIPTION          "This slot assignment covers the &quot;Set MWD CU schedule - monthly&quot; rule in the 24 MS   <br>";
      $ "California_CU_Schedules.MWD" [date] := $ "California_CU_Schedules.MWDDiversion" [date] - $ "California_CU_Schedules.MWDReturns" [date];

      ENDFOREACH;

    END
    UUID "{1432441c-7bab-4e5b-8630-93f0d9be2401}";;

  END
  UUID "{e86929fe-c622-4b77-8e9b-20396a580527}";;

  POLICY_GROUP   "Data Setup";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Forbeared Return Flow";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "APivarnik 20200630: No change made to rule in integration effort";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"Finish Timestep") DO
            $ "BelowImperialDam:Forbeared Return Flow Credits.Local Inflow" [date] := IF ( date <= @"24:00:00 September Max DayOfMonth, 2020" )
 THEN
  0.00000000 "acre-ft/month"
 ELSE
  "VolumeToFlow"( $ "ForecastUse.ForbearedReturnFlow" ["Dec31ofYear"( date )] / 12.00000000, date )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{fd225bc0-304b-4b5c-95ea-ed4e9ebc0f02}";;

    RULE                 "Compute Upper Basin Gains";
    DESCRIPTION          "DESCRIPTION: This rule calculates the local gains for each reservoir and local inflow in the upper basin from the relevent RFC forecasts. - CE 9/17/13 Assign each one of the reach simulation Local Inlow slots in the Upper basin based on the input <br>CBRFC forecast values that are input to the model on data objects.  The CBRFC forecasts for the headwater reservoirs (Taylor Park, Fontenelle and Vallecito) are input directly to the simulation reservoir object.  For the reach objects, consideration needs to be made to any upstream forecasts and the appropriate intervening flow for the reach needs to be determined.  This rule makes that calculation.<br><br>SLOTS SET: ColoradoAbovePowell:InterveningAbovePowell.Local Inflow; UpperSanJuan.Inflow; GreenBelowFlamingGorge:YampaRiver.Local Inflow; SanJuanBelowNavajo:AnimasRiver.Local Inflow; GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow; GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow; GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow; GunnisonAboveBlueMesa:InterveningAboveBlueMesa.Local Inflow; Azotea Tunnel.Fractional Return Flow; GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow; GReenAboveFlamingGorge.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200630: Added If statement for 24 MS assignments vs MTOM assignments<br>APivarnik, 20201001: Changed rule per discussion with UC for integration effort. Got rid of if statement for 24MS/MTOM assignments and just used MTOM logic for both models";
    BEGIN

      FOREACH (DATETIME index IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "ColoradoAbovePowell:InterveningAbovePowell.Local Inflow" [index] := $ "PowellInflow.Unregulated" [index] + ( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [index] + $ "Azotea Tunnel.Diversion Requested" [index] + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [index] ) - ( ( $ "CrystalInflow.Unregulated" [index] + $ "FlamingGorgeInflow.Unregulated" [index] + $ "NavajoInflow.ModUnregulated" [index] + NaNToZero ( $ "GainsCrystalToGJ.GainsCrystalToGJ" [index] ) + NaNToZero ( $ "AnimasRiverInflow.Animas_at_Durango" [index] ) ) + NaNToZero ( $ "YampaRiverInflow.Yampa_at_Deerlodge" [index] ) );

            $ "UpperSanJuan.Inflow" [index] := $ "NavajoInflow.ModUnregulated" [index] - $ "Vallecito.Inflow" [index];

            $ "GreenBelowFlamingGorge:YampaRiver.Local Inflow" [index] := NaNToZero ( $ "YampaRiverInflow.Yampa_at_Deerlodge" [index] );

            $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" [index] := NaNToZero ( $ "AnimasRiverInflow.Animas_at_Durango" [index] );

            $ "GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow" [index] := NaNToZero ( $ "GainsCrystalToGJ.GainsCrystalToGJ" [index] );

            $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [index] := $ "MorrowPointInflow.Unregulated" [index] - $ "BlueMesaInflow.Unregulated" [index];

            $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [index] := $ "CrystalInflow.Unregulated" [index] - $ "MorrowPointInflow.Unregulated" [index];

            $ "GunnisonAboveBlueMesa:InterveningAboveBlueMesa.Local Inflow" [index] := $ "BlueMesaInflow.Unregulated" [index] - $ "TaylorPark.Inflow" [index];

          DESCRIPTION          "This assignment is necessary for RW 6.6. Per instruction from BoR this value is set to 0 for all <br>timesteps. LJ 03/19/2015.";
      $ "Azotea Tunnel.Fractional Return Flow" [index] := 0.00000000;

      ENDFOREACH;

    DESCRIPTION          "Move non-headwater reservoir inflow forecasts into reaches above reservoirs (FG, BM, MP, CR, <br>NV) to get intervening gains for those reservoirs <br>";
      FOREACH (DATETIME index IN "OffsetDate"( "RunStartDate"(  ), - 12.00000000, "1 months" ) TO "OffsetDate"( "RunEndDate"(  ), 12.00000000, "1 months" )) DO
            $ "GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow" [index] := $ "FlamingGorgeInflow.Unregulated" [index] - $ "Fontenelle.Inflow" [index];

      ENDFOREACH;

      FOREACH (DATETIME index IN "OffsetDate"( "RunStartDate"(  ), - 12.00000000, "1 months" ) TO "OffsetDate"( "RunStartDate"(  ), - 1.00000000, "1 months" )) DO
            $ "GreenAboveFlamingGorge.Outflow" [index] := $ "FlamingGorgeInflow.Unregulated" [index] - $ "Fontenelle.Inflow" [index] + $ "Fontenelle.Outflow" [index];

      ENDFOREACH;

    END
    UUID "{001f202f-f095-4afe-b9f2-c277efc600ec}";;

    RULE                 "SetCaliforniaPreliminaryStateAdjustedApportionment";
    DESCRIPTION          "DESCRIPTION: For any out year, the California State Apportionment needs to be adjusted based on the estimated Payback and estimated EC ICS Creation for IID that is input to the model. This preliminary adjustment to the CA State Apportionment allows for a calculation of MWD Diversion that takes the estimated parameters into consideration. This is a more realistic calculation than using the standard CA State Apportionment. The payback and ICS Creation can be adjusted in later logic and the MWD can be adjusted again.<br><br>SLOTS SET: AnnualWaterUse.California_PreliminaryAdjustedApportionment[Current Year]";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January 31, Current Year" ) AND ( ( "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" ) ) OR ( ( "GetRunCycleIndex"(  ) == 3.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND "IsLBorDCPconditionChanged"(  ) ) ) ) ) AND NOT "Is24MonthStudy"(  );
    NOTES                "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br><br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 AND Shortage is in effect and the alternate calculation in the rule if that is the case.  In the case of shortage, EC ICS Creation is not allowed and the value (Input to the model) is not used in the calculation of apportionment.  Subsequent rules (Reset MWD Annual Forecast Use - Force to CA Apportionment, Reset Monthly Forecast Use MWD - All Months Outyears, Reset Monthly Forecast Use MWD - Nov and Dec, Cur Year, and Redistribute MWD Nov & Dec Div Request) that depend on the value calculated in this rule were also modified to allow execution in Run Cycle 3 if Shortage is in effect.<br><br>APivarnik, 20200511: Added run constraint to get rule to fire in RC4 if LB conidtion changes (fixes difference in overrun calc by IID ICS amount)<br><br>APivarnik, 20200630: Added Not IS24MonthStudy to execution constraint to prevent the rule from firing in 24 MS mode";
    BEGIN

      $ "AnnualWaterUse.California_PreliminaryAdjustedApportionment" ["Dec31ofYear"( @"t" )] := IF ( "IsMRM"(  ) )
 THEN
  IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" )
  THEN
   $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
  ELSE
   IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
   THEN
    $ "AnnualWaterUse.CA_BasicApportionment" [] - $ "ICSProjectionData.California_EstimatedPayback" ["Dec31ofYear"( @"t" )] - $ "ICSProjectionData.CA_SystemConservation" ["Dec31ofYear"( @"t" )]
   ELSE
    $ "AnnualWaterUse.CA_BasicApportionment" [] - $ "ICSProjectionData.California_EstimatedPayback" ["Dec31ofYear"( @"t" )] - ( $ "ICSProjectionData.AnnualCreationEC_IID_Default" ["Dec31ofYear"( @"t" )] - $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" ["Dec31ofYear"( @"t" )] ) - $ "ICSProjectionData.CA_SystemConservation" ["Dec31ofYear"( @"t" )]
   ENDIF
  ENDIF
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF;

    END
    UUID "{9d7435c8-fc52-4f9d-bfd6-a5933c24f626}";;

    RULE                 "INPUT MISSING NOTIFICATION";
    DESCRIPTION          "DESCRIPTION: This rule checks if the necessary RFC inflow information has been entered. This includes inflow information for all upper basin reserviors. -CE 9/17/13<br><br>SLOTS SET: <br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE, 9/17/13 <br><br>APivarnik, 20201006: Per UC instruction, removed Is24MS if conditional on setting NIIP slot";
    BEGIN

    DESCRIPTION          "This rule executes if there is missing input data and if this rule. If this rule does execute and <br>give an error, make sure the input data sheet is set up correctly (CBRFC_EnsembleForecast) <br>and that the run period is correct for the current model run.  ";
      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "BlueMesaInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: BlueMesaInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "TaylorPark.Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: TaylorPark.Inflow Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "MorrowPointInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: MorrowPointInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "CrystalInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: CrystalInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "FlamingGorgeInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: FlamingGorgeInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Fontenelle.Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: Fontenelle.Inflow Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "NavajoInflow.ModUnregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: NavajoInflow.ModUnregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Vallecito.Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: Vallecito.Inflow Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "PowellInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: PowellInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: NavajoIndianIrrigationProjectNIIP.Diversion Requested Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Azotea Tunnel.Diversion Requested" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: AzoteaTunnel.Diversion Requested Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: TunnelDiversionBelowCrystalForAg.Diversion Requested Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: SanJuanBelowNavajo:AnimasRiver.Local Inflow Missing"
 ENDIF;

    END
    UUID "{cebce44c-342d-4896-a053-e159c76e91f6}";;

    RULE                 "Set Extended Forecasts to Historic Average Hydrology";
    DESCRIPTION          "DESCRIPTION: This rule sets the inflow above Fontenelle and the unregulated inflow to Flaming Gorge for the 12 months beyond the run end date. Note that the rule actually will set all unpopulated (NaN) timesteps from the run start to 12 months after the finish with historic average values. However, the DMI Excel_InputFrom24MS populates the run period values as Inputs. The DMI is set to import values until Finish Timestep + 12 timesteps, but only those values until the end of the run are currently provided by the spreadsheet.<br><br>SLOTS SET: Fontenelle.Inflow; FlamingGorgeInflow.Unregulated";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>SC, 20111201: This rule set the inflows above Fontenelle, the unregulated inflow to Flaming Gorge, and the Yampa River Inflow for the 12 months beyond the run end date.  These values are needed by the operations rules for Flaming Gorge and Fontenelle as written by CADSWES.  Would be nice to review these rules and see if this is absolutely necessary. - sc 12/1/11<br><br>MC, 20160913: The comment in the body suggests the forecasts will be extended beyond the Finish Timestep by historic values, but actually all timesteps are being set with those values. Are the values being used?<br><br>APivarnik, 20200630: Added Not IS24MonthStudy to execution constraint to prevent the rule from firing in 24 MS mode<br><br>APivarnik, 20201006: Removed Not Is24MS execution constraint. After some changes were made in the Compute Upper Basin rule, this rule needed to fire in 24 MS mode. If this did not execute, the Compute Upper Basin Gains would fail. Changed For statement timeframe to only fill slots post finish timestep. This way the model will fail if the input is incorrect.";
    BEGIN

    DESCRIPTION          "This rule will extend the forecasts for the locations specified beyond the RFC forecast period.  <br>The values in the extended forecast are set to historic input values for the specific location.  <br>";
      FOREACH (DATETIME index IN @"Finish Timestep + 1" TO @"Finish Timestep + 12") DO
            $ "Fontenelle.Inflow" [index] := IF ( IsNaN $ "Fontenelle.Inflow" [index] )
 THEN
  $ "HistoricData.HistoricAverageMonthlyInflows" [index, "FontenelleMonthlyAveInflow"]
 ENDIF;

            $ "FlamingGorgeInflow.Unregulated" [index] := IF ( IsNaN $ "FlamingGorgeInflow.Unregulated" [index] )
 THEN
  $ "HistoricData.HistoricAverageMonthlyInflows" [index, "FlamingGorgeMonthlyAveUnregInflow"]
 ENDIF;

      ENDFOREACH;

    END
    UUID "{6c55642c-b4a5-452d-be93-1e20bfa2c106}";;

    RULE                 "Run Cycle Counter Print Message";
    DESCRIPTION          "DESCRIPTION: This rule records the run cycle in the diagnostic output window for debugging purposes. -CE 9/17/13<br><br>SLOTS SET: <NONE><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE, 9/17/13<br><br>APivarnik, 20200630: Since the 24 MS will now solve with run cycles, the rule is kept on in 24 MS and MTOM mode";
    BEGIN

      PRINT "******************************************************";

      PRINT "Begin Run Cycle # " CONCAT "GetRunCycleIndex"(  );

      PRINT "******************************************************";

    END
    UUID "{7755fda4-4ed6-406a-84f3-eaefeea61c6c}";;

    RULE                 "Set LB Demand Variability Triggers Below Parker";
    DESCRIPTION          "DESCRIPTION:  This rule fires on the start timestep and sets the trigger values for each timestep of the entire run.  Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request based on side inflow hydrology between certain locations.  The below Parker variability takes into considerations the side inflows below Parker Dam and sets a slot value (trigger) that will be used when compared to a historic statistically derived volume to determine the variability thresholds. This rule only sets the volumes and those will be used in subsequent rules when compared to historic threshold inflow values. <br><br>SLOTS SET: LowerBasinDemandVariability.LocalInflowBelowParkerTrigger";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" ) ) AND NOT "Is24MonthStudy"(  );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200630: Added Not IS24MonthStudy to execution constraint to prevent the rule from firing in 24 MS mode";
    BEGIN

    DESCRIPTION          "Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request based on side inflow hydrology between certain locations.  The <br>below Parker variability takes into considerations the side inflows below Parker Dam and sets a slot value (trigger) that will be used when compared to a historic statistically derived <br>volume to determine the variability thresholds. This rule only sets the volumes and those will be used in subsequent rules when compared to historic threshold inflow values. ";
      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (date == @"Start Timestep" OR "GetMonth"( date ) == 9.00000000 AND "OffsetDate"( date, 4.00000000, "1 Months" ) <= @"Finish Timestep") THEN
            IF_STATEMENT (date == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( date ) < 10.00000000) THEN
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVolYr2 = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowBelowParkerVolYr2;

      END_WITH_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END
    UUID "{87d31299-5bb7-4e8c-8067-4285400d2ee4}";;

    RULE                 "Set LB Demand Variability Triggers Above Hoover";
    DESCRIPTION          "DESCRIPTION: This rule fires on the start timestep and sets the trigger values for each timestep of the entire run.  Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request based on side inflow hydrology between certain locations.  <br>The above Mead variability takes into considerations the side inflows below Glen Canyon Dam and above Hoover Dam and sets a slot value (trigger) that will be used when compared to a historic statistically-derived volume to determine the variability thresholds. <br>This rule only determines the side inflow volume that will be used later for the comparison.<br><br>SLOTS SET: LowerBasinDemandVariability.LocalInflowAboveHooverTrigger; LowerBasinDemandVariability.PowellUnregulatedInflowTrigger";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" ) ) AND NOT "Is24MonthStudy"(  );
    NOTES                "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br><br>APivarnik, 20200630: Added Not IS24MonthStudy to execution constraint to prevent the rule from firing in 24 MS mode<br>";
    BEGIN

    DESCRIPTION          "Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request <br>based on side inflow hydrology between certain locations.  <br>The above Mead variability takes into considerations the side inflows below Glen Canyon Dam and above Hoover Dam <br>and sets a slot value (trigger) that will be used when compared to a historic statistically-derived volume to determine the <br>variability thresholds. <br>This rule only determines the side inflow volume that will be used later for the comparison.";
      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (( date == @"Start Timestep" OR "GetMonth"( date ) == 9.00000000 AND "OffsetDate"( date, 4.00000000, "1 Months" ) <= @"Finish Timestep" ) COMMENTED_BY "Note that the following expression evaluates as &quot;(A OR B) AND C&quot;, not as &quot;A OR (B AND C)&quot; - mc, <br>1/4/2016") THEN
            IF_STATEMENT (date == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( date ) < 10.00000000) THEN
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVolYr2 = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowAboveHooverVolYr2;

      END_WITH_STATEMENT;

          INACTIVE      WITH_STATEMENT (NUMERIC unregInflowPowellYr2 = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", @"24:00:00 October 31, Current Year", "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 2.00000000 ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := unregInflowPowellYr2;

      END_WITH_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVolYr2 = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowAboveHooverVolYr2;

      END_WITH_STATEMENT;

          INACTIVE      WITH_STATEMENT (NUMERIC unregInflowPowellYr2 = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", @"24:00:00 October 31, Current Year", "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )] := unregInflowPowellYr2;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

          INACTIVE      WITH_STATEMENT (NUMERIC waterYearNumber = "GetYear"( date ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF) DO
            WITH_STATEMENT (NUMERIC unregInflowPowell = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", "OffsetDate"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ), - 11.00000000, "1 Months" ), "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )] := unregInflowPowell;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END
    UUID "{9e206a82-d12b-4bd7-871f-9f0c14690a02}";;

  END
  UUID "{3e572fc2-ad4a-4512-8973-914bf72e2fef}";;

  UTILITY_GROUP "24 Month General Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AcreFeetPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170504: Disabled this function because there are no calls to it in the current rule set<br>AP, 20200629: Enabled during the 24 MS/MTOM Integration Effort";
    BEGIN

      value;

    END
    UUID "{04888093-06e6-439b-91c8-6193df7d88c3}";;

    FUNCTION       "SlotToString" ( OBJECT obj )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function retrieves a list of slots from a data object by using the GetSeriesSlots predefined function and then converts the list of slots into a list of strings of the slot names.<br><br>RETURNS: List of strings<br><br>ARGUMENTS:<br>1. OBJECT obj - object for which the slot names are desired<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      MAPLIST ( SLOT slotname IN "GetSeriesSlots"( obj ) ) DO
  "GetSlotName"( slotname )
 ENDMAPLIST;

    END
    UUID "{a2809567-4d10-4e4c-a3ef-af5781592197}";;

    FUNCTION       "AcreFeetPerMonthPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet/month]";
    DESCRIPTION    "<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170504: This function is only used in DebuggingRule, which I turned off, so I turned this function off also<br>AP, 20200629: Enabled during the 24 MS/MTOM Integration Effort";
    BEGIN

      value;

    END
    UUID "{8c438d77-4b00-4aab-9d1a-e4a7fa048f75}";;

    FUNCTION       "CFSPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170504: No calls to this function so I turned it off<br>AP, 20200629: Enabled during the 24 MS/MTOM Integration Effort";
    BEGIN

      value;

    END
    UUID "{2c763fb3-e875-44b7-b86a-e01de03b3535}";;

    FUNCTION       "GetMonthlyDatelist" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: makes a monthly datelist from the startDate month to the endDate month.<br><br>RETURNS: List of form &lcub;Month&rcub; [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME startDate - beginning period for which to generate list<br>2. DATETIME endDate - ending of period for which to generate list<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170504: Calls to this function use current or next timestep and end of July in current year as startDate and endDate, so implicit assumption those arguments are end of month dates? I think all of the calls to the function use t or t+1 as startDate and July 31, Current Year as endDate, so okay now but not robust.";
    BEGIN

      IF ( startDate >= endDate )
 THEN
  { endDate }
 ELSE
  WHILE ( ( GET @INDEX 0.00000000 FROM dateList ) > startDate ) WITH LIST dateList = { endDate } DO
   INSERT ( GET @INDEX 0.00000000 FROM dateList ) - "GetDaysInMonth"( ( GET @INDEX 0.00000000 FROM dateList ) - 1.00000000 "day" ) INTO dateList
  ENDWHILE
 ENDIF;

    END
    UUID "{42fc95ad-a250-4249-8b02-a07fc6b15e47}";;

    FUNCTION       "SumGainsBelow" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170530: This function has no calls to it in the current ruleset, so I turned it off. Note this version differs from SumGainsBelowVolume and SumAllGainsBelowVolume because it only sums slots with Input values.<br>AP, 20200629: Enabled during the 24 MS/MTOM Integration Effort";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "INPUT", FALSE, @"t", @"t" );

    END
    UUID "{3e1304b7-a5ed-44cf-ada9-368fd3f74f6e}";;

    FUNCTION       "SumAllGainsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumObjectsAggregatedOverTime to calculate the sum of the local inflows downstream of the reservoir specified as an input argument between the dates specified as input arguments<br><br>RETURNS: Volume of local inflows (the TRUE option in the call to SumObjectsAggregatedOverTime converts FLOW to VOLUME) [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir object for which local inflow total is desired<br>2. DATETIME startDate - beginning date for sum<br>3. DATETIME endDate - end date for sum<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: This function is the same as the user-defined function SumGainsBelowVolume. I changed all calls to that function to call thist function and turned that one off.";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "ALL", TRUE, startDate, endDate );

    END
    UUID "{3e8873fd-0acb-4909-a3d3-6c5dfafe3cb7}";;

    FUNCTION       "SumDiversionsBelow" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "MC, 20170530: This function is the same as SumDiversionsBelowVolume except that this version does not convert the aggregated flow rates to Volume; there are no calls to this function in the current ruleset, so I turned it off.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "INPUT", FALSE, @"t", @"t" );

    END
    UUID "{55c70a47-88a5-4942-ba86-b63413e5af89}";;

    FUNCTION       "SumDiversionsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "MC, 20170530: This function is the same as SumAllDiversionsBelowVolume except this version aggregates only slots with Input values. There are no calls to this function in the current ruleset, so I turned it off.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "INPUT", TRUE, startDate, endDate );

    END
    UUID "{b700ec62-2366-4a95-b129-1f6b86889497}";;

    FUNCTION       "SumAllDiversionsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumObjectsAggregatedOverTime to calculate the sum of the diversion requests downstream of the reservoir specified as an input argument between the dates specified as input arguments<br><br>RETURNS: Volume of diversion requests (the TRUE option in the call to SumObjectsAggregatedOverTime converts FLOW to VOLUME) [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir object for which diversion total is desired<br>2. DATETIME startDate - beginning date for sum<br>3. DATETIME endDate - end date for sum<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "ALL", TRUE, startDate, endDate );

    END
    UUID "{122aa2a3-ad2d-46aa-92f8-b013124c3fda}";;

    FUNCTION       "SumSlotVolume" ( SLOT slot, LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: Given a slot (FLOW units) and a list of dates as arguments, returns the volume sum of the slot over the dates<br><br>RETURNS: Volume sum of slots flow values for dates specified [L^3]<br><br>ARGUMENTS:<br>1. SLOT slot - the slot whose values are to be summed<br>2. LIST dates - the dates to be included in the sum<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: Replace calls to this function with the predefined function SumFlowsToVolume?";
    BEGIN

      FOR ( DATETIME date IN dates ) WITH NUMERIC sum = 0.00000000 "acre-feet" DO
  sum + "FlowToVolume"( slot [date], date )
 ENDFOR;

    END
    UUID "{09067f31-7ebd-4161-8c13-bbd7cc81a2aa}";;

    FUNCTION       "Compute Head as a Function of Turbine Release" ( NUMERIC turbineRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the Mohave power head for the current timestep as the difference between the tailwater elevation, as calculated from the tailwater table using the turbineRelease argument, and the average pool elevation over the current timestep, calculated as the sum of the current pool elevation and the previous pool elevation divided by 2<br><br>RETURNS: Turbine head [L]<br><br>ARGUMENTS:<br>1. NUMERIC turbineRelease - dam release through the turbines<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      ( $ "Mohave.Pool Elevation" [] + $ "Mohave.Pool Elevation" [@"t - 1"] ) / 2.00000000 - "TableInterpolation"( $ "Mohave.Tailwater Table", 0.00000000, 1.00000000, turbineRelease, @"t" );

    END
    UUID "{ecc4d28e-9e95-44bc-8879-5115b3350168}";;

    FUNCTION       "Annual Volume" ( SLOT slot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumFlowsToVolume to calculate the sum of a given slot over the current calendar year<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. SLOT slot - the slot for which the annual volume is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Remove this function and simply call SumFlowsToVolume instead?";
    BEGIN

      "SumFlowsToVolume"( slot, @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" );

    END
    UUID "{6fc6c106-26b9-4cda-8ce9-53630fcf70e3}";;

    FUNCTION       "AnnualVolumeSlot" ( SLOT slot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculate the sum of a given slot over the current calendar year<br><br>RETURNS: Sum of slot values [Slot units]<br><br>ARGUMENTS:<br>1. SLOT slot - the slot to sum<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      "SumSlot"( slot, @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" );

    END
    UUID "{ef99f9d7-352c-4e3c-b0b3-3b95d52e63b4}";;

    FUNCTION       "SumSlotList" ( OBJECT obj )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This functions starts out with a data object. It gets a list of slots in the object by using the GetSeriesSlots predefined function. It then sums the values of all the slots in the object over the current timestep.<br><br>MC, 20170530: There are no calls to this function in the current ruleset, so I turned it off.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( SLOT slotname IN "GetSeriesSlots"( obj ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
  result + slotname []
 ENDFOR;

    END
    UUID "{b01d3868-6495-4b5c-a921-da3e0bc26308}";;

    FUNCTION       "SumSlotListDates" ( OBJECT obj, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This functions sums the values of all the slots on the object passed as an argument for the timestep passed as an argument<br><br>RETURNS: Sum of slot values [L^3]<br><br>ARGUMENTS:<br>1. OBJECT obj - object whose slots are to be summed<br>2. DATETIME date - date on which to calculate the slot sum<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( SLOT slotname IN "GetSeriesSlots"( obj ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
  result + slotname [date]
 ENDFOR;

    END
    UUID "{c7382fda-6200-4b42-a304-36458572752b}";;

    FUNCTION       "GetLastDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the last day of the year of the model run's last timestep, regardless of the date passed to the function.<br><br>RETURNS: Last day of the year for last year in run [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date that is irrelevant since the function returns the same value regardless of this date<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: This function returns the same value no matter what date is passed; replace it with the Dec31ofYear(@&quot;Finish Timestep&quot;) wherever it occurs";
    BEGIN

      IF ( "GetMonth"( date ) > 1.00000000 )
 THEN
  "Dec31ofYear"( @"Finish Timestep" )
 ELSE
  "Dec31ofYear"( @"Finish Timestep" )
 ENDIF;

    END
    UUID "{2b3cfbc7-6652-49fb-8520-a5dc0d0f335b}";;

    FUNCTION       "GetFirstDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is used in rules that set monthly values in outyears. If the start timestep is December, we want the rule to skip the 1st 2 timesteps and set values Feb - Dec (11 total), otherwise set values Jan-Dec (12 total). <br><br>RETURNS: Last date in January or February of the current year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date used to determine whether the returned date represents January or February<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( date == @"Start Timestep + 1" )
 THEN
  @"24:00:00 February Max DayOfMonth, Current Year"
 ELSE
  @"24:00:00 January Max DayOfMonth, Current Year"
 ENDIF;

    END
    UUID "{1f6d0c57-c47a-4cbf-8369-982c2e9d15f5}";;

    FUNCTION       "GetDaysBasedOnFirstDate" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is used in rules that set monthly values in outyears. If the start timestep is December, we want the rule to skip the 1st two timesteps and set values Feb - Dec (11 total), otherwise set values Jan-Dec (12 total). <br><br>RETURNS: the number of months to divide an annual volume into [NONE]<br><br>ARGUMENTS: <br>1. DATETIME date - date used to determine the number of months<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown <br>MC, 20170530: 1.) Replaced @&quot;t&quot; by date because both rules calling this function pass @&quot;t&quot; as date; 2.) Changed the original misleading name GetDaysBasedOnFirstDate to current name because the function is actually calculating a number of months, not days (reverted back for consistency with CRSS?)<br><br>ST, 20181231: updated logic to match 24 MS";
    BEGIN

      IF ( date == @"Start Timestep + 1" )
 THEN
  11.00000000
 ELSE
  12.00000000
 ENDIF;

    END
    UUID "{53ba7e28-21b0-4aeb-aa31-af8e6af1227d}";;

    FUNCTION       "Dec31ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the day of the year for December 31 making corrections for leap years if necessary. -CE 6/11/13<br><br>RETURNS: December 31 of the year of the date specified [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies the year for which Dec 31 is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170531: (Possible rewrite) CompletePartialDate(@&quot;December 31&quot;, date)";
    BEGIN

      IF ( "LeapYear"( date ) )
 THEN
  "OffsetDate"( date, "Units NONE"( 366.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ELSE
  "OffsetDate"( date, "Units NONE"( 365.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ENDIF;

    END
    UUID "{360542aa-f153-42db-9736-a6b91d6252c6}";;

    FUNCTION       "Units NONE" ( NUMERIC number )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Removes the &quot;day&quot; units from a value. - CE 6/11/13<br><br>RETURNS: Number without units [NONE]<br><br>ARGUMENTS:<br>1. NUMERIC number - a number with units of &quot;days&quot;<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      number / 1.00000000 "day";

    END
    UUID "{826d2d51-596a-4334-bd77-3791fc1dd03c}";;

    FUNCTION       "Delete - SumGainsBelowVolume " ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumObjectsAggregatedOverTime to calculate the sum of the local inflows downstream of the reservoir specified as an input argument between the dates specified as input arguments<br><br>RETURNS: Volume of local inflows (the TRUE option in the call to SumObjectsAggregatedOverTime converts FLOW to VOLUME)<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir object for which local inflow total is desired<br>2. DATETIME startDate - beginning date for sum<br>3. DATETIME endDate - end date for sum<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: This function is the same as SumAllGainsBelowVolume, so I changed all references to this function to call that function, and turned this function off.<br>";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "ALL", TRUE, startDate, endDate );

    END
    UUID "{3288054e-9a4f-4154-b39d-3468518bce05}";;

  END
  UUID "{94f89e7e-e6e0-4d92-912b-bfe7746f9da4}";;

  UTILITY_GROUP "Get Data Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetMaxRelease" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function returns the maxRelease value from the UBRuleCurveData data object for the reservoir specified<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the maximum release is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "maxRelease"];

    END
    UUID "{f0b88055-71d9-4985-9437-4af8398596e0}";;

    FUNCTION       "GetMinRelease" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function returns the minRelease value from the UBRuleCurveData data object for the reservoir specified<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the minimum release is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "minRelease"];

    END
    UUID "{c2700b83-a645-45a7-8f9f-8deb90aa66ce}";;

    FUNCTION       "GetMininumSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the Min Space value from the MeadFloodControlData data object for the reservoir specified<br><br>RETURNS: Volume [L^3]<br><br>CONSTRAINTS: <NONE><br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the minimum space is desired (originally only Mead value specified in data object)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "MeadFloodControlData.MinSpace" [STRINGIFY reservoir, "Min Space"];

    END
    UUID "{b0debd7d-2986-4a80-b133-43ffad45e802}";;

    FUNCTION       "GetMaxCreditableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the maximum creditable space from the MeadFloodControlData.CredSpace table for the specified upper basin reservoir. This represents the maximum space that can be credited to available flood control space in the system for that reservoir.<br><br>RETURNS: Volume [L^3]<br><br>CONSTRAINTS: <NONE><br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the creditable space is desired<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "MeadFloodControlData.CredSpace" ["Credit. Space", STRINGIFY reservoir];

    END
    UUID "{50c246c9-958c-4468-a8fd-38e19fa3cd78}";;

    FUNCTION       "GetInactiveCapacity" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the value from the inactiveCapacityStorage column of the slot UBRuleCurveData.ReservoirData for the reservoir specified<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the inactive capacity storage is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "inactiveCapacityStorage"];

    END
    UUID "{756d25b6-6e74-4e57-9ea7-e1f760dc96de}";;

    FUNCTION       "GetLiveCapacity" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the value from the liveCapacityStorage column of the slot UBRuleCurveData.ReservoirData for the reservoir specified<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the live capacity storage is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "liveCapacityStorage"];

    END
    UUID "{0286bad3-d3e6-44d6-9bd6-eb49a1778d9b}";;

    FUNCTION       "AvailableWaterInStorage" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: Simple computation of the total amount of water that is available to be released<br>taking the reservoir down to 0 storage<br><br>RETURNS: Flow <br><br>ARGUMENTS: <br>1. OBJECT res - the reservoir <br><br>CONSTRAINTS: 0 af/mo<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT 0.00000000 "acre-ft/month";
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      res & "Inflow" [] + "VolumeToFlow"( res & "Storage" [@"t - 1"] - $ "UBRuleCurveData.ReservoirData" [STRINGIFY res, "DeadCapacity"], @"t" ) - "VolumeToFlow"( "EstimateEvaporation"( res, res & "Storage" [@"t - 1"], $ "UBRuleCurveData.ReservoirData" [STRINGIFY res, "DeadCapacity"], @"t - 1", @"t" ), @"t" );

    END
    UUID "{2cae728e-9a2b-4143-89e6-71ab87aac763}";;

    FUNCTION       "GetTargetStorage" ( OBJECT reservoir, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the value from the slot for Target Storage on the LBRuleCurveData data object for the reservoir and date specified<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - reservoir for which Target Storage is desired<br>2. DATETIME date - date for which Target Storage is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "LBRuleCurveData." CONCAT ( STRINGIFY reservoir ) CONCAT " Target Storage" [date];

    END
    UUID "{4ca72cdc-3ac0-4ac9-b315-1af6ef9c664e}";;

    FUNCTION       "SystemSpace" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the space required in Mead for the current timestep from the MeadFloodControlData.Space slot<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "MeadFloodControlData.Space" [0.00000000, "GetMonthAsString"( @"t" )];

    END
    UUID "{2e3f8a92-94ba-4864-8946-3a3f94a0aab6}";;

    FUNCTION       "GetEndDayOfMonth" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the last day of the current month<br><br>RETURNS: Datetime<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: See Development Notes on function MaxDayOfMonth";
    BEGIN

      @"24:00:00 Current Month Max DayOfMonth, Current Year";

    END
    UUID "{f38c0a43-1ebd-456d-8f28-0ccb7be975d5}";;

    FUNCTION       "GetStartDayOfMonth" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates and returns the first day of the current month<br><br>RETURNS: First day of current month [Datetime]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: See Development Notes on function MinDayOfMonth";
    BEGIN

      @"24:00:00 Current Month Min DayOfMonth, Current Year";

    END
    UUID "{427680e6-70c3-4f12-b1c7-b3c91b0c0c0d}";;

    FUNCTION       "GetDiversionToDate" ( SLOT Slot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" == @"24:00:00 January Max DayOfMonth, Current Year" )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "SumSlot"( Slot, @"24:00:00 January 31, Current Year", @"t - 1" )
 ENDIF;

    END
    UUID "{434c0d7f-0df9-4245-8890-d580d5308bc8}";;

    FUNCTION       "GetDaysLeftInYear" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( ( "GetDayOfYear"( @"24:00:00 December Max DayOfMonth, Current Year" ) - "GetDayOfYear"( "OffsetDate"( @"t - 1", 1.00000000, "1 days" ) ) ) + 1.00000000 "day" );

    END
    UUID "{1b11b88b-53dd-49b0-a94b-3c159aad5644}";;

  END
  UUID "{951305b9-1f35-4e65-9fb4-65e4f7753e18}";;

  UTILITY_GROUP "Is Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "Is24MonthStudy" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( $ "MTOMRunType.RunType" [] == 3.00000000 )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{cb7e7b71-645a-46f0-a366-5f659099f91a}";;

    FUNCTION       "IsYearDemandVariabilityAndRunCycle4" ( DATETIME date )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This rule returns a Boolean value of TRUE if lower basin demand variability is active and the run is in Run Cycle 4 and a value of FALSE otherwise<br><br>RETURNS: Boolean [BOOLEAN]<br><br>ARGUMENTS:<br>1. DATETIME date - date which specifies the year in question<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20180125: Added LBDV.BlwParkerTriggerSet and ICS Credits.SacWYType conditions to function based on USBR changes to function";
    BEGIN

      IF ( "GetRunCycleIndex"(  ) == 4.00000000 AND ( ( NaNToZero ( $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == 1.00000000 OR NaNToZero ( $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == - 1.00000000 ) OR ( ( NaNToZero ( $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == 1.00000000 OR NaNToZero ( $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == - 1.00000000 ) OR $ "ICS Credits.SacWYType" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] != 3.00000000 ) ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{d3daf197-3d7e-4b27-9346-f328cad080f3}";;

    FUNCTION       "IsMRM" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This Function will determine if the model is in a deterministic mode or an MRM mode.  Right now, the deterministic run is as high as 32 months and the MRM is as short as 60 months. so anything over 3 years difference between the year of the finish timestep and the year of the start timestep will be an MRM run. The function returns True if the model is in an MRM run and False if the model is not. If the MRM is only run for the deterministic period, this function does not apply. Other methods of determining an MRM run should be implemented here if they are known. TP 3/13/2013<br><br>RETURNS: FALSE if slot LowerBasinDemandVariability.DetermCheck has value of NaN or 1.0; TRUE otherwise [BOOLEAN]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 3/13/2013<br>MC, 20170515: The function is called from several rules in the current ruleset, but the slot used in this function doesn't appear to be set anywhere in the rules. It is currently set as input through Sep 2022 in the model but I can't determine how it was set as it shows up on the MRM DMI but is not in the EnsembleForecasts spreadsheet. I looked at the SEP15 model and spreadsheets and it does not appear in the spreadsheet there either, but is in the model?<br>MC, 20180309: The slot is set from values in the DONOTCHANGE worksheet of the EnsembleForecasts spreadsheet";
    BEGIN

      IF ( IsNaN $ "LowerBasinDemandVariability.DetermCheck" [@"Start Timestep"] OR $ "LowerBasinDemandVariability.DetermCheck" [@"Start Timestep"] == 1.00000000 )
 THEN
  FALSE
 ELSE
  TRUE
 ENDIF;

    END
    UUID "{77c6cb47-3924-443d-80b2-7e8f9c14ffcc}";;

    FUNCTION       "IsDomesticSurplus" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Check if Domestic Surplus for current year.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author, S.Baker 20200311";
    BEGIN

      IF ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{556c0a86-e519-4a67-af64-ea8cacfbef0b}";;

    FUNCTION       "IsQuantifiedSurplus" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Check if Domestic Surplus for current year.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author, S.Baker 20200311";
    BEGIN

      IF ( ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] ) > 0.00000000 ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{ad3e62f1-e978-4110-a9db-401185deb5a3}";;

    FUNCTION       "IsJANofOutyear" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Checks whether the lower basin is in domestic or quantified surplus for a given year<br><br>Added 5/5/2020 by APivarnik";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{ca0b24d2-527c-4ced-8dec-8967f5c30dc4}";;

    FUNCTION       "IsAPRtoDECofStartYear" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Checks whether model is between April and December of the start year<br><br>Added 5/5/2020 by APivarnik";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{52608fc6-c015-4d5b-8fe3-998abe49aca1}";;

    FUNCTION       "IsSurplusOrDCP" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This Function checks the two limits of Shortage or Surplus and returns a boolean statement saying if the water year is in surplus or shortage. This is being used in the LC Demand Variability Logic. TP 4/18/2013<br><br>RETURNS: TRUE if Mead is in Shortage or Surplus; FALSE otherwise [BOOLEAN]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 4/18/2013<br><br>S.Baker, 20180925: Changed IF statements to use function 'GetProjectedPoolElevation' instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). ";
    BEGIN

      IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) <= $ "DCP.DCP_StartElevation" [] )
 THEN
  TRUE
 ELSE
  IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Surplus.Domestic Surplus Trigger Elevation" [] )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF
 ENDIF;

    END
    UUID "{43700a2b-b93e-4abd-93d1-439824e212a9}";;

    FUNCTION       "IsDomesticOrQuantified" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Checks whether the lower basin is in domestic or quantified surplus for a given year<br><br>Added 5/5/2020 by APivarnik";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] ) > 0.00000000 ) OR NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] ) > 0.00000000 )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{1b6eceb1-c37f-4b6b-a557-69aa6d420cb1}";;

    FUNCTION       "IsFloodControl" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Checks whether the lower basin is in flood control surplus for a given year<br><br>Added 5/5/2020 by APivarnik<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( ( NaNToZero ( $ "Surplus.Flood Control Surplus Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] ) > 0.00000000 ) OR ( NaNToZero ( $ "FloodControlOutput.Exclusive Space Flag" [@"24:00:00 December Max DayOfMonth, Current Year"] ) > 0.00000000 ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{53ef8e92-067c-409b-b264-6aa2f7193bc4}";;

    FUNCTION       "IsLBorDCPconditionChanged" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Check if the Lower Basin condition or DCP BWSCP condition has changed between run cycles 3 and 4.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author, S.Baker 20200311<br><br>A.Pivarnik, 20200731: Added NantoZero for the ScheduleCheck slots in the LBDV data object";
    BEGIN

      IF ( NaNToZero ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] ) != NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) OR $ "DCP BWSCP Flags.LB DCP BWSCP Check" ["Dec31ofYear"( @"t" )] != $ "DCP BWSCP Flags.LB DCP BWSCP" ["Dec31ofYear"( @"t" )] )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{92349f2c-df3a-4918-ab7f-7afdefb584a8}";;

    FUNCTION       "IsStartYear" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns True if the timestep is the start timestep, and False otherwise. -CE 6/11/13";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{2df1daae-14b0-4bc8-91ef-c88e83ed7618}";;

    FUNCTION       "IsQuantifiedOrFloodControl" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR NaNToZero ( $ "FloodControlOutput.Flood Control Flag" [] ) > 0.00000000 OR NaNToZero ( $ "FloodControlOutput.Exclusive Space Flag" [] ) > 0.00000000 OR ( NaNToZero ( $ "Surplus.Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 1.00000000 ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{7f9481d7-b0d6-470c-a603-007f3f0e56c5}";;

    FUNCTION       "IsDomesticOrQuantifiedOrFloodControl" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Check if Domestic or Quantified Surplus or Flood Control for current year.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author, S.Baker 20200311";
    BEGIN

      IF ( "IsQuantifiedOrFloodControl"(  ) OR "IsDomesticSurplus"(  ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{2c04ee45-8310-4567-9a7f-56fd04962ab7}";;

    FUNCTION       "IsJPUser" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      { "MWD" , "CAP" , "SNWA" };

    END
    UUID "{0d9bfb23-aee6-4734-887a-578080c69feb}";;

  END
  UUID "{b3476884-4797-4a2d-85f6-4f38a8ce3a39}";;

  UTILITY_GROUP "KNN Functions - MTOM Only";
  DESCRIPTION   "The groups supports daily modeling of FG operations. ";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "ChooseIndexYearRatio" ( NUMERIC aprRatio, NUMERIC mayRatio, NUMERIC junRatio, NUMERIC julRatio )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function selects an index year from the K nearest neighbors in the historical record. The distance calculation between years is based on the monthly volume ratios to the seasonal volume<br><br>RETURNS: Historical year as a number, not a date [NONE]<br><br>ARGUMENTS:<br>1. NUMERIC aprRatio - the April proportion of the seasonal (April-July) volume<br>2. NUMERIC mayRatio - the May proportion of the seasonal volume<br>3. NUMERIC junRatio - the June proportion of the seasonal volume<br>4. NUMERIC julRatio - the July proportion of the seasonal volume<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      GET @INDEX WHILE ( NOT $ "KNN_MTOM.randomNum" [@"24:00:00 December Max DayOfMonth, Current Year"] <= $ "KNN_MTOM.CumulativeSumW" [i, 0.00000000] ) WITH NUMERIC i = 0.00000000 DO
  i + 1.00000000
 ENDWHILE COMMENTED_BY "Select the index year based on the current year's random number" FROM "FindKNNFromRatios"( aprRatio, mayRatio, junRatio, julRatio );

    END
    UUID "{99792043-0230-4c96-9904-0139bbac36cf}";;

    FUNCTION       "FindKNNFromRatios" ( NUMERIC aprRatio, NUMERIC mayRatio, NUMERIC junRatio, NUMERIC julRatio )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function creates a list of the K historical years that are nearest to the year with the monthly ratios specified by the input arguments<br><br>RETURNS: List of lists of the form &lcub;&lcub;Year, Distance&rcub;&rcub;<br><br>ARGUMENTS:<br>1. NUMERIC aprRatio - the April proportion of the seasonal (April-July) volume<br>2. NUMERIC mayRatio - the May proportion of the seasonal volume<br>3. NUMERIC junRatio - the June proportion of the seasonal volume<br>4. NUMERIC julRatio - the July proportion of the seasonal volume<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST sortedYears = "SortPairsAscending"( FOR ( LIST yrVol IN "GetYearsAndRatios"(  ) ) WITH LIST result = {  } DO
  ( APPEND { GET @INDEX 0.00000000 FROM yrVol , "Exp"( ( aprRatio - GET @INDEX 1.00000000 FROM yrVol ) ^ 2.00000000 + ( mayRatio - GET @INDEX 2.00000000 FROM yrVol ) ^ 2.00000000 + ( junRatio - GET @INDEX 3.00000000 FROM yrVol ) ^ 2.00000000 + ( julRatio - GET @INDEX 4.00000000 FROM yrVol ) ^ 2.00000000, 0.50000000 ) } ONTO result ) COMMENTED_BY "Create the list element &lcub;Year, Distance measure&rcub;"
 ENDFOR ) COMMENTED_BY "Create a list with elements &lcub;Year, Distance measure&rcub; for each historic year that is sorted from the smallest to largest distance" DO
  FOR ( NUMERIC val IN "GetNumbers"( 0.00000000, $ "KNN_MTOM.K" [] - 1.00000000, 1.00000000 ) ) WITH LIST result = {  } DO
   APPEND GET @INDEX val FROM sortedYears ONTO result
  ENDFOR COMMENTED_BY "Create a new list with only the K nearest historical years"
 ENDWITH;

    END
    UUID "{7bd300ba-e160-482c-a19c-b7595333ab48}";;

    FUNCTION       "GetCurrentMonthlyNaturalInflow" ( DATETIME month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the monthly flow volume for the month specified in the input argument of the current year (when this function is called from the rule Set Yampa Daily Natural - Second Stage Disagg, the input argument is actually a date, not a month)<br><br>RETURNS: Flow volume for month [L^3]<br><br>ARGUMENTS:<br>1. DATETIME month<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH DATETIME currentMonth = "GetDate"( "GetMonthAsString"( month ) CONCAT ",current year" ) DO
  "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [currentMonth], currentMonth )
 ENDWITH;

    END
    UUID "{6ef7c824-38ad-4899-812e-62d8efe18629}";;

    FUNCTION       "GetCurrentYearDailyList" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function generates a list of the dates within the KNN StartMonth to EndMonth period (currently April-July) for the current year<br><br>RETURNS: List of dates<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170714: Implemented Heather P.'s changes that use predefined functions to streamline the code and remove older CONCAT statements for constructing dates";
    BEGIN

      "GetDates"( "CompletePartialDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ), "CompletePartialDate"( @"Min DayOfMonth", @"t" ) ), "CompletePartialDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ), "CompletePartialDate"( @"Max DayOfMonth", @"t" ) ), "1 days" );

    END
    UUID "{dc5da988-06d5-4c46-8ef6-fb7a181eb304}";;

    FUNCTION       "GetIndexYearDailyList" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function generates a list of the dates within the KNN StartMonth to EndMonth period (currently April-July) for the KNN index year<br><br>RETURNS: List of dates (days) <br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170714: Implemented Heather P.'s changes that use predefined functions to streamline the code and remove some older CONCAT statements for constructing dates";
    BEGIN

      "GetDates"( "CompletePartialDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ), "CompletePartialDate"( "NumberToYear"( $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] ), @"24:00:00 December 31" COMMENTED_BY "The month doesn't matter here, it just needs a month to be valid <br>" ) ), "CompletePartialDate"( "NumberToYear"( $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] ), "GetDate"( "24:00:00" CONCAT ( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT " Max DayOfMonth" ) ) ), "1 days" );

    END
    UUID "{7882d699-3853-4cc0-aa2c-fa9afd807abd}";;

    FUNCTION       "GetMonthlyProportionVector" ( DATETIME month )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates each day's volume proportion of the monthly volume (for the month passed as an input argument) for the historical index year<br><br>RETURNS: List of proportion values [NONE]<br><br>ARGUMENTS:<br>1. DATETIME month - month for which the proportions are needed<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST days = "GetDates"( "GetDate"( "GetMonthAsString"( month ) CONCAT "1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"], "." ) ), "GetDate"( ( "GetMonthAsString"( month ) CONCAT " " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( month ), "." ) ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"], "." ) ), "1 DAYS" ) COMMENTED_BY "Generate list of days in month for historical index year" DO
  WITH NUMERIC monthlyVolume = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeDaily", GET @INDEX 0.00000000 FROM days, GET @INDEX ( LENGTH days ) - 1.00000000 FROM days ) DO
   FOR ( DATETIME day IN days ) WITH LIST propVec = {  } DO
    ( APPEND ( $ "KNN_MTOM.DeerlodgeDaily" [day] * 24.00000000 "hour" ) / monthlyVolume ONTO propVec ) COMMENTED_BY "Calculate each day's volume proportion and append to result list"
   ENDFOR
  ENDWITH
 ENDWITH;

    END
    UUID "{24ebe7b8-3e0b-43db-aad9-f671f078ea33}";;

    FUNCTION       "GetProportionVector" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates each day's volume proportion of the total spring volume for the historical index year<br><br>RETURNS: List of proportion values [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC sprVol = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeDaily", GET @INDEX 0.00000000 FROM "GetIndexYearDailyList"(  ), GET @INDEX ( LENGTH "GetIndexYearDailyList"(  ) ) - 1.00000000 FROM "GetIndexYearDailyList"(  ) ) COMMENTED_BY "Calculate the spring period volume for the historical index year" DO
  FOR ( DATETIME day IN "GetIndexYearDailyList"(  ) ) WITH LIST propVec = {  } DO
   APPEND "FlowToVolume"( $ "KNN_MTOM.DeerlodgeDaily" [day], day ) / sprVol ONTO propVec
  ENDFOR COMMENTED_BY "Calculate each day's proportion of the spring volume"
 ENDWITH;

    END
    UUID "{0074f1bc-4aab-45a7-888c-676c48a3fe89}";;

    FUNCTION       "GetRandSeed" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns a seed for use by the Random or RandomNormal function. The seed is incremented by the trace number, as stored in the first timestep of the Hydrology Increment slot. The trace number could be available as a RPL function, but would not be enough to fulfill our requirements.<br><br>In the current setup, all MRM runs will have the same set of random numbers at the same trace, but all traces will have different sets, as controlled by the Hydrology Increment slot, which is rotated with the MRM runs.<br>This also allows single trace runs to have identical random numbers generated as well, which is not possible with a RPL function.<br><br>Probably should rename the Hydrology Increment slot to Trace Number.<br><br>With Random Seed = 1, is equivalent to just using the Trace Number as the seed for each trace.<br><br>RETURNS: Number used as seed for Random or RandomNormal function [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170504: The above description predates the use of this uniform documentation format.";
    BEGIN

      ( $ "KNN_MTOM.Random Seed" [] + ( $ "KNN_MTOM.hydrologyIncrement" [@"Start Timestep"] - 1.00000000 ) );

    END
    UUID "{b82a2262-4926-4732-9ad7-60bb9238a592}";;

    FUNCTION       "GetSecondStageProportionVector" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates each day's volume as a proportion of its respective month's volume, based on the same proportions from the historical index year, for the April-July period of the current year<br><br>RETURNS: List of numeric proportions [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME month IN "GetDates"( @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year", "1 MONTHS" ) ) WITH LIST propVec = {  } DO
  WITH LIST monthlyProp = "GetMonthlyProportionVector"( month ) COMMENTED_BY "Calculate the month's daily proportion vector" DO
   FOR ( NUMERIC dayProp IN monthlyProp ) WITH LIST result = propVec DO
    APPEND dayProp ONTO result
   ENDFOR COMMENTED_BY "Loop through the month's vector and append elements to final result list"
  ENDWITH
 ENDFOR COMMENTED_BY "Loop through each month in the April-July period";

    END
    UUID "{bc275580-8670-4b81-b1a4-1e1fe19ba1df}";;

    FUNCTION       "GetSpringVolume" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculate the total volume of Yampa_at_Deerlodge for the KNN StartMonth to EndMonth (currently April-July) period<br><br>RETURNS: Flow volume for Yampa_at_Deerlodge [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", "GetDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ) CONCAT ",current year" ), "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ",current year" ) );

    END
    UUID "{d9baf231-40c8-4a0f-bcd3-316090ffe94c}";;

    FUNCTION       "GetYearsAndRatios" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: For each year in the historical record, this function calclulates each month's proportion of the total April-July Yampa flow volume<br><br>RETURNS: List of lists of the form &lcub;&lcub;Year, Apr proportion, May proportion, June proportion, July proportion&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC year IN "GetNumbers"( "GetYear"( "NumberToDate"( $ "KNN_MTOM.HistoricalStartYear" [] ) ), "GetYear"( "NumberToDate"( $ "KNN_MTOM.HistoricalEndYear" [] ) ), 1.00000000 ) ) WITH LIST result = {  } DO
  WITH NUMERIC seasonalVol = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeMonthly", "GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ), "GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) DO
   APPEND { year , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "May, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "May, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "June, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "June, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol } ONTO result
  ENDWITH COMMENTED_BY "Calculate the year's April-July volume"
 ENDFOR COMMENTED_BY "Loop over list of historical years";

    END
    UUID "{3421e235-5589-41ee-82aa-aaf502c408c0}";;

  END
  UUID "{d46ce5a8-519b-4a78-bc44-3592bab88f5a}";;

  UTILITY_GROUP "Headwater Reservoir Functions - MTOM Only";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetEOMTargetElevation" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object and a date, and then returns the end of month target elevation for that reservoir on that date.  This function requires that the reservoirs data object be named &quot;[reservoir]Data&quot; and that the guide slot that holds the target elevations be named &quot;[reservoir]Guide&quot;.  - sc 12/16/10<br><br>RETURNS: Pool elevation [L]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir for which target elevation is desired<br>2. DATETIME date - date for which target is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/16/2010";
    BEGIN

      WITH OBJECT resDataObj = "GetObject"( ( STRINGIFY res ) CONCAT "Data" ) DO
  WITH STRING guideSlotName = ( STRINGIFY res ) CONCAT "Guide" DO
   resDataObj & guideSlotName [date, "Target Elevation"]
  ENDWITH
 ENDWITH;

    END
    UUID "{133fd05a-5f04-4108-9cbb-6c3291556205}";;

    FUNCTION       "GetReservoirMinConstraint" ( OBJECT reservoir, DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir and a date and returns the minimum constraint to the outflow allowed from that reservoir on that date. - sc 12/16/10<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which minimum outflow is desired (Taylor Park or Vallecito)<br>2. DATETIME date - date for which minimum is desired<br>3. NUMERIC prevElev - pool elevation at the end of the previous timestep<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/16/2010<br>TV, 8/1/2012: Added additional argument necessary for Taylor Park";
    BEGIN

      IF ( reservoir == % "TaylorPark" )
 THEN
  "Min"( $ "TaylorParkData.MinFlow" [date] COMMENTED_BY "Minimum flow requirements", "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [date], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ), "ElevationToStorage"( % "TaylorPark", prevElev ), date ) COMMENTED_BY "Maximum possible release from reservoir to dead pool. -tv 8.1.12" )
 ELSE
  IF ( reservoir == % "Vallecito" )
  THEN
   $ "VallecitoData.MinFlow" []
  ELSE
   STOP_RUN "No such Reservoir"
  ENDIF
 ENDIF;

    END
    UUID "{44e04b3a-bb3c-4ddf-b530-b5f467d84e82}";;

    FUNCTION       "MonthlyEvapVolume" ( OBJECT reservoir, DATETIME date, NUMERIC previousPoolElevation, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object, a datetime, a pool elevation and storage at the end of the timestep previous to the passed-in date.  It returns the volume of water evaporated from the passed-in reservoir during the passed-in date timestep. - sc 12/19/10<br><br>RETURNS: Evaporation volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which evaporation estimate is desired<br>2. DATETIME date - date the specifies the timestep for which evaporation is desired<br>3. NUMERIC previousPoolElevation - pool elevation at the end of the timestep prior to &quot;date&quot;<br>4. NUMERIC previousStorage - storage volume at the end of the timestep prior to &quot;date&quot;<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/19/2010";
    BEGIN

      WITH NUMERIC evapHeight = reservoir & "Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000] * "GetDaysInMonth"( date ) DO
  WITH NUMERIC elevationAfterEvap = previousPoolElevation - evapHeight DO
   WITH NUMERIC storageAfterEvap = "TableInterpolation"( reservoir & "Elevation Volume Table", 0.00000000, 1.00000000, elevationAfterEvap, date ) DO
    previousStorage - storageAfterEvap
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{95e070e9-407f-4d75-88bb-2e435212c932}";;

    FUNCTION       "GetReservoirMaxConstraint" ( OBJECT reservoir, DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir and a date and returns the maximum constraint to the outflow allowed from that reservoir on that date. - sc 12/16/10<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which maximum outflow is desired (Taylor Park or Vallecito)<br>2. DATETIME date - date for which maximum is desired<br>3. NUMERIC prevElev - pool elevation at the end of the previous timestep<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/16/2010";
    BEGIN

      IF ( reservoir == % "TaylorPark" OR reservoir == % "Vallecito" )
 THEN
  "TableInterpolation"( reservoir & "Max Release", 0.00000000, 1.00000000, prevElev, @"t" )
 ELSE
  STOP_RUN "No such Reservoir"
 ENDIF;

    END
    UUID "{49a1ce5c-6e8c-4ed2-94aa-f7f0d74401cd}";;

    FUNCTION       "SolveConstrainedOutflow" ( OBJECT reservoir, NUMERIC elevationTarget, NUMERIC previousPoolElev, NUMERIC minConstraint, NUMERIC maxConstraint, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object, an end-of-timestep elevation target, a previous timestep elevation, a minimum release constraint, a maximum release constraint, and a datetime.  It returns a release value for the passed in reservoir on the passed in date that hits the elevation target, or gets as close as possible within the passed in constraints.  Note the min and max constraints are imposed in the Post-Execution checks and do not appear in the body of the function. - sc 12/14/10<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which outflow is desired<br>2. NUMERIC elevationTarget - target pool elevation<br>3. NUMERIC previousPoolElev - pool elevation at end of previous timestep<br>4. NUMERIC minConstraint - minimum flow rate possible<br>5. NUMERIC maxConstraint - maximum flow rate possible<br>6. DATETIME date - date for which pool elevation should meet target<br><br>CONSTRAINTS: minConstraint & maxConstraint (passed arguments)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    MAX_CONSTRAINT maxConstraint;
    MIN_CONSTRAINT minConstraint;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/14/2010<br>MC, 20170531: Remove WITH statement?";
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [date], "ElevationToStorage"( reservoir, elevationTarget ), "ElevationToStorage"( reservoir, previousPoolElev ), date );

    END
    UUID "{5a9087bc-e584-4bbd-9615-98cce35b252f}";;

    FUNCTION       "SimulateHeadwaterRes" ( OBJECT reservoir )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object and returns a list of three-item lists, each sub-list of the form &lcub;date, outflow, end-of-month pool elevation&rcub;. There is one sublist for each timestep in the run.<br>The function operates the passed-in reservoir basically according to a guide curve specified on the reservoirs data object.  A minimum constraint and maximum constraint to the outflow are calculated for each timestep that provides a floor and ceiling to the outflow that can be initiated to hit the elevation target prescribed by the guide curve.  A water balance calculation is performed at each timestep to determine the pool elevation at the end of the timestep. Then it steps forward one timestep does another water balance calculation, and continues doing this until it reaches the last timestep of the run.  The water balance equation used here is:<br><br>[Previous End of Month Storage] + [Reservoir Inflow] - [Reservoir Outflow] - [Reservoir Evaporation] = [End of Month Storage].  - sc 12/20/10<br><br>RETURNS: List of lists of the form &lcub;&lcub;date, outflow, End of month pool elevation&rcub;&rcub;<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which outflows are desired<br><br>CONSTRAINTS: minConstraint and maxConstraint outflows calculated by user-defined functions<br><br><br><br>TV, 20120801: Added additional argument (previous pool elevation) required by changes to the function GetReservoirMinConstraint";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/20/2010";
    BEGIN

      FOR ( DATETIME date IN @"Start Timestep" TO @"Finish Timestep" ) WITH LIST result = {  } DO
  WITH NUMERIC previousPoolElevation = IF ( date == @"Start Timestep" )
  THEN
   reservoir & "Pool Elevation" [@"t - 1"]
  ELSE
   GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result
  ENDIF DO
   WITH NUMERIC resOutflow = WITH NUMERIC elevationTarget = "GetEOMTargetElevation"( reservoir, date ) DO
    WITH NUMERIC minConstraint = "GetReservoirMinConstraint"( reservoir, date, previousPoolElevation ) DO
     WITH NUMERIC maxConstraint = "GetReservoirMaxConstraint"( reservoir, date, previousPoolElevation ) DO
      "SolveConstrainedOutflow"( reservoir, elevationTarget, previousPoolElevation, minConstraint, maxConstraint, date )
     ENDWITH
    ENDWITH
   ENDWITH COMMENTED_BY "Calculate outflow from previous pool elevation to target subject to constraints" DO
    WITH NUMERIC PreviousStorage = "TableInterpolation"( reservoir & "Elevation Volume Table", 0.00000000, 1.00000000, previousPoolElevation, date ) DO
     WITH NUMERIC releaseVolume = resOutflow * "GetDaysInMonth"( date ) DO
      WITH NUMERIC inflowVolume = reservoir & "Inflow" [date] * "GetDaysInMonth"( date ) DO
       WITH NUMERIC evapVolume = "MonthlyEvapVolume"( reservoir, date, previousPoolElevation, PreviousStorage ) DO
        WITH NUMERIC newStorage = PreviousStorage + inflowVolume - releaseVolume - evapVolume DO
         WITH NUMERIC EOMPoolElevation = "TableInterpolation"( reservoir & "Elevation Volume Table", 1.00000000, 0.00000000, newStorage, date ) DO
          APPEND { date , resOutflow , EOMPoolElevation } ONTO result
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDFOR;

    END
    UUID "{f70cfce2-dd89-4470-b370-8a8104785219}";;

  END
  UUID "{cc0cf129-e6a2-4321-9a65-96d06f919462}";;

  UTILITY_GROUP "Fontenelle Functions - MTOM Only";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "FontenelleMonthlyOutflow" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION:This function returns a monthly outflow for Fontenelle reservoir based on the monthly logic that has always been in the MTOM model.  There are various constraints for some months where the logic is specified for that month and for those months that are not specified, the outflow is set to the outflow of the month before.  All of the monthly flows are constrained to the Min and Max constraints that are conditioned into the function and can be viewed when the &quot;Post-Exec. Checks&quot; box is checked.  <br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Minimum monthly release; release to reach maximum pool elevation; safe channel capacity; release to reach minimum pool elevation";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MAX_CONSTRAINT "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", 6408.00100000 "ft" ), $ "Fontenelle.Storage" [@"t - 1"], @"t" );
    MIN_CONSTRAINT "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", 6518.99900000 "ft" ), $ "Fontenelle.Storage" [@"t - 1"], @"t" );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 5/11/2015<br><br>20201210,CF: Min and Max of elevation volume table PEs to prevent exceeding. Later rules impose constraints.<br><br>20201210,CF: Fontenelle constraints changed to rules to make differencing runs easier. New rules match CRSS: Safe Channel Capacity, Min Elevation, Max Elevation, Min Flow. Removed from FontenelleMonthlyOutflow() but old function saved FontenelleMonthlyOutflow_Constrained()<br><br>TP, 5/11/2015: This rule replaces a series of 11 other rules that made similar checks.<br><br>MC, 20160816: Corrected the date of the beginning pool elevations in the ElevationToStorage functions for April, September, and December from @&quot;t&quot; to @&quot;t-1&quot;, and changed the time periods in the denominators of those months' calculations from a number of months to a difference of dates, which more accurately calculates the periods in question since &quot;month&quot; in RW is 31 days. Other possible modifications discussed with Lee T. before she left are: 1) changing the recalculation of winter flows from December to October to better reflect actual operations; 2) changing the minimum elevation to 6,465 feet because 6,468 feet is not a hard boundary (leaving the target at 6,468 ft but changing the min elevation to 6,465 ft allows some flexibility in the model that reflects actual operations); 3) adding an estimate of evaporation to the above months' flow calculations (doesn't make much difference); 4) making the minimum flow values periodic and variable throughout the year<br><br>MC, 20170508: All of the changes discussed in the above comment were in place by the April 2017 MTOM run<br><br>S.Baker, 2018/11/26: There was a lower minimum elevation in Fontenelle from 1985-1989. To enable the testbed to simulate Fontenelle's operations closer to the historical operations, a new expression slot was added to account for a lower minimum elevation during this period. The expression slot would check the date to see if it falls in the 1985-1989 time frame and use the lower minimum elevation if it does. This would cause no changes to the current operation of Fontenelle.  Change - Replaced &quot;FontenelleData.MinElevation&quot; in the Max Constraint of the Post-Execution Checks to use the scalar slot ?FontenelleData.MinElevation_FullRecord?.  This new slot sets a lower minimum elevation for 1985-1989 when Fontenelle was drawn down. <br><br>";
    BEGIN

      WITH NUMERIC June1Target = 6480.00000000 "feet" COMMENTED_BY "June 1st target of 6480 not included in CRSS. Reclamation operators of Fontenelle indicated the June 1st <br>target represents operator preference and not a standard operating procedure.  <br>" DO
  IF ( "MonthIs"( { "July" } ) )
  THEN
   "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] ) COMMENTED_BY "Set the July Outflow to be such that the August 1 Pool Elevation target is met"
  ELSE
   IF ( "MonthIs"( { "June" } ) )
   THEN
    IF ( $ "Fontenelle.Pool Elevation" [] > $ "FontenelleData.July1Target" [] )
    THEN
     "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] )
    ELSE
     "FontenelleTargetFlow"( $ "FontenelleData.July1Target" [] )
    ENDIF COMMENTED_BY "Release flows such that the July target is met unless the current pool elevation<br>is currently above the July pool elevation target, then release for the August 1<br>target"
   ELSE
    IF ( "MonthIs"( { "April" } ) )
    THEN
     "Min"( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.July1Target" [] ) + ( "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 2" ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.July1Target" [] ), @"t - 1", @"t + 2" ) ) ) / ( @"24:00:00 June Max DayOfMonth, Current Year" - @"24:00:00 March Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Steady release over April, May and June to meet July1 Target", "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) COMMENTED_BY "Power Plant Capacity" )
    ELSE
     IF ( "MonthIs"( { "August" } ) )
     THEN
      "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" )
     ELSE
      IF ( "MonthIs"( { "October" } ) )
      THEN
       ( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 5" ) ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ), @"t - 1", @"t + 5" ) ) / ( @"24:00:00 March Max DayOfMonth, Next Year" - @"24:00:00 September Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Compute the steady flow over December to March necsessary to meet Apr 1 target. Change in storage plus forecasted volume divided by 4 months. The next 3 months will look back at this value."
      ELSE
       IF ( "MonthIs"( { "September" } ) )
       THEN
        ( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 6" ) ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ), @"t - 1", @"t + 6" ) ) / ( @"24:00:00 March Max DayOfMonth, Next Year" - @"24:00:00 August Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Compute the steady flow over September to March necsessary to meet Apr 1 target. Change in storage plus forecasted volume divided by 3 months.  The next two months will look back at this value."
       ELSE
        IF ( "MonthIs"( { "May" } ) )
        THEN
         "Max"( $ "Fontenelle.Outflow" [@"t - 1"], "SolveOutflow"( % "Fontenelle", % "Fontenelle" & "Inflow" [@"t"], "ElevationToStorage"( % "Fontenelle", June1Target ), "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ), @"t" ) )
        ELSE
         $ "Fontenelle.Outflow" [@"t - 1"]
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{953a1967-db48-452c-a7c7-879b2acd5339}";;

    FUNCTION       "FontenelleMonthlyOutflow_wConstraints" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION:This function returns a monthly outflow for Fontenelle reservoir based on the monthly logic that has always been in the MTOM model.  There are various constraints for some months where the logic is specified for that month and for those months that are not specified, the outflow is set to the outflow of the month before.  All of the monthly flows are constrained to the Min and Max constraints that are conditioned into the function and can be viewed when the &quot;Post-Exec. Checks&quot; box is checked.  <br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Minimum monthly release; release to reach maximum pool elevation; safe channel capacity; release to reach minimum pool elevation";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT "MaxItem"( { $ "FontenelleData.PeriodicMinFlow" [] , "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) } ) COMMENTED_BY "Must release at least the monthly minimum rate and enough to ensure pool elevation does not exceed maximum";
    MAX_CONSTRAINT IF ( ( "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) < 0.00000000 "acre-ft/month" ) COMMENTED_BY "Reservoir can accept all inflow without exceeding maximum capacity" )
 THEN
  "Min"( $ "FontenelleData.SafeChannelCapacity" [], "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MinElevation_FullRecord" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) ) COMMENTED_BY "Maximum is either the SafeChannelCapacity or outflow to reach the minimum elevation"
 ELSE
  "Max"( $ "FontenelleData.SafeChannelCapacity" [], "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) ) COMMENTED_BY "Maximum is either the SafeChannelCapacity or outflow to reach the maximum elevation"
 ENDIF;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 5/11/2015<br><br>TP, 5/11/2015: This rule replaces a series of 11 other rules that made similar checks.<br><br>MC, 20160816: Corrected the date of the beginning pool elevations in the ElevationToStorage functions for April, September, and December from @&quot;t&quot; to @&quot;t-1&quot;, and changed the time periods in the denominators of those months' calculations from a number of months to a difference of dates, which more accurately calculates the periods in question since &quot;month&quot; in RW is 31 days. Other possible modifications discussed with Lee T. before she left are: 1) changing the recalculation of winter flows from December to October to better reflect actual operations; 2) changing the minimum elevation to 6,465 feet because 6,468 feet is not a hard boundary (leaving the target at 6,468 ft but changing the min elevation to 6,465 ft allows some flexibility in the model that reflects actual operations); 3) adding an estimate of evaporation to the above months' flow calculations (doesn't make much difference); 4) making the minimum flow values periodic and variable throughout the year<br><br>MC, 20170508: All of the changes discussed in the above comment were in place by the April 2017 MTOM run<br><br>S.Baker, 2018/11/26: There was a lower minimum elevation in Fontenelle from 1985-1989. To enable the testbed to simulate Fontenelle's operations closer to the historical operations, a new expression slot was added to account for a lower minimum elevation during this period. The expression slot would check the date to see if it falls in the 1985-1989 time frame and use the lower minimum elevation if it does. This would cause no changes to the current operation of Fontenelle.  Change - Replaced &quot;FontenelleData.MinElevation&quot; in the Max Constraint of the Post-Execution Checks to use the scalar slot ?FontenelleData.MinElevation_FullRecord?.  This new slot sets a lower minimum elevation for 1985-1989 when Fontenelle was drawn down. ";
    BEGIN

      WITH NUMERIC June1Target = 6480.00000000 "feet" DO
  IF ( "MonthIs"( { "July" } ) )
  THEN
   "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] ) COMMENTED_BY "Set the July Outflow to be such that the August 1 Pool Elevation target is met"
  ELSE
   IF ( "MonthIs"( { "June" } ) )
   THEN
    IF ( $ "Fontenelle.Pool Elevation" [] > $ "FontenelleData.July1Target" [] )
    THEN
     "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] )
    ELSE
     "FontenelleTargetFlow"( $ "FontenelleData.July1Target" [] )
    ENDIF COMMENTED_BY "Release flows such that the July target is met unless the current pool elevation<br>is currently above the July pool elevation target, then release for the August 1<br>target"
   ELSE
    IF ( "MonthIs"( { "April" } ) )
    THEN
     "Min"( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.July1Target" [] ) + ( "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 2" ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.July1Target" [] ), @"t - 1", @"t + 2" ) ) ) / ( @"24:00:00 June Max DayOfMonth, Current Year" - @"24:00:00 March Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Steady release over April, May and June to meet July1 Target", "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) COMMENTED_BY "Power Plant Capacity" )
    ELSE
     IF ( "MonthIs"( { "August" } ) )
     THEN
      "Min"( "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ), $ "Fontenelle.Outflow" [@"t - 1"] )
     ELSE
      IF ( "MonthIs"( { "October" } ) )
      THEN
       ( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 5" ) ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ), @"t - 1", @"t + 5" ) ) / ( @"24:00:00 March Max DayOfMonth, Next Year" - @"24:00:00 September Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Compute the steady flow over December to March necsessary to meet Apr 1 target. Change in storage plus forecasted volume divided by 4 months. The next 3 months will look back at this value."
      ELSE
       IF ( "MonthIs"( { "September" } ) )
       THEN
        ( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 6" ) ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ), @"t - 1", @"t + 6" ) ) / ( @"24:00:00 March Max DayOfMonth, Next Year" - @"24:00:00 August Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Compute the steady flow over September to March necsessary to meet Apr 1 target. Change in storage plus forecasted volume divided by 3 months.  The next two months will look back at this value."
       ELSE
        IF ( "MonthIs"( { "May" } ) )
        THEN
         "Max"( $ "Fontenelle.Outflow" [@"t - 1"], "SolveOutflow"( % "Fontenelle", % "Fontenelle" & "Inflow" [@"t"], "ElevationToStorage"( % "Fontenelle", June1Target ), "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ), @"t" ) )
        ELSE
         $ "Fontenelle.Outflow" [@"t - 1"]
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{6c6d1c62-c804-492e-9778-f5e4a1337432}";;

    FUNCTION       "FontenelleTargetFlow" ( NUMERIC Elevation )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the target outflow for Frontenelle. The outflow is either the maximum possible outflow given the inflow, or the release needed to meet the target elevation, whichever is less assuming the flow meets the power plant capacity. - ce 6/6/13<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS:<br>1. NUMERIC Elevation - the target pool elevation to reach with the outflow<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT $ "FontenelleData.MinFlow" [];
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170609: Could the maximum possible release be moved to the Post-Excecution Checks?";
    BEGIN

      "Min"( "GetMaxOutflowGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) COMMENTED_BY "Maximum possible release from the res", "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", Elevation ), "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Release to meet target elevation" );

    END
    UUID "{9ec34bd6-716d-4ab2-9171-8318cee7af98}";;

  END
  UUID "{982d8054-08ce-417f-b3ec-e0f02ef86827}";;

  UTILITY_GROUP "Flaming Gorge Functions - MTOM Only";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "DaysToDownramp" ( NUMERIC PPC, NUMERIC Baseflow, NUMERIC Rate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the number of days required to downramp from powerplant capacity to baseflow. Baseflow is set by the current hydrologic classification. The unit business is because Riverware cannot currently do calculations with the FlowPerTime unit. <br><br>RETURNS: Number of days [NONE]<br><br>ARGUMENTS<br>1. NUMERIC PPC - beginning flow rate (assuming powerplant capacity)<br>2. NUMERIC Baseflow - ending flow rate (baseflow rate based on current hydrologic classification)<br>3. NUMERIC Rate - daily flow rate reduction value<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      ( ( PPC - Baseflow ) / ( Rate / 1.00000000 "day" ) ) COMMENTED_BY "Assuming we are downramping from power plant capacity, divide required reduction in flow rate by the daily reduction in rate";

    END
    UUID "{78759d68-59dc-4d82-8630-7e85ca6ee382}";;

    FUNCTION       "DaysToRampUp" ( NUMERIC PPC, NUMERIC Baseflow, NUMERIC Rate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: The number of days to ramp up are determined by either the powerplant capacity minus the baseflow divided by the ramp up rate, or 0, whichever is greater<br><br>RETURNS: Number of days [NONE]<br><br>ARGUMENTS<br>1. NUMERIC PPC - beginning flow rate (assuming powerplant capacity)<br>2. NUMERIC Baseflow -ending flow rate  (baseflow rate based on current hydrologic classification)<br>3. NUMERIC Rate - daily flow rate reduction value<br><br>CONSTRAINTS<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: CE 6/12/13";
    BEGIN

      "Max"( ( PPC - Baseflow ) / ( Rate / 1.00000000 "day" ), 0.00000000 "day" );

    END
    UUID "{33bf34b1-47e6-4c7e-9d1a-3d415ec67169}";;

    FUNCTION       "ForecastComputeOutflowAtRuleCurveStorage" ( OBJECT reservoir, DATETIME month, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function performs a simple water balance for the reservoir and month specified as inputs. The water balance is based on the previous storage passed to the function, the rule curve storage for the month passed as input, the reservoir inflows, and an evaporation estimate.<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS<br>1. OBJECT reservoir - reservoir for which outflow forecast is needed<br>2. DATETIME month - timestep for which outflow forecast is needed<br>3. NUMERIC previousStorage - reservoir storage volume at beginning of month<br><br>CONSTRAINTS: Minimum and Maximum release rates for the specified reservoir<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    MIN_CONSTRAINT "GetMinRelease"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      ( previousStorage - "RuleCurveStorage"( reservoir, month ) ) / 1.00000000 "month" + reservoir & "Inflow" [month] - "VolumeToFlow"( "EstimateEvaporation"( reservoir, previousStorage, previousStorage, month, month ), month );

    END
    UUID "{08d36834-bcde-43ee-8829-62f5eac11f81}";;

    FUNCTION       "ForecastComputeStorageAtGivenOutflow" ( OBJECT reservoir, NUMERIC outflow, DATETIME month, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Based on a simple water balance and the given input arguments, this function returns either the Inactive Capacity of the reservoir or a projection of the storage taking into account the outflow and estimated evaporation<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which outflow forecast is needed<br>2. NUMERIC outflow - outflow rate to use in forecast<br>3. DATETIME month - timestep for which outflow forecast is needed<br>4. NUMERIC previousStorage - reservoir storage volume at beginning of month<br><br>CONSTRAINTS: Inactive storage capacity; Live storage capacity (from slot UBRuleCurveData.ReservoirData)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT "GetInactiveCapacity"( reservoir );
    MAX_CONSTRAINT "GetLiveCapacity"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170503: Previous version of function was written so that it returned either the InactiveCapacity or the LiveCapacity (fixed value), but could not return a value between those; rewrote the function to return the computed water balance value constrained by the Inactive or Live capacity";
    BEGIN

      WITH NUMERIC ForecastStorage = previousStorage + "FlowToVolume"( reservoir & "Inflow" [month], month ) - ( "FlowToVolume"( outflow, month ) + "EstimateEvaporation"( reservoir, previousStorage, previousStorage, month, month ) ) DO
  "Max"( "Min"( ForecastStorage, "GetLiveCapacity"( reservoir ) ), "GetInactiveCapacity"( reservoir ) )
 ENDWITH;

    END
    UUID "{edee65c3-f67e-4b56-a622-b61a2a83de43}";;

    FUNCTION       "ForecastFontenelleRelease" ( DATETIME startMonth, DATETIME endMonth )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function forecasts the releases and associated storage volumes for Fontenelle for the period startMonth to endMonth.<br><br>RETURNS: List of lists of the form &lcub;&lcub;Storage volumes&rcub;, &lcub;Outflow rates&rcub;&rcub;<br><br>ARGUMENTS:<br>1. DATETIME startMonth - first month in the period of calculation<br>2. DATETIME endMonth - last month in the period of calculation<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC totalMonths = IF ( "GetMonth"( endMonth ) - "GetMonth"( startMonth ) < 0.00000000 )
 THEN
  12.00000000 - "Abs"( "GetMonth"( endMonth ) - "GetMonth"( startMonth ) )
 ELSE
  "GetMonth"( endMonth ) - "GetMonth"( startMonth )
 ENDIF DO
  FOR ( NUMERIC month IN "GetNumbers"( 0.00000000, totalMonths, 1.00000000 ) ) WITH LIST result = { { $ "Fontenelle.Storage" ["OffsetDate"( startMonth, - 1.00000000, "1 MONTHS" )] } COMMENTED_BY "Previous storage" , {  } COMMENTED_BY "New outflow " } DO
   WITH DATETIME currentDate = "OffsetDate"( startMonth, month, "1 MONTHS" ) DO
    WITH NUMERIC newStorage = "ForecastComputeStorageAtGivenOutflow"( % "Fontenelle", "ForecastComputeOutflowAtRuleCurveStorage"( % "Fontenelle", currentDate, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ), currentDate, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ) DO
     { APPEND newStorage COMMENTED_BY "New, compute StorageAtGivenOutflow which takes time and previous storage as a parameter" ONTO GET @INDEX 0.00000000 FROM result , APPEND ( ( ( GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ) - newStorage ) / 1.00000000 "month" + % "Fontenelle" & "Inflow" [currentDate] - "VolumeToFlow"( "EstimateEvaporation"( % "Fontenelle", GET @INDEX month FROM GET @INDEX 0.00000000 FROM result, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result, currentDate, currentDate ), currentDate ) ) COMMENTED_BY "MC, 20170503: Does this give the same flow rate as ForecastComputeOutflowAtRuleCurveStorage in the computation of newStorage?" ONTO GET @INDEX 1.00000000 FROM result }
    ENDWITH
   ENDWITH
  ENDFOR
 ENDWITH;

    END
    UUID "{11035a5f-eb7f-4499-af91-01c67167adcc}";;

    FUNCTION       "GetFGBaseFlowMagnitude" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft/month";
    DESCRIPTION    "DESCRIPTION: Returns the steady base flow magnitude necessary to meet the May 1 ULDE.  The magnitude is first projected as if there are no base flow limits. If the necessary base flow is outside of the limits, then the returned flow is within the limits set by the current hydrologic classification. <br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF, 20190128: Removed Min Constraint SolveOutflow(MaxPE) to since it is not being applied as part of a Max() check along with MinFlow at the rule level to match CRSS.  <br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "GetFGBaseFlowMagnitudeUnconstrained"(  ) < $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 0.00000000] )
 THEN
  $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 0.00000000] COMMENTED_BY "Use Lower Limit of Base Flow Range"
 ELSE
  IF ( "GetFGBaseFlowMagnitudeUnconstrained"(  ) > $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 1.00000000] )
  THEN
   $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 1.00000000] COMMENTED_BY "Use Upper Limit of Base Flow Range"
  ELSE
   "GetFGBaseFlowMagnitudeUnconstrained"(  ) COMMENTED_BY "Somewhere in between, use calculated value"
  ENDIF
 ENDIF;

    END
    UUID "{038a3f53-27d1-4a78-9f2b-538e58c4e3b5}";;

    FUNCTION       "GetFGBaseFlowMagnitudeUnconstrained" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    ".acre-ft/month";
    DESCRIPTION    "Arguements: None<br><br>DESCRIPTION: Uses a simple water balance with predicted inflows to calculate a steady outflow rate from the current timestep to the next April to meet the May 1 ULDE regardless of base flow restrictions. Additional provisions ensure FG baseflow will be sufficent to meet the lower baseflow limit set for the Green at Jensen by the EIS during baseflow operation months. <br><br>- Jan-April: Use current inflow forecast to calculate the baseflow needed to achieve the Target May 1 UDLE (based on precent exceedence/current hydrologic year classification).<br>- May-Dec: Use predicted inflow between t and next April to calculate the baseflow needed to achieve the March 1 drawdown level of 6027ft from the EIS. <br><br>Returns: The unconstrained baseflow [L^3/T]";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF,20200104:Now take Inflow - EstEvap to account for evaporation. Previous comments I made in MTOM rules about not needing to account for Evap were incorrect.<br><br>CF 20190125: Updated to use TargetHWGivenInflowOneMonth<br><br>CF,20190109: TargetHWGivenInflow now take Inflow - EstEvap to account for evaporation. Jan-Feb now uses GetMay1TargetElevation() according to direction from HP about use of % exceedance to calculate PE target. Mar-April do not use BF targets at Jensen. <br><br>CF,20181010: for FG update adding in baseflow targets for Jensen to GetFGBaseFlowMagnitudeUnconstrained<br><br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "MonthIs"( { "January" , "February" } ) )
 THEN
  "Max"( "TargetHWGivenInflow"( % "FlamingGorge", @"t", @"24:00:00 April Max DayOfMonth, Current Year", "GetMay1TargetElevation"(  ) COMMENTED_BY "CF: This has been changed to a hydrologic year classification calculated target as per HP. <br>Previously was a static target. <br>", "PredictedFGInflow"( @"t", @"24:00:00 April Max DayOfMonth, Current Year" ) - "EstimateEvaporation"( % "FlamingGorge", $ "FlamingGorge.Storage" [@"t - 1"], "ElevationToStorage"( % "FlamingGorge", "GetMay1TargetElevation"(  ) ), @"t", @"24:00:00 April Max DayOfMonth, Current Year" ), $ "FlamingGorge.Storage" [@"t - 1"] ) COMMENTED_BY "CF, 20190107: Changed to use Evap. <br>", "Max"( ( $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 2.00000000] - $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"t"] ) COMMENTED_BY "CF: This ensures FG baseflow will be sufficient to meet the lower baseflow limit set for the Green <br>at Jensen by the EIS. The flow at Jensen is the FG baseflow plus the predicted Yampa flow. <br>", $ "FlamingGorgeData.MinFlow" [] ) )
 ELSE
  IF ( "MonthIs"( { "March" } ) )
  THEN
   "Max"( "TargetHWGivenInflow"( % "FlamingGorge", @"t", @"24:00:00 April Max DayOfMonth, Current Year", "GetMay1TargetElevation"(  ) COMMENTED_BY "CF: This has been changed to a hydrologic year classification calculated target as per HP. <br>Previously was a static target. <br>", ( "PredictedFGInflow"( @"t", @"24:00:00 April Max DayOfMonth, Current Year" ) - "EstimateEvaporation"( % "FlamingGorge", $ "FlamingGorge.Storage" [@"t - 1"], "ElevationToStorage"( % "FlamingGorge", "GetMay1TargetElevation"(  ) ), @"t", @"24:00:00 April Max DayOfMonth, Current Year" ) ) COMMENTED_BY "CF: MTOM's unregulated inflow accounts for the evaporation and upstream delta storage <br>therefore it does not need to include EstimateEvaporation like CRSS. <br>", $ "FlamingGorge.Storage" [@"t - 1"] ) COMMENTED_BY "CF, 20190107: Changed to use Evap. <br>", $ "FlamingGorgeData.MinFlow" [] )
  ELSE
   IF ( "MonthIs"( { "April" } ) COMMENTED_BY "CF:April, this include Evap in fct. The EIS has no Jensen targets in March and April, in these <br>months release are used to meet the UDLE.   <br>" )
   THEN
    "Max"( "TargetHWGivenInflowOneMonth"( % "FlamingGorge", @"t", @"24:00:00 April Max DayOfMonth, Current Year", "GetMay1TargetElevation"(  ) COMMENTED_BY "CF: This has been changed to a hydrologic year classification calculated target as per HP. <br>Previously was a static target. <br>", "PredictedFGInflow"( @"t", @"24:00:00 April Max DayOfMonth, Current Year" ) - "EstimateEvaporation"( % "FlamingGorge", $ "FlamingGorge.Storage" [@"t - 1"], "ElevationToStorage"( % "FlamingGorge", "GetMay1TargetElevation"(  ) ), @"t", @"24:00:00 April Max DayOfMonth, Current Year" ), $ "FlamingGorge.Storage" [@"t - 1"] ) COMMENTED_BY "CF, 20190107: Changed to use Evap. <br>", $ "FlamingGorgeData.MinFlow" [] )
   ELSE
    "Max"( "TargetHWGivenInflow"( % "FlamingGorge", @"t", @"24:00:00 April Max DayOfMonth, Next Year", $ "FlamingGorgeData.May1TargetElevation" [3.00000000, 2.00000000] COMMENTED_BY "CF: This is the May 1 drawdown level of 6027ft. In Aug - Dec this the the target elevation from <br>the to EIS. This is the target until Jan when the hydrologic year classification can be calculated.   <br>", "PredictedFGInflow"( @"t", @"24:00:00 April Max DayOfMonth, Next Year" ) - IF ( @"24:00:00 April Max DayOfMonth, Next Year" < "RunEndDate"(  ) )
    THEN
     "EstimateEvaporation"( % "FlamingGorge", $ "FlamingGorge.Storage" [@"t - 1"], "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.May1TargetElevation" [3.00000000, 2.00000000] ), @"t", @"24:00:00 April Max DayOfMonth, Next Year" )
    ELSE
     "EstimateEvaporation"( % "FlamingGorge", $ "FlamingGorge.Storage" [@"t - 1"], "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.May1TargetElevation" [3.00000000, 2.00000000] ), "OffsetDate"( @"t", - 1.00000000, "1 Years" ), "OffsetDate"( @"24:00:00 April Max DayOfMonth, Next Year", - 1.00000000, "1 Years" ) )
    ENDIF, $ "FlamingGorge.Storage" [@"t - 1"] ), "Max"( ( $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 2.00000000] - $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"t"] ) COMMENTED_BY "CF: This ensures FG baseflow will be sufficient to meet the lower baseflow limit set for the Green <br>at Jensen by the EIS. The flow at Jensen is the FG baseflow plus the predicted Yampa flow.  <br>", $ "FlamingGorgeData.MinFlow" [] ) ) COMMENTED_BY "CF: May-Dec assume static target of 6027 for May 1, Next Year.  <br>"
   ENDIF
  ENDIF COMMENTED_BY "CF: The EIS has no Jensen targets in March and April, in these months release are used to meet <br>the UDLE.  <br>"
 ENDIF COMMENTED_BY "CF: Jan-Feb use GetMay1Target based on exceedance.   <br>";

    END
    UUID "{6f2b32c3-90d7-4ce0-9071-5d0f1efde20e}";;

    FUNCTION       "GetMay1TargetElevation" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns the May 1 target pool elevation based on the percent exceedance value of the Apr-Jul inflow forecast<br><br>RETURNS: Target May 1 pool elevation for Flaming Gorge [L]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      $ "FlamingGorgeData.May1TargetElevation" [IF ( ( WHILE ( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] * 100.00000000 < $ "FlamingGorgeData.May1TargetElevation" [result, 1.00000000] AND result <= 2.00000000 ) WITH NUMERIC result = 0.00000000 DO
  result + 1.00000000
 ENDWHILE == 0.00000000 ) COMMENTED_BY "Cycle through indices and if exceedance percentage is greater than all in table, return index of 0; target elevation will be 6,027 ft" )
 THEN
  0.00000000
 ELSE
  WHILE ( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] * 100.00000000 < $ "FlamingGorgeData.May1TargetElevation" [result, 1.00000000] AND result <= 2.00000000 ) WITH NUMERIC result = 0.00000000 DO
   result + 1.00000000
  ENDWHILE COMMENTED_BY "Cycle through indices and return index for which exceedance percentage is between lower and upper limit" - 1.00000000
 ENDIF COMMENTED_BY "Find index in May1TargetElevation corresponding to appropriate exceedance level of forecast", 2.00000000];

    END
    UUID "{feedee48-9aeb-4d64-8cb9-be26add46c0c}";;

    FUNCTION       "GetNumberOfDaysAtPPC" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function bounds the days at power plant capacity to within the limts for the current hydrologic classification<br><br>RETURNS: Number of days to release at power plant capacity [T]<br><br>ARGUMENTS<br>1. NUMERIC Class<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: CE 6/12/13";
    BEGIN

      WITH NUMERIC DaysAtPPC = "GetNumberOfDaysAtPPCUnconstrained"( Class ) DO
  IF ( DaysAtPPC < $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000] )
  THEN
   $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000]
  ELSE
   IF ( DaysAtPPC > $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000] )
   THEN
    $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000]
   ELSE
    DaysAtPPC
   ENDIF
  ENDIF
 ENDWITH COMMENTED_BY "Ensure that the days at power plant capacity fall within the limits of the current hydrologic classification";

    END
    UUID "{21eb232d-9177-47b3-a484-01d665af02f5}";;

    FUNCTION       "GetNumberOfDaysAtPPCUnconstrained" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Interpolates the number of days to have the powerplant at capacity for the current hydrologic classification based on the current exceedance percentile for the Yampa April through July volume<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS<br>1. NUMERIC Class - Annual hydrologic class<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      "Interpolate"( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 0.00000000], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000] );

    END
    UUID "{bdc0a049-8ffd-445b-bf51-d0cfc7ef7d7b}";;

    FUNCTION       "NumberOfMonthsUntilMay" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the number of months remaining to make releases to meet the May 1 Upper Limit Drawdown Elevation (ULDE) on Flaming Gorge reservoir. This is called by the Flaming Gorge baseflow operations. -HG 9/12/12<br><br>RETURNS: Number of months until next May [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: HG, 9/12/12";
    BEGIN

      IF ( "GetMonth"( @"t" ) >= 5.00000000 )
 THEN
  ( 12.00000000 - "GetMonth"( @"t - 1" ) + 4.00000000 ) COMMENTED_BY "For May through December.<br>Calculate the remaining months of current year (current month - Dec.)<br>Add the first four months of next year (Jan.- Apr.).<br>"
 ELSE
  ( 5.00000000 - "GetMonth"( @"t" ) ) COMMENTED_BY "For January through April.<br>Calculate the remaining months to make releases before May 1, <br>includes the current month."
 ENDIF;

    END
    UUID "{522bddc7-b363-4587-80a9-b8141665e8dd}";;

    FUNCTION       "PredictedFGInflow" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total inflow volume between the dates specified as arguments<br><br>RETURNS: Inflow volume to Flaming Gorge [L^3]<br><br>CF: ForecastData.FlamingGorgeInflow is set by Fontenelle rule ForecastFutureFGInflow-total average. This is the 50% Exceedance.  <br><br>ARGUMENTS<br>1. DATETIME startDate - beginning date of period for sum<br>2. DATETIME endDate - ending date of period for sum<br><br>CONSTRAINTS<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      IF ( endDate > @"Finish Timestep" )
 THEN
  "SumFlowsToVolume"( $ "FlamingGorge.Inflow", startDate, @"Finish Timestep" ) + "SumFlowsToVolume"( $ "FlamingGorgeData.ProjectedInflow", @"Finish Timestep + 1", endDate )
 ELSE
  "SumFlowsToVolume"( $ "FlamingGorge.Inflow", startDate, endDate )
 ENDIF;

    END
    UUID "{75bcf33a-a62f-4808-844a-f985f8f9762c}";;

    FUNCTION       "PredictedYampaFlow" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total inflow volume between the dates specified as arguments<br><br>RETURNS: Inflow volume to Yampa at Deerlodge [L^3]<br><br>ARGUMENTS<br>1. DATETIME startDate - beginning date of period for sum<br>2. DATETIME endDate - ending date of period for sum<br><br>CONSTRAINTS<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF,20181012: Else statement added to deal with when at the end of a run and no yampa data<br><br>AUTHOR, DATE: CF,20181010 for FG update adding in baseflow targets for Jensen to GetFGBaseFlowMagnitudeUnconstrained<br>";
    BEGIN

      IF ( endDate < "RunEndDate"(  ) )
 THEN
  "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", startDate, endDate )
 ELSE
  "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Previous Year", @"24:00:00 April Max DayOfMonth, Current Year" ) COMMENTED_BY "CF: This could be improved to take what is between @t - run end date + portion of previous <br>years spring but I don't know how to impliment the time so it finds what month the run end date is <br>and looks back for the previous years that month (would sometimes be current year).  <br>"
 ENDIF;

    END
    UUID "{1aa73f2c-5690-4ea5-89d9-6877a6e64bd5}";;

    FUNCTION       "FGSpringReleaseStartDate" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguments: None<br><br>Description: This function determines FG spring release date based on Yampa peak magnitude and historic julian day larval razorback sucker emergence. <br><br>Formula Ax^2+Bx+C where x = $ FlamingGorgeEIS.YampaPeakDailyFlow.<br><br>Returns: Date";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF, 20181010: Use reference to new LTSPRegressionCoefficients table slot. <br><br>HP, 20170714<br><br>";
    BEGIN

      @"24:00:00 January 1, Current Year" + ( $ "FlamingGorgeData.LTSPRegressionCoefficients" [0.00000000, "A"] * ( $ "KNN_MTOM.YampaPeakDailyFlow" [@"24:00:00 December 31, Current Year"] ^ 2.00000000 / 1.00000000 "cfs^2" ) - $ "FlamingGorgeData.LTSPRegressionCoefficients" [0.00000000, "B"] * ( $ "KNN_MTOM.YampaPeakDailyFlow" [@"24:00:00 December 31, Current Year"] / 1.00000000 "cfs" ) + $ "FlamingGorgeData.LTSPRegressionCoefficients" [0.00000000, "C"] ) * 1.00000000 "day";

    END
    UUID "{8ca2784d-46cd-457b-8938-96b8aaff208b}";;

    FUNCTION       "RoundToNearestDay" ( NUMERIC numDays )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the rounded value of the specified argument &quot;numDays&quot;. If the fractional part of numDays is < 0.5 the value is rounded down; otherwise, the value is rounded up.<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS:<br>1. NUMERIC numDays<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "Fraction"( numDays, 1.00000000 "day" ) >= 0.50000000 "day" )
 THEN
  "Ceiling"( numDays, 1.00000000 "day" )
 ELSE
  "Floor"( numDays, 1.00000000 "day" )
 ENDIF;

    END
    UUID "{406f541c-6ba5-4fc4-9484-8969737f3baf}";;

    FUNCTION       "YampaDaysAbove14000" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the number of days that the Yampa River will be above 14000 cfs. If the Yampa April to July volume is greater than the bypass threshold then the number of days above 14000 cfs is determined with a linear regression equation based on data for the historical period 1923-2006. For volumes less than the bypass threshold the number of days above 14000 cfs is zero. -CE 6/12/13<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS:<NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170315 - The description on this function is the same as the one for the function YampaDaysAbove14000Old, which uses regression; however, this version does not use regression";
    BEGIN

      "CountDaysAboveThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ), 14000.00000000 "cfs" );

    END
    UUID "{ebe528f9-34e4-450e-9fd9-c8493c7436d9}";;

    FUNCTION       "FindYampaPeakDateForYear" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function finds the date of the Yampa peak flow within the period April through July of the current year<br><br>RETURNS: Date of the Yampa April-July peak flow [DATETIME]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170503: Function simplified by removing 3 unused local variable WITH statements";
    BEGIN

      WITH NUMERIC yampaPeak = "MaxItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) ) DO
  GET @INDEX FIND yampaPeak WITHIN "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) FROM "GetDates"( @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year", "1 days" )
 ENDWITH;

    END
    UUID "{f8e4c1db-17aa-4f9e-b322-b270dc71f42c}";;

    FUNCTION       "FindYampa10kcfsBypassDateForYear" ( DATETIME YampaPeakDate )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the date to bypass if the Yampa River flows are at 10,000 cfs for the length of time necessary to meet flow targets.<br><br>RETURNS: Date to begin ramp up to bypass [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME YampaPeakDate - date of the Yampa peak flow (from function FindYampaPeakDateForYear)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170503: Numeric input argument BypassDays removed because it was not used";
    BEGIN

      WITH LIST flowList = "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) DO
  WITH NUMERIC DaysAbv10k = "CountDaysAboveThreshold"( flowList, 10000.00000000 "cfs" ) DO
   WITH NUMERIC DaysToRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.BypassCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" ) ) / 1.00000000 "day" + 2.00000000 DO
    WITH NUMERIC DaysToPeak = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
     IF ( $ "KNN_MTOM.SpringHClass" [] < 4.00000000 AND $ "KNN_MTOM.SpringHClass" [] > 0.00000000 )
     THEN
      IF ( ( DaysAbv10k >= $ "KNN_MTOM.YampaDaysAbove10000ForBypass" [$ "KNN_MTOM.SpringHClass" [], 0.00000000] OR ( $ "KNN_MTOM.SpringHClass" [] == 2.00000000 AND DaysAbv10k > 3.00000000 "day" ) ) COMMENTED_BY "Will bypass if Yampa River flows are above 10,000 cfs for days necessary to meet flow targets in all hydrologic classifications or<br>in average years if Yampa River above 10,000 cfs for 3 days in order to meet 18,600 cfs target 50% of the time." )
      THEN
       WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
        IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( DaysToPeak - length - 1.00000000 == - 1.00000000 )
        THEN
         0.00000000
        ELSE
         DaysToPeak - length - 1.00000000
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
        THEN
         DaysToPeak - length
        ELSE
         result
        ENDIF
       ENDFOR COMMENTED_BY "If the Yampa River is above 10,000 cfs for enough days to meet flow targets then this calculation determines the peak date of the Yampa River <br>and returns the first date that the Yampa River reaches 10,000 cfs before the peak date." DO
        GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
        THEN
         0.00000000
        ELSE
         DateIndex - DaysToRamp
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
       ENDWITH
      ELSE
       WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
        IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( DaysToPeak - length - 1.00000000 == - 1.00000000 )
        THEN
         0.00000000
        ELSE
         DaysToPeak - length - 1.00000000
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
        THEN
         DaysToPeak - length
        ELSE
         result
        ENDIF
       ENDFOR DO
        GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
        THEN
         0.00000000
        ELSE
         DateIndex - DaysToRamp
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
       ENDWITH
      ENDIF
     ELSE
      "DateMax"( WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
       IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( DaysToPeak - length - 1.00000000 == - 1.00000000 )
       THEN
        0.00000000
       ELSE
        DaysToPeak - length - 1.00000000
       ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
       THEN
        DaysToPeak - length
       ELSE
        result
       ENDIF
      ENDFOR DO
       GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
       THEN
        0.00000000
       ELSE
        DateIndex - DaysToRamp
       ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
      ENDWITH, @"24:00:00 April 2, Current Year" ) COMMENTED_BY "Returns the maximum of April 2 or the first day that the Yampa River is above 10,000 cfs so the April-July function works."
     ENDIF
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "Counts Yampa River flow days above 10,000 cfs to determine if flow targets can be met."
 ENDWITH COMMENTED_BY "Determines the date to bypass if the Yampa River flows are at 10,000 cfs for the length of time necessary to meet flow targets. ";

    END
    UUID "{d92401c9-eb1a-4816-893e-2dd2372dd6d9}";;

    FUNCTION       "DaysAboveThreshold" ( LIST dailyFlows, NUMERIC flowThreshold )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function counts the number of flow values in the argument list &quot;dailyFlows&quot; that exceed the value of the argument &quot;flowThreshold&quot;<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS:<br>1. LIST dailyFlows - list of daily flow rates<br>2. NUMERIC flowThreshold - threshold flow rate<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC flow IN dailyFlows ) WITH NUMERIC result = 0.00000000 "day" DO
  IF ( flow > flowThreshold )
  THEN
   1.00000000 "day"
  ELSE
   0.00000000 "day"
  ENDIF + result
 ENDFOR;

    END
    UUID "{4e18f5a6-6aca-43d9-9a09-f514e07b392c}";;

    FUNCTION       "FindYampa14kcfsPPCDateForYear" ( NUMERIC PPCDays, DATETIME YampaPeakDate )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the date to increase the Flaming Gorge release to the powerplant capacity (PPC) if the Yampa River flows are at 14,000 cfs for the length of time necessary to meet flow targets.<br><br>RETURNS: Date to increase release rate [DATETIME]<br><br>ARGUMENTS:<br>1. NUMERIC PPCDays - the number of days that Flaming Gorge will release at powerplant capacity<br>2. DATETIME YampaPeakDate - date of the Yampa peak flow (from function FindYampaPeakDateForYear)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST flowList = "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) DO
  WITH NUMERIC DaysAbv14k = "DaysAboveThreshold"( flowList, 14000.00000000 "cfs" ) COMMENTED_BY "Counts Yampa River flows above 14,000 cfs to determine if flow targets can be met." DO
   WITH NUMERIC DaysToRamp = "RoundToNearestDay"( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" ) ) / 1.00000000 "day" + 1.00000000 DO
    WITH NUMERIC DaysToPeak = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
     IF ( $ "KNN_MTOM.SpringHClass" [] < 4.00000000 AND $ "KNN_MTOM.SpringHClass" [] > 0.00000000 )
     THEN
      IF ( DaysAbv14k >= $ "KNN_MTOM.YampaDaysAbove14000ForPPC" [$ "KNN_MTOM.SpringHClass" [], 0.00000000] )
      THEN
       WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
        IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 14000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX DaysToPeak - length - 1.00000000 FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 14000.00000000 "cfs" ) < 1.00000000 "day" )
        THEN
         DaysToPeak - length
        ELSE
         result
        ENDIF
       ENDFOR DO
        GET @INDEX DateIndex - DaysToRamp FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
       ENDWITH COMMENTED_BY "Finds the date closest to the Yampa River peak flow date that flows are 14,000 cfs in order to begin ramp up to PPC."
      ELSE
       ( YampaPeakDate - PPCDays / 2.00000000 ) COMMENTED_BY "FG has a spring peak every year and flow targets below 18,600 cfs.  This returns the date closest to the Yampa River peak <br>with half of the PPC days determined for flow targets being met in all hydrologic classifications. "
      ENDIF
     ELSE
      ( YampaPeakDate - PPCDays * 0.75000000 ) COMMENTED_BY "FG has a spring peak every year and flow targets below 18,600 cfs.  This returns the date closest to the Yampa River peak with the PPC days determined<br>for flow targets being met in all hydrologic classifications. This returns 75% of the PPC days so that ramping to PPC occurs closer to the Yampa River peak in dry years.  <br>The wet year hydrologic classification is usually targeted using the bypass functions."
     ENDIF
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Determines the date to increase to PPC if the Yampa River flows are at 14,000 cfs for the length of time necessary to meet flow targets.";

    END
    UUID "{ddfc86b8-1353-4676-bd90-246bb1ee873c}";;

    FUNCTION       "CountDaysAboveThreshold" ( LIST Flows, NUMERIC MinFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a count of the number of values in the list &quot;Flows&quot; that are greater than the value of &quot;MinFlow&quot;<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS<br>1. LIST Flows - list of flow rates<br>2. NUMERIC MinFlow - threshold flow rate<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC flow IN Flows ) WITH NUMERIC result = 0.00000000 "day" DO
  IF ( flow >= MinFlow )
  THEN
   result + 1.00000000 "day"
  ELSE
   result
  ENDIF
 ENDFOR;

    END
    UUID "{c5bb171f-5cee-4f80-8aa8-fecb203365b7}";;

    FUNCTION       "CountDaysBelowThreshold" ( LIST Flows, NUMERIC MinFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a count of the number of values in the input argument list &quot;Flows&quot; that are less than the value of the input argument &quot;MinFlow&quot;<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS<br>1. LIST Flows - list of flow rates<br>2. NUMERIC MinFlow - threshold flow rate<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC flow IN Flows ) WITH NUMERIC result = 0.00000000 "day" DO
  IF ( MinFlow >= flow )
  THEN
   result + 1.00000000 "day"
  ELSE
   result
  ENDIF
 ENDFOR;

    END
    UUID "{1dc07d49-51ee-46ae-996d-038455ea581a}";;

    FUNCTION       "AugustDownRamp" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: None<br><br>Description: Create a list for August flows whether downramping from bypass flows or not. When bypass releases extend through the entire A-J period to July 31st, this function downramps to base flows in August.<br><br>Returns: List of August flows. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF,20200104: TargetHWGivenInflowOneMonth() replaced by FGTargetHWGivenInflowOneMonth()<br><br>20191018, CF: The August rule considers if down ramping needs to occur or not. If it does then AugustDownRamp() is called which has a provision that sets the outflow required to avoid MaxPE but only after downramping has occurred. This was modified to have daily outflow to avoid MaxPE checked for to all days in August (regardless of where FG is in the down ramp). Additionally add GetFGBaseFlowMagnitude() to Aug1 max check. If down ramping does not need to occur in August than the rule set daily outflow equal to the baseflow. This was modified to have a max avoid MaxPE check. I've <br><br>CF 20190125: Updated to use TargetHWGivenInflowOneMonth";
    BEGIN

      WITH NUMERIC RampRate = $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"24:00:00 April Max DayOfMonth, Current Year"], 0.00000000] * 1.00000000 "cfs" DO
  WITH NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] - $ "FlamingGorge.Outflow" [] ) / RampRate * 1.00000000 "day" ) COMMENTED_BY "Number of days needed to downramp from July 31st bypass release to August base flow." DO
   WITH LIST DateList = "GetDates"( @"24:00:00 August 1, Current Year", @"24:00:00 August 31, Current Year", "1 days" ) DO
    WITH LIST FlowList = FOR ( DATETIME date IN DateList ) WITH LIST Augflows = {  } DO
     WITH NUMERIC i = ( date - @"24:00:00 August 1, Current Year" ) / 1.00000000 "day" DO
      APPEND IF ( date == @"24:00:00 August 1, Current Year" )
      THEN
       "MaxItem"( { ( $ "KNN_MTOM.FlamingGorgeDaily" COMMENTED_BY "CF: CRSS slot $ &quot;DailyFlows.FlamingGorgeDaily&quot;  <br>" [@"24:00:00 July Max DayOfMonth, Current Year"] - RampRate ) , "GetFGBaseFlowMagnitude"(  ) , "TargetHWGivenInflowOneMonth"( % "FlamingGorge", @"t - 1", @"t", $ "FlamingGorgeData.MaxPE" [] COMMENTED_BY "CF: Prv fct (TargetHWGivenInflowforOneMonth) just took in Elevation but this matches <br>TargetHW arguements and is more explicit.   <br>", "FlowToVolume"( $ "FlamingGorge.Inflow" COMMENTED_BY "CF: CRSS slot ForecastData.FlamingGorgeInflow <br>" [], @"t" ) COMMENTED_BY "CF: MTOM's unregulated inflow accounts for the evaporation and upstream delta storage <br>therefore it does not need to include EstimateEvaporation like CRSS. <br>", $ "FlamingGorge.Storage" [@"t - 1"] ) } )
      ELSE
       IF ( date <= @"24:00:00 August 1, Current Year" + DaysToDownRamp )
       THEN
        "MaxItem"( { ( GET @INDEX i - 1.00000000 FROM Augflows ) - "KNN_MTOM.BaseFlowDownrampRateNoUnits" COMMENTED_BY "CF: CRSS slot ForecastData.FlamingGorgeInflow <br>" [$ "KNN_MTOM.BaseFlowHClass" COMMENTED_BY "CF: CRSS slot different <br>" [@"24:00:00 April 30, Current Year"], 0.00000000] * 1.00000000 "cfs" , "GetFGBaseFlowMagnitude"(  ) , "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) } ) COMMENTED_BY "Downramping."
       ELSE
        "Max"( "Max"( ( GET @INDEX i - 1.00000000 FROM Augflows ), "GetFGBaseFlowMagnitude"(  ) ), "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) ) COMMENTED_BY "No downramping needed, the list generates August base flows or flows<br>necessary to maintain max PE.<br>CF: Added logic to maintain max PE here. "
       ENDIF
      ENDIF ONTO Augflows
     ENDWITH
    ENDFOR COMMENTED_BY "Create a list for August flows whether downramping from bypass flows or not." DO
     FOR ( DATETIME date IN DateList ) WITH LIST DateFlowList = {  } DO
      APPEND { date , GET @INDEX ( date - @"24:00:00 August 1, Current Year" ) / 1.00000000 "day" FROM FlowList } ONTO DateFlowList
     ENDFOR
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{2a691ba0-1d22-4888-a1a2-22c854c18a03}";;

    FUNCTION       "SpringFlowA-JVolumeUpdate" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the April through July unregulated inflow volume for Flaming Gorge<br><br>RETURNS: Unregulated inflow volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "MonthIs"( { "January" , "February" , "March" } ) )
 THEN
  ( ( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) / "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) * "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Before April, the April-July volume forecast is calculated as the average volume for that period multiplied by the ratio of the current year's forecast volume <br>from the current month through April to the average for the same period."
 ELSE
  "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) COMMENTED_BY "Otherwise, use the April through July forecast and/or actual flows"
 ENDIF;

    END
    UUID "{a2adea20-7d12-45a9-a08e-4e43104dd205}";;

    FUNCTION       "BaseFlowA-JVolumeUpdate" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates an estimated or actual unregulated inflow volume for the period April through July at Flaming Gorge<br><br>RETURNS: Unregulated inflow volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20160913: I don't see how March or May targets are reflected in this function, are they considered elsewhere? That inline comment precedes this documentation.<br>MC, 20170503: August used the same calculation as April-July so I removed its separate IF conditional and just let it calculate under the final ELSE; changed the position of the denominators in the calculations to better reflect how the factor is being calculated as a ratio of average unregulated flows for different periods (not sure it's any clearer, though)";
    BEGIN

      IF ( "MonthIs"( { "January" , "February" , "March" } ) )
 THEN
  ( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) * ( "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) / "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) ) COMMENTED_BY "January through April flows change depending on actual inflow, the forecasted unreg inflow and meeting March or May 1 elevation target.<br>Forecast volume is calculated as the sum of the current year's monthly forecast flows from the current month through April multiplied by the <br>ratio of the average April-July flow to the average flow for the current period."
 ELSE
  IF ( "MonthIs"( { "September" , "October" , "November" , "December" } ) )
  THEN
   "Max"( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"t - 1", @"t - 1" ) * ( "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Next Year", @"24:00:00 July Max DayOfMonth, Next Year" ) / $ "KNN_MTOM.FGAverageUnregInflow" [@"t - 1"] ), 0.00000000 "acre-ft" )
  ELSE
   "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) COMMENTED_BY "April, May, June, July, August"
  ENDIF COMMENTED_BY "The months of September through December look at actual flows coming into the system and react if necessary to meet the March 1 elevation target."
 ENDIF;

    END
    UUID "{67627ffd-9dfc-427c-8af2-9fcdeca2403f}";;

    FUNCTION       "MakeDailyFlamingGorgeReleaseDateandFlowList_LTSP" ( DATETIME startdate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "HP, 20170714<br><br>Arguments: <br>     Startdate between April-July<br>     2nd Disagg Yampa Flows<br>     FG Spring Release Start Date<br><br>Description:<br>    This function is the powerhouse for FG daily disaggregation and calculates the ramp rates, number of days at powerplant capacity, number of days at bypass, and timing of the spring peak. The LTSP timing uses a function that estimates larval razorback sucker based on Yampa peak magnitude and historic julian days to larval presence. The ramp down takes into account Reach 2 Jensen flows and calculates target flows accordingly. <br><br>Returns:<br>     Daily FG hydrograph in cfs for the April-July period.<br>     	";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF 20190125: Updated to use TargetHWGivenInflowOneMonth<br><br>HP, 20170714";
    BEGIN

      WITH LIST DateList = "GetDates"( @"24:00:00 April 1, Current Year", @"t" COMMENTED_BY "Only calculates daily schedule to the end of the current month for computation efficiency.", "1 days" ) DO
  WITH LIST FlowList = WITH DATETIME YampaPeakDate = IF ( TRUE )
  THEN
   "FindYampaPeakDateForYear"(  )
  ELSE
   @"24:00:00 May 27, Current Year"
  ENDIF COMMENTED_BY "Finds the Yampa peak flow date for this year, change if to FALSE to use May 27 which matches it with the dates that the expression slot was using..." DO
   WITH NUMERIC DaysAtPPC = "Max"( "RoundToNearestDay"( "GetNumberOfDaysAtPPC"( $ "KNN_MTOM.SpringHClass" COMMENTED_BY "CF: CRSS slot $ &quot;DailyFlows.FlamingGorgeDaily&quot; <br>" [@"t"] ) ), 1.00000000 "day" ) COMMENTED_BY "Calculate number of days that Flaming Gorge will release Power Plant Capacity (PPC), with a minimum of 1 day at PPC to meet flow recommendation, I am unsure about the minimum days in really dry years, but am using 1 for now..." DO
    WITH NUMERIC RampUpDaysToPPC = "RoundToNearestDay"( "Max"( IF ( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) <= $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" )
    THEN
     0.00000000 "day"
    ELSE
     ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" )
    ENDIF, 0.00000000 "day" ) ) COMMENTED_BY "Calculate the number of days that the flow will have to ramp to reach the PPC, or sets it to 0 if it can reach it in one jump." DO
     WITH NUMERIC RampUpToPPCRate = ( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( ( RampUpDaysToPPC / 1.00000000 "day" ) + 1.00000000 ) ) COMMENTED_BY "Calculate the up ramping rate depending on the number of days so that it evenly ramps up to PPC over those days. Will not exceed the up ramp rate limit (2000 cfs)." DO
      WITH NUMERIC RampUpDaysToBypass = "RoundToNearestDay"( "Max"( IF ( ( $ "KNN_MTOM.BypassCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) <= $ "KNN_MTOM.RampUpRateNoUnits" COMMENTED_BY "CF: CRSS slot $ &quot;FlamingGorgeData.RampUpRateNoUnits&quot; <br>" [] * 1.00000000 "cfs" )
      THEN
       0.00000000 "day"
      ELSE
       ( $ "KNN_MTOM.BypassCapacity" COMMENTED_BY "CF: CRSS slot $ &quot;FlamingGorgeData.BypassCapacity&quot; <br>" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" )
      ENDIF, 0.00000000 "day" ) ) DO
       WITH NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - 2700.00000000 "cfs" ) / ( $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs" ) * 1.00000000 "day" ) DO
        WITH NUMERIC DaysAtBypass = "RoundToNearestDay"( "GetDaysAtBypass"( $ "KNN_MTOM.SpringHClass" [] ) COMMENTED_BY "CF: CRSS uses GetNumberOfDaysAtBypass() instead. <br>" ) DO
         WITH DATETIME FGSpringReleaseStartDate = "DateMax"( "DateMin"( "FGSpringReleaseStartDate"(  ), @"24:00:00 August 2, Current Year" - ( DaysAtPPC + RampUpDaysToPPC + DaysToDownRamp + DaysAtBypass / 2.00000000 ) COMMENTED_BY "Estimate total spring flow days...<br>" ), @"24:00:00 April 2, Current Year" ) COMMENTED_BY "Start ramping up using LTSP polynomial, but Apr 2 as a minimum to avoid breaking, and start early <br>enough to end by July 31" DO
          FOR ( DATETIME date IN DateList ) WITH LIST flows = {  } DO
           WITH NUMERIC i = ( date - @"24:00:00 April 1, Current Year" ) / 1.00000000 "day" DO
            APPEND IF ( date < startdate )
            THEN
             IF ( IsNaN $ "KNN_MTOM.FlamingGorgeDaily" [date] )
             THEN
              $ "FlamingGorge.Outflow" [@"t - 1"]
             ELSE
              $ "KNN_MTOM.FlamingGorgeDaily" [date]
             ENDIF COMMENTED_BY "CF: Change to use Outflow @ t-1 if Flaming Gorge Daily has not been calculated.   <br>"
            ELSE
             IF ( ( date < FGSpringReleaseStartDate ) COMMENTED_BY "Before Spring Releases start continue at base flows for the ULDE in March and April that will meet ULDE on May 1" )
             THEN
              $ "FlamingGorge.Outflow" [@"t - 1"] COMMENTED_BY "CF: Change from a IF April use Outflow[@March&rcub; Else Outflow[@April]  <br>"
             ELSE
              IF ( ( date < FGSpringReleaseStartDate + RampUpDaysToPPC ) COMMENTED_BY "Ramping period up to Flaming Gorge PPC Release (or max release if below PPC)" )
              THEN
               "Min"( ( GET @INDEX i - 1.00000000 FROM flows ) + RampUpToPPCRate, "MaxItem"( { $ "FlamingGorgeData.PowerPlantCapacity" [] , "CheckJensen"(  ) , "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) } ) COMMENTED_BY "Release PPC or volume necessary to stay below max PE. Also Check Jensen. <br>" )
              ELSE
               IF ( "CountDaysAboveThreshold"( flows, $ "KNN_MTOM.BypassCapacity" [] ) < DaysAtBypass )
               THEN
                "Min"( ( GET @INDEX i - 1.00000000 FROM flows ) + $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs", "MaxItem"( { $ "KNN_MTOM.BypassCapacity" [] , "CheckJensen"(  ) , "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) } ) COMMENTED_BY "Release bypass capacity or volume necessary to stay below max PE. Also check Jensen. <br>" ) COMMENTED_BY "Ramps up and continues at Bypass Cap until it has been at Bypass Cap for enough days"
               ELSE
                IF ( "CountDaysAboveThreshold"( flows, $ "FlamingGorgeData.PowerPlantCapacity" [] ) < DaysAtPPC )
                THEN
                 "Max"( ( GET @INDEX i - 1.00000000 FROM flows ) - $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs", "Max"( $ "FlamingGorgeData.PowerPlantCapacity" [], "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) ) COMMENTED_BY "Downramps to base flows unless inflows will increase FG above max PE.<br>Releases volume necessary to stay below max PE." ) COMMENTED_BY "Ramps down from bypass (if it was there) then continues at PPC until it has been above PPC for enough days"
                ELSE
                 "Max"( ( GET @INDEX i - 1.00000000 FROM flows ) - $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" COMMENTED_BY "CF: CRSS slot $ &quot;FlamingGorgeData.BaseFlowMagnitudeLimits&quot; <br>" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs", "MaxItem"( { "GetFGBaseFlowMagnitude"(  ) COMMENTED_BY "CF: GetFGBaseFlowMagnitude() was missing from IF after downramp statement. Fixed.    <br>" , "CheckJensen"(  ) , "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) } ) COMMENTED_BY "Releases base flows or volume necessary to stay below max PE.Also check Jensen. <br>" ) COMMENTED_BY "Ramps down from PPC and then continues at the new base flow which is newly calculated each month"
                ENDIF
               ENDIF
              ENDIF
             ENDIF
            ENDIF ONTO flows
           ENDWITH
          ENDFOR
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH DO
   FOR ( DATETIME date IN DateList ) WITH LIST DateFlowList = {  } DO
    APPEND { date , GET @INDEX ( date - @"24:00:00 April 1, Current Year" ) / 1.00000000 "day" FROM FlowList } ONTO DateFlowList
   ENDFOR COMMENTED_BY "This links together the date and flow in a list of 2 item lists..... e.g., &lcub;...,(5/1/12, 1200 cfs), (5/2/12, 1300 cfs), etc...&rcub;"
  ENDWITH
 ENDWITH;

    END
    UUID "{1a13f595-2959-4baf-8537-ab64e450a548}";;

    FUNCTION       "TargetHWGivenInflowOneMonth" ( OBJECT Res, DATETIME TargetBeginDate, DATETIME TargetEndDate, NUMERIC TargetPE, NUMERIC TotalInflow, NUMERIC PrvStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "ARGUMENTS<br>1. OBJECT Res<br>2. DATETIME TargetBeginDate, first timestep for flow calculation<br>3.DATETIME TargetEndDate, last timestep<br>3.NUMERIC TargetPE, PE to achieve at TargetEndDate<br>5. NUMERIC TotalInflow - Total inflow occuring between TargetBeginDate and TargetEndDate. Passed as argument to allow use of functions rather than Slot.Inflow<br><br>DESCRIPTION: This function returns the release for the current month to attain the specified pool elevation value, &quot;TargetPE&quot;, at &quot;TargetEndDate&quot; based on a water balance using &quot;TotalInflow&quot; and evaporation. Can handle one timestep periods (Begin = End) or longer. This is meant to be a generic version of the predefined function targetHWgiveninflow.<br><br>RETURNS: Monthly outflow rate [L^3/T]<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF,20190109: New mass balance function called by GetFGBaseFlowMagnitudeUnconstrained which accounts for evaporation. Replaces old ...forOneMonth() function. This is more generic.<br><br>AUTHOR, DATE:  CF,20190109";
    BEGIN

      "VolumeToFlow"( ( PrvStorage - "ElevationToStorage"( Res, TargetPE ) + TotalInflow ), TargetEndDate );

    END
    UUID "{f0d15fdd-8da5-4654-ac7a-30810f6926b5}";;

    FUNCTION       "FGTargetHWGivenInflowOneMonth" ( NUMERIC TargetPE )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "ARGUMENTS<br>NUMERIC TargetPE, PE to achieve at TargetEndDate<br><br>DESCRIPTION: This function returns the release for the current month to attain the specified pool elevation value, &quot;TargetPE&quot;. New fct FGTargetHWGivenInflowOneMonth() w/ only 1 PE arguement now calls generic TargetHWGivenInflowOneMonth() to improve readability   <br><br>RETURNS: Monthly outflow rate [L^3/T]<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "20201210,CF: Add Evaporation to FGTargetHWGivenInflowOneMonth() <br><br>CF,20190109: New mass balance function called by GetFGBaseFlowMagnitudeUnconstrained which accounts for evaporation. Replaces old ...forOneMonth() function. This is more generic.<br><br>AUTHOR, DATE:  CF,20190109";
    BEGIN

      "TargetHWGivenInflowOneMonth"( % "FlamingGorge", @"t - 1", @"t", TargetPE COMMENTED_BY "CF: Prv fct (TargetHWGivenInflowforOneMonth) just took in Elevation but this matches <br>TargetHW arguements and is more explicit.   <br>", ( "FlowToVolume"( $ "FlamingGorge.Inflow" COMMENTED_BY "CF: CRSS slot ForecastData.FlamingGorgeInflow <br>" [], @"t" ) - "EstimateEvaporation"( % "FlamingGorge", $ "FlamingGorge.Storage" [@"t - 1"], $ "FlamingGorge.Storage" [@"t - 1"], @"t", @"t" ) ) COMMENTED_BY "CF: MTOM's unregulated inflow accounts for the evaporation and upstream delta <br>storage therefore it does not need to include EstimateEvaporation like CRSS.  <br>", $ "FlamingGorge.Storage" [@"t - 1"] );

    END
    UUID "{391323d4-033d-4a07-8efa-8347e14cbd9d}";;

    FUNCTION       "GetDaysAtBypass" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguments: None<br><br>Description: The function determines the number of days Flaming Gorge will bypass based on hydrologic class. <br><br>-In wet years Flaming Gorge will always bypass.  <br>-In dry years Flaming Gorge will never bypass.  <br>-In the other three year types, Flaming Gorge will bypass if conditions on the Yampa River warrant bypassing water to try and meet the wetter targets at Jensen (18600 cfs).   <br> <br>Yampa must be above 10000 (calculated by DaysAboveThreshold) for a length of time greater than or equal to the values in YampaDaysAbove10000ForBypass for Flaming Gorge to bypass water. If this is the case then GetNumberOfDaysAtBypass is used to determine the number of days at bypass. This is a function of both the year type on the Yampa and the year type on the Green/at Flaming Gorge as determined by the Compute Percent Exceedance rule.  <br><br>In previous versions of CRSS, Flaming Gorge would only bypass when the Yampa was flowing at 14000 cfs for enough days to meet the 22600 flow target at Jensen. The 22600 cfs flow target has a shorter duration than the 18600 cfs target, therefore under certain hydrologies this updated version will function differently than previous versions of CRSS. <br><br>Returns: the number of days Flaming Gorge will bypass.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF,20190204: Imported from CRSS. ";
    BEGIN

      WITH NUMERIC MaxBypassDays = "Max"( "RoundToNearestDay"( ( $ "FlamingGorge.Storage" [@"t - 1"] - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ) + "PredictedFGInflow"( @"t", @"24:00:00 August Max DayOfMonth, Current Year" ) ) / "GetMaxOutflowGivenHW"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [], @"t" ) ), 0.00000000 "day" ) DO
  IF ( $ "KNN_MTOM.SpringHClass" [] < 4.00000000 AND $ "KNN_MTOM.SpringHClass" [] > 0.00000000 )
  THEN
   IF ( "DaysAboveThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ), 10000.00000000 "cfs" ) >= $ "FlamingGorgeData.YampaDaysAbove10000ForBypass" [$ "KNN_MTOM.SpringHClass" [], 0.00000000] )
   THEN
    "GetNumberOfDaysAtBypass"( $ "KNN_MTOM.SpringHClass" [] )
   ELSE
    0.00000000 "day"
   ENDIF
  ELSE
   IF ( $ "KNN_MTOM.SpringHClass" [] == 0.00000000 )
   THEN
    0.00000000 "day" COMMENTED_BY "In Dry years never bypass"
   ELSE
    "Max"( "GetNumberOfDaysAtBypass"( $ "KNN_MTOM.SpringHClass" [] ), MaxBypassDays ) COMMENTED_BY "In wet years always bypass."
   ENDIF
  ENDIF
 ENDWITH COMMENTED_BY "Are we in Mod Dry, Ave, or Mod Wet?";

    END
    UUID "{afe5a5aa-c06f-4d1f-979d-6fe7e2aa2d8d}";;

    FUNCTION       "GetNumberOfDaysAtBypass" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: Current hydrologic year classification <br><br>Description: Funciton ensures that the days at power plant capacity calculated by GetNumberOfDaysAtBypassUnconstrained fall within the limits of the current hydrolocic classification<br><br>Returns: Number of days ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT $ "FlamingGorgeData.DaysAtBypass" [Class, 0.00000000];
    MAX_CONSTRAINT $ "FlamingGorgeData.DaysAtBypass" [Class, 1.00000000];
    NOTES          "CF,20200104: Min and Max constraints added to match CRSS<br><br>CF,20190204: Imported from CRSS. <br>";
    BEGIN

      "GetNumberOfDaysAtBypassUnconstrained"( Class ) COMMENTED_BY "Ensure that the days at power plant capacity fall within the <br>limits ofthe current hydrolocic classification";

    END
    UUID "{67cda824-64ee-4ef3-b6ef-781afcdf0869}";;

    FUNCTION       "GetNumberOfDaysAtBypassUnconstrained" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: Current hydrologic year classification <br><br>Description: Funciton interpolates to find the number of days at by pass capacity based on the spring flow percentage exceedence and the EIS mandated limits for the current hydrolocic classification<br><br>Returns: Number of days ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF,20190204: Imported from CRSS. ";
    BEGIN

      "Interpolate"( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 0.00000000], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtBypass" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtBypass" [Class, 0.00000000] );

    END
    UUID "{bcdfcd21-30e7-44ed-9d2d-efd60ac222c2}";;

    FUNCTION       "CheckJensen" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "ARGUMENTS<br>None<br><br>DESCRIPTION: New fct CheckJensen() replaces Max(FG.BaseFlowMagLimits-Minitem(YampaDepleted)),MinFlow) to improve readability.<br><br>RETURNS: Monthly outflow rate [L^3/T]";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( ( $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 2.00000000] - "MinItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"t", @"24:00:00 July 31, Current Year" ) ) ), $ "FlamingGorgeData.MinFlow" [] );

    END
    UUID "{aff436d3-f110-40ec-849d-fe86cdec218b}";;

  END
  UUID "{415c2fa2-80ea-4bcc-a815-430c9b53df93}";;

  UTILITY_GROUP "Aspinall Functions - MTOM Only";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "BlueMesaOutflowCalc" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the outflow to be released from Blue Mesa by considering the following constraints: 1.) Release the greater of the flows necessary to meet the Whitewater Target Flow, the Black Canyon Target Flow, and the target pool elevation for Blue Mesa; 2.) Prevent an overflow at Crystal; 3.) If above minimum power pool elevation (7,393 ft), then maintain the pool above that value; 4.) Release no more than the maximum possible outflow; 5.) Maintain the pool elevation above the top of the dead pool (7,358 ft); 6.) Prevent the pool elevation from exceeding the maximum pool elevation.<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Release not less than 0 cfs";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Some of the limiting constraints could be moved to Post-Execution Checks (i.e., max possible outflow, release to max PE, release to dead pool); update local variable names; replace hard-coded values with slot values as possible";
    BEGIN

      WITH NUMERIC MonthlyWhitewaterTarget = FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
  $ "BlueMesaData.TargetDailyWhitewaterFlows" [date]
 ENDFOR COMMENTED_BY "Computes the average flow for the month at the Whitewater Gage.<br>CF: Removed logic about spillway and HClass > 3.    <br>" DO
  WITH NUMERIC MonthlyCanyonFlows = IF ( $ "BlueMesaData.MeetCanyonDecreeFlows" [] == 1.00000000 )
  THEN
   FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
    $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date]
   ENDFOR
  ELSE
   0.00000000 "acre-ft/month"
  ENDIF DO
   WITH NUMERIC ReleaseToMeetBMMaxPE = "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MaximumPoolElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Outflow to bring the reservoir to the maximum reservoir pool" DO
    WITH NUMERIC ReleaseToMeetBMTargetPE = "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), 0.00000000 "cfs" COMMENTED_BY "CF: If the inflow + storage[t-1] is not equal to the guide storage[t] then will calculate a negative <br>outflow, setting to 0 prevents that from being included in solving the Blue Mesa Outflow <br>" ) COMMENTED_BY "Outflow to meet the target pool elevation" DO
     WITH NUMERIC TargetReleaseFromBM = "Max"( "MinItem"( { "MaxItem"( { "SolveBlueMesaReleaseForDownstreamTargets"( MonthlyWhitewaterTarget, @"t", MonthlyCanyonFlows ) , ReleaseToMeetBMTargetPE } ) , "SolveBlueMesaReleaseForCrystalReleaseTarget"( $ "BlueMesaData.CrystalMaxOutflow" [@"t"], @"t" ) , "MaximumRelToAvoidMinimumPE"(  ) , "ReleaseableVolumeRate"(  ) } ), ReleaseToMeetBMMaxPE COMMENTED_BY "Release necessary to prevent Flood Control" ) DO
      "Max"( TargetReleaseFromBM, 0.00000000 "cfs" )
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "Calculate flows needed in Black Canyon"
 ENDWITH COMMENTED_BY "Calculate flows needed at Whitewater gage";

    END
    UUID "{2cd969d6-480e-44aa-b936-83d2c0808fc2}";;

    FUNCTION       "BlueMesaOutflowCalc_Old2020" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the outflow to be released from Blue Mesa by considering the following constraints: 1.) Release the greater of the flows necessary to meet the Whitewater Target Flow, the Black Canyon Target Flow, and the target pool elevation for Blue Mesa; 2.) Prevent an overflow at Crystal; 3.) If above minimum power pool elevation (7,393 ft), then maintain the pool above that value; 4.) Release no more than the maximum possible outflow; 5.) Maintain the pool elevation above the top of the dead pool (7,358 ft); 6.) Prevent the pool elevation from exceeding the maximum pool elevation.<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Release not less than 0 cfs";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Some of the limiting constraints could be moved to Post-Execution Checks (i.e., max possible outflow, release to max PE, release to dead pool); update local variable names; replace hard-coded values with slot values as possible";
    BEGIN

      WITH NUMERIC MonthlyWhitewaterTarget = IF ( ( "GetMonth"( @"t" ) == 5.00000000 OR "GetMonth"( @"t" ) == 6.00000000 ) AND ( $ "BlueMesa.Storage" [@"t - 1"] + "FlowToVolume"( $ "BlueMesa.Inflow" [@"t"], @"t" ) > "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.SpillwayElevation" [] ) OR $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] < 3.00000000 ) )
 THEN
  FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
   $ "BlueMesaData.TargetDailyWhitewaterFlows" [date]
  ENDFOR
 ELSE
  $ "BlueMesaData.BaseFlowTarget" [@"t", $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"]] COMMENTED_BY "CF: This was corrected so it takes in H Class to find correct baseflow.  <br>"
 ENDIF COMMENTED_BY "Computes the average flow for the month at the Whitewater Gage, which is calculated and then <br>referenced on the BlueMesaData.MayThruJulyDaily slot. TP 9/22/2015" DO
  WITH NUMERIC MonthlyCanyonFlows = IF ( $ "BlueMesaData.MeetCanyonDecreeFlows" [] == 1.00000000 )
  THEN
   FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
    $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date]
   ENDFOR
  ELSE
   0.00000000 "acre-ft/month"
  ENDIF DO
   WITH NUMERIC MeetDownstreamFlowTargets = "SolveBlueMesaReleaseForDownstreamTargets"( MonthlyWhitewaterTarget, @"t", MonthlyCanyonFlows ) COMMENTED_BY "Maximum release to meet the Whitewater Gage and the Black Canyon Target Flows" DO
    WITH NUMERIC ReleaseToMeetBMMaxPE = "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MaximumPoolElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Outflow to bring the reservoir to the maximum reservoir pool" DO
     WITH NUMERIC ReleaseToMeetBMTargetPE = "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), 0.00000000 "cfs" COMMENTED_BY "CF: If the inflow + storage[t-1] is not equal to the guide storage[t] then will calculate a negative <br>outflow, setting to 0 prevents that from being included in solving the Blue Mesa Outflow <br>" ) COMMENTED_BY "Outflow to meet the target pool elevation" DO
      WITH NUMERIC MaxReleaseToAvoidMinPE = WITH NUMERIC tunnelDiv = $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [@"t"] DO
       WITH NUMERIC WaterAvailToCanyon = "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPoolElevation" [] COMMENTED_BY "Input Minimum Pool Elevation on the Blue Mesa Data Object" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), % "BlueMesa" & "Inflow" [@"t"] ) DO
        WITH NUMERIC GainsAbvCrystal = $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [@"t"] + $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [@"t"] DO
         WITH NUMERIC GainsBMToGJ = GainsAbvCrystal + $ "GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow" [@"t"] DO
          WITH NUMERIC flowLevel = $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] DO
           WITH NUMERIC WaterRigtsAtWW = $ "BlueMesaData.BaseFlowTarget" [@"t", flowLevel] DO
            "Max"( tunnelDiv + "MinItem"( { WaterAvailToCanyon , "MaxItem"( { WaterRigtsAtWW - GainsBMToGJ , $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"] - GainsAbvCrystal , 0.00000000 "cfs" } ) , IF ( $ "BlueMesa.Pool Elevation" [@"t - 1"] <= $ "BlueMesaData.MinimumPoolElevation" [] )
            THEN
             "Max"( 300.00000000 "cfs" - GainsAbvCrystal, 0.00000000 "cfs" )
            ELSE
             "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPoolElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) - tunnelDiv, 0.00000000 "cfs" )
            ENDIF } ), "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPoolElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), 0.00000000 "cfs" ) )
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH COMMENTED_BY "This determines the outflow from the reservoir as the reservoir approaches and goes below the spillway.  <br>If the Blue Mesa is above min power pool (7,393 ft) in the previous time step, then release the amount <br>necessary to meet the downstream demands, including the Gunnison Tunnel and the Whitewater and Black <br>Canyon Target Flows but not more than what would lower Blue Mesa to Min Power Pool. If the Blue Mesa Pool <br>Elevation is below Min Power Pool then only release enough to meet the Gunnison Tunnel flow and base target <br>flows at Whitewater and the Canyon. " DO
       WITH NUMERIC MaxReleaseToPreventCrystalOverflow = "SolveBlueMesaReleaseForCrystalReleaseTarget"( $ "BlueMesaData.CrystalMaxOutflow" [@"t"], @"t" ) COMMENTED_BY "If Possible do not release over the maximum monthly target flow for Crystal. <br>Aug - Apr: 2,100 cfs; June - July: 4,150 cfs; no limit in May. " DO
        WITH NUMERIC BMPoolElevWithNoRelease = "TableInterpolation"( $ "BlueMesa.Elevation Volume Table", 1.00000000, 0.00000000, $ "BlueMesa.Storage" [@"t - 1"] + "FlowToVolume"( $ "BlueMesa.Inflow" [@"t"], @"t" ), @"t" ) DO
         WITH NUMERIC NoReleaseStorage = "ElevationToStorage"( % "BlueMesa", BMPoolElevWithNoRelease ) COMMENTED_BY "Calculate storage without release <br>" DO
          WITH NUMERIC SpillwayStorage = "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.SpillwayElevation" [] ) COMMENTED_BY "Calculate storage at the spillway invert <br>" DO
           WITH NUMERIC VolumeAboveSpillway = NoReleaseStorage - SpillwayStorage DO
            WITH NUMERIC ReleaseableVolumeRate = VolumeAboveSpillway / 1.00000000 "month" + $ "BlueMesa.Maximum Controlled Release" [0.00000000, 0.00000000] COMMENTED_BY "Here, this value represents only the max outlet works instead of also including <br>the Regulated Spill, which is how the RiverWare documentation considers it. <br>" DO
             WITH NUMERIC maxPossibleOutflow = "TableInterpolation"( $ "BlueMesaData.BlueMesa_MaxOutflowTable", 0.00000000, 1.00000000, BMPoolElevWithNoRelease, @"t" ) COMMENTED_BY "Mathematically derived max possible outflow based on the Max Release table <br>on the Blue Mesa data object. " DO
              WITH NUMERIC maxOutflowToBottom = "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MaxDeadPoolElevation" [] + 0.10000000 "feet" ) COMMENTED_BY "The minimum elevation is a tenth of a foot high to prevent the reservoir from failing from the <br>mass balance for the reservoir. TP 9/28/2015", "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Max release to the top of the dead pool (7,358 ft.)" DO
               WITH NUMERIC TargetReleaseFromBM = "Max"( "MinItem"( { "MaxItem"( { MeetDownstreamFlowTargets , ReleaseToMeetBMTargetPE } ) , MaxReleaseToPreventCrystalOverflow , MaxReleaseToAvoidMinPE , ReleaseableVolumeRate COMMENTED_BY "MC, 20170808: for testing, replaced maxPossibleOutflow <br>with ReleaseableVolumeRate  <br>" , maxOutflowToBottom } ), ReleaseToMeetBMMaxPE COMMENTED_BY "Release necessary to prevent Flood Control" ) DO
                "Max"( TargetReleaseFromBM, 0.00000000 "cfs" )
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "Calculate flows needed in Black Canyon"
 ENDWITH COMMENTED_BY "Calculate flows needed at Whitewater gage";

    END
    UUID "{5e756b45-3818-4779-93c9-e6c5243eafcd}";;

    FUNCTION       "TaylorParkMinReleaseConstraint" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and returns the minimum release permitted on that date from Taylor Park Reservoir.  Currently it is just the &quot;MinFlow&quot; slot on the &quot;TaylorParkData&quot; object.  It is expected that this function will get more detailed as the development of the model continues and may have unique calculations for each month of the year. - sc 12/16/10<br><br>RETURNS: Minimum flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the minimum flow is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: Replace calls to this function with references to the slot?";
    BEGIN

      $ "TaylorParkData.MinFlow" [date];

    END
    UUID "{e99577dd-57fe-4e16-b295-2386f4d84497}";;

    FUNCTION       "CalcCanyonPeakFlowTarget" ( NUMERIC currentForecast )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function returns the one-day peak flow target for the Black Canyon portion of the Gunnison River that will meet the Federal Reserve Water Right. Data for the linear calculation is stored in BlueMesaData.PeakFlowCalcData. Peak flow levels are from Appendix G, Sect 31 of Decree, Case No. 01CW05.<br><br>ARGUMENTS: Current Unregulated Inflow Forecast<br><br>RETURNS: One-day peak flow target for the Black Canyon portion of the Gunnison River.<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/22/2010<br><br>CF, 20170505: The function was modified to take currentForecast as an argument. Data for the linear calculation has been stored in BlueMesaData.PeakFlowCalcData rather than the function's body. - CF 5/5/17<br><br>SC, 20101222: The calculation is taken from Paul Davidson's &quot;Black Canyon Logic&quot; spreadsheet which references the relevant section of the Decree. The peak flow is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir. There are six regions, each having its own linear calculation for the peak flow. First the function determines which region, or level, the forecast fits into, and then calculates using the linear equation associated with that region, the appropriate peak flow target for May of the current year. - sc 12/22/10";
    BEGIN

      WITH STRING forecastLevel = FOR ( STRING level IN { "Level 6" , "Level 5" , "Level 4" , "Level 3" , "Level 2" , "Level 1" } ) WITH STRING result = "Level 6" DO
  IF ( $ "BlueMesaData.CanyonFlowCalcData" [level, "Upper Limit"] > currentForecast )
  THEN
   level
  ELSE
   result
  ENDIF
 ENDFOR DO
  ( $ "BlueMesaData.CanyonFlowCalcData" [forecastLevel, "Parameter A"] * ( currentForecast / 1000.00000000 "acre-feet" ) + $ "BlueMesaData.CanyonFlowCalcData" [forecastLevel, "Parameter B"] ) * 1.00000000 "cfs"
 ENDWITH;

    END
    UUID "{2d731052-366c-4aac-a2d7-cc9398889761}";;

    FUNCTION       "CalcGunnisonWWPeakFlowTarget" ( NUMERIC HClass, NUMERIC currentForecast )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: The one-day peak flow target at the Whitewater gage is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir BlueMesaInflow.Unregulated. The target is determine based a linear equation divided into six regions corresponding to the different hydrologic year types. The coefficients are stored in BlueMesaData.PeakFlowCalcData and come from the 2012 ROD Figure 1 and Table 1.<br><br>RETURNS: One-day peak flow target for the Whitewater gage.<br><br>ARGUMENTS: <br>1. NUMERIC HClass - current hydrologic year classification based on the current Apr-Jul forecast for Blue Mesa unregulated inflow<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/22/2010<br><br>CF, 20170505: The function was modified to take currentForecast and HClass as arguments. - CF 5/5/17<br><br>MC, 20161103: I think this calculation is actually for the Whitewater Gage, not the Black Canyon. The parameters in BlueMesaData.PeakFlowCalcData are consistent with those from the ROD referenced in the document BlueMesaOpsOutline_2015.docx<br><br>This function returns the one-day peak flow target for the Black Canyon portion of the Gunnison River.  The calculation is taken from Paul Davidson's &quot;Black Canyon Logic&quot; spreadsheet which references the releavant section of the Decree.  The peak flow is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir.  There are six regions, each having its own linear calculation for the peak flow.  First the function determines which region, or level, the forecast fits into, and then calculates using the linear equation associated with that region, the appropriate peak flow target for May of the current year. - sc 12/22/10";
    BEGIN

      $ "BlueMesaData.PeakFlowCalcData" [HClass, "Parameter A"] * ( currentForecast / 1000.00000000 "acre-feet" ) + $ "BlueMesaData.PeakFlowCalcData" [HClass, "Parameter B"];

    END
    UUID "{03ceb0c5-f624-4594-b192-a5dc9ad285c3}";;

    FUNCTION       "CalcGunnisonHClass" ( NUMERIC currentForecast )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: Calculates the Hydrologic Year classification which is a value between 0 (Dry) and 5 (Wet) that is based on Figure 1 and Table 1 of the 2012 ROD for the Aspinall Unit.  Values are stored in BlueMesaData.PeakFlowCalcData. <br><br>RETURNS: Numeric peak flow level 0-5/hydrologic year type [No Units]<br><br>ARGUMENTS:<br>1. NUMERIC currentForecast - current Blue Mesa forecasted unregulated inflow<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: CF, 20170505<br><br>CF, 20170505: The function was modified to take currentForecast as an argument. The name of this function was updated. - CF 5/5/17";
    BEGIN

      FOR ( NUMERIC HClass IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 , 5.00000000 } ) WITH NUMERIC result = 0.00000000 DO
  IF ( currentForecast > $ "BlueMesaData.PeakFlowCalcData" [HClass, "Lower Limit"] )
  THEN
   HClass
  ELSE
   result
  ENDIF
 ENDFOR;

    END
    UUID "{06502e35-1f8a-442e-855d-b5bd3a54a0ed}";;

    FUNCTION       "UBConstrainedOutflow" ( OBJECT reservoir, NUMERIC UnconstrainedOutflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: None <br>  <br>Description: <br>  <br>Returns: Constrainted Outflow rate [L^3/T]";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT 0.00000000 "acre-ft/month";
    MAX_CONSTRAINT "Min"( "SolveOutflow"( reservoir, reservoir & "Inflow" [@"t"], 0.00000000 "acre-ft", reservoir & "Storage" [@"t - 1"], @"t" ), $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "maxRelease"] );
    NOTES          "CF,20190405: Created to apply to Aspinall Rules";
    BEGIN

      UnconstrainedOutflow;

    END
    UUID "{e52fff83-59b6-491c-9f14-a3ad2494fce7}";;

    FUNCTION       "SolveBlueMesaReleaseForDownstreamTargets" ( NUMERIC TargetWhitewaterFlow, DATETIME date, NUMERIC TargetCanyonFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "Arguements: <br>1. NUMERIC TargetWhitewaterFlow - flow rate required at the Whitewater gage<br>2. DATETIME date - date for which the release is desired<br>3. NUMERIC TargetCanyonFlow - flow rate required through Black Canyon<br>  <br>Description: This function takes a numeric flow target and a date. It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target for the Whitewater gage and the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace. The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa.<br><br>Since MTOM now includes evaporation additional releases are nessisary to maintain Morrow Point and Crystal storage. Blue Mesa also releases to achieve a target Morrow Point storage which was given by Rick Clayton. At this time releases to achieve a Crystal target storage have not been included in Blue Mesa operations and are just withheld by Crystal in the first timestep, see rule Crystal Outflow.   <br>  <br>Returns: Blue Mesa release [L^3/T] - release from Blue Mesa Reservoir that is necessary to hit the flow targets ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF,20190403: Moved in from Apr 2019 Offc CRSS. Add accounting for Evap of DS res. Add release needed to get MP to target storage. <br><br>MC, 20170705: Added adjustment to local inflows for dates in May because local inflow value includes changes in Paonia and Ridgway storages that are not available to meet downstream targets (i.e., the local inflows are unregulated but regulated flows are what actually contribute to target flows). The value added is the average difference between regulated and unregulated flows for 1980-2017 based on data received from Rick C. <br>MC, 20161123: This function receives target Whitewater and Black Canyon flows, as well as a date. It returns the Blue Mesa Reservoir release value necessary to achieve both of the passed-in flow targets by calculating a water balance between the reservoir and each target location, and setting the release to the maximum needed to attain the targets.  (used in updated BlueMesaOpsOutline_November2016.docx)";
    BEGIN

      "Max"( "Max"( ( ( TargetWhitewaterFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] - ( $ "GainsCrystalToGJ.GainsCrystalToGJ" [date] - IF ( "GetMonth"( date ) == 5.00000000 )
 THEN
  $ "BlueMesaData.CrystalToGJ_MayAdjustment" []
 ELSE
  0.00000000 "acre-feet/month"
 ENDIF COMMENTED_BY "In May, adjust local inflows for reservoir storages" ) ) + "VolumeToFlow"( ( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ), @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ) ) COMMENTED_BY "Need to account for Evap to maintain constant storage in DS res. <br>" + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "Additional Release needed to get MP to Target <br>", @"t" ) ) COMMENTED_BY "-Would set a Blue Mesa Release enough to meet the Whitewater Target and the Gunnison Tunnel <br>Diversion while leveraging the gains between Blue Mesa and Grand Junction  <br>", ( ( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] ) + "VolumeToFlow"( ( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ), @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ) ) COMMENTED_BY "Need to account for Evap to maintain constant storage in DS res. <br>" + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "Additional Release needed to get MP to Target <br>", @"t" ) ) COMMENTED_BY "This would set a Blue Mesa Release enough to meet the minimum Black Canyon Flows and the <br>Gunnison Tunnel Diversion while leveraging the gains between BM and the Tunnel. " ), "VolumeToFlow"( ( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ), @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ) ) COMMENTED_BY "Need to account for Evap to maintain constant storage in DS res. <br>" + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "Additional Release needed to get MP to Target <br>", @"t" ) COMMENTED_BY "If Gains Meet DS Targets: <br>" );

    END
    UUID "{d7a77937-f5fa-426c-804f-53b982617b8c}";;

    FUNCTION       "SolveBlueMesaReleaseForDownstreamTargets_NoEvap" ( NUMERIC TargetWhitewaterFlow, DATETIME date, NUMERIC TargetCanyonFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "Arguements: <br>1. NUMERIC TargetWhitewaterFlow - flow rate required at the Whitewater gage<br>2. DATETIME date - date for which the release is desired<br>3. NUMERIC TargetCanyonFlow - flow rate required through Black Canyon<br>  <br>Description: This function takes a numeric flow target and a date. It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target for the Whitewater gage and the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace. The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa.<br><br>Since MTOM now includes evaporation additional releases are nessisary to maintain Morrow Point and Crystal storage. Blue Mesa also releases to achieve a target Morrow Point storage which was given by Rick Clayton. At this time releases to achieve a Crystal target storage have not been included in Blue Mesa operations and are just withheld by Crystal in the first timestep, see rule Crystal Outflow.   <br>  <br>Returns: Blue Mesa release [L^3/T] - release from Blue Mesa Reservoir that is necessary to hit the flow targets ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF,20190403: Moved in from Apr 2019 Offc CRSS. Add accounting for Evap of DS res. Add release needed to get MP to target storage. <br><br>MC, 20170705: Added adjustment to local inflows for dates in May because local inflow value includes changes in Paonia and Ridgway storages that are not available to meet downstream targets (i.e., the local inflows are unregulated but regulated flows are what actually contribute to target flows). The value added is the average difference between regulated and unregulated flows for 1980-2017 based on data received from Rick C. <br>MC, 20161123: This function receives target Whitewater and Black Canyon flows, as well as a date. It returns the Blue Mesa Reservoir release value necessary to achieve both of the passed-in flow targets by calculating a water balance between the reservoir and each target location, and setting the release to the maximum needed to attain the targets.  (used in updated BlueMesaOpsOutline_November2016.docx)";
    BEGIN

      "Max"( "Max"( ( ( TargetWhitewaterFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] - ( $ "GainsCrystalToGJ.GainsCrystalToGJ" [date] - IF ( "GetMonth"( date ) == 5.00000000 )
 THEN
  $ "BlueMesaData.CrystalToGJ_MayAdjustment" []
 ELSE
  0.00000000 "acre-feet/month"
 ENDIF COMMENTED_BY "In May, adjust local inflows for reservoir storages" ) ) + "VolumeToFlow"( ( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ), @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ) ) COMMENTED_BY "Need to account for Evap to maintain constant storage in DS res. <br>" + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "Additional Release needed to get MP to Target <br>", @"t" ) ) COMMENTED_BY "-Would set a Blue Mesa Release enough to meet the Whitewater Target and the Gunnison Tunnel <br>Diversion while leveraging the gains between Blue Mesa and Grand Junction  <br>", ( ( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] ) + "VolumeToFlow"( ( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ), @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ) ) COMMENTED_BY "Need to account for Evap to maintain constant storage in DS res. <br>" + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "Additional Release needed to get MP to Target <br>", @"t" ) ) COMMENTED_BY "This would set a Blue Mesa Release enough to meet the minimum Black Canyon Flows and the <br>Gunnison Tunnel Diversion while leveraging the gains between BM and the Tunnel. " ), "VolumeToFlow"( ( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ), @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ) ) COMMENTED_BY "Need to account for Evap to maintain constant storage in DS res. <br>" + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "Additional Release needed to get MP to Target <br>", @"t" ) COMMENTED_BY "If Gains Meet DS Targets: <br>" );

    END
    UUID "{b498f76b-5070-4e5c-ac14-1cd527994c6f}";;

    FUNCTION       "SolveBlueMesaReleaseForCrystalReleaseTarget" ( NUMERIC TargetCrystalRelease, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "ARGUMENTS:<br>1. NUMERIC TargetCrystalRelease - release rate desired from Crystal<br>2. DATETIME date - date on which the release is desired<br><br>DESCRIPTION: This function takes a numeric release target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in release target for Crystal Reservoir  The function does this by doing a water balance in the reach of the river between Blue Mesa and Crystal Res and solving for the release from Crystal Res. <br><br>Since MTOM now includes evaporation additional releases are nessisary to maintain Morrow Point and Crystal storage.<br><br>RETURNS: Release rate [L^3/T]<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF,20190403: Moved in from Apr 2019 Offc CRSS. Add accounting for Evap of DS res. <br><br>AUTHOR, DATE: sc 12/28/10";
    BEGIN

      "Max"( TargetCrystalRelease - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] - "VolumeToFlow"( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) COMMENTED_BY "CF: MP should reach target by end of timestep. <br>", @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ), @"t" ), "VolumeToFlow"( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) COMMENTED_BY "CF: MP should reach target by end of timestep. <br>", @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ), @"t" ) COMMENTED_BY "CF: Only release to cover evap. <br>" );

    END
    UUID "{8cd450d2-0f34-4930-bce0-e062d67f3778}";;

    FUNCTION       "MaximumRelToAvoidMinimumPE" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: None <br>  <br>Description: This determines the outflow from the reservoir as the reservoir approaches and goes below the spillway. If the Blue Mesa is above 7,393 ft in the previous time step, then release the amount necessary to meet the downstream demands, including the Gunnison Tunnel and the Whitewater and Black Canyon Target Flows (we already calculate) but not more than what would lower Blue Mesa to 7,393 ft. If the Blue Mesa Pool Elevation is below 7,393 then only release enough to meet the Gunnison Tunnel flow and base target flows at Whitewater and the Canyon. <br>  <br>RETURNS: Outflow rate [L^3/T] <br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: CF<br>CF,20210104: Simplified logic to match CRSS.<br><br>CF,20201210: This logic from BlueMesaOutflowCalc() moved to seperate function. <br>Simplified based on above descritpion which was a comment on BlueMesaOutflowCalc(). This calculates a different value than MaximumRelToAvoidMinimumPE() but I believe it preforms correctly. ";
    BEGIN

      WITH NUMERIC tunnelDiv = $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [@"t"] DO
  WITH NUMERIC GainsAbvCrystal = $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [@"t"] + $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [@"t"] DO
   WITH NUMERIC GainsBMToGJ = GainsAbvCrystal + $ "GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow" [@"t"] DO
    WITH NUMERIC flowLevel = $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] DO
     WITH NUMERIC WaterRightsAtWW = $ "BlueMesaData.BaseFlowTarget" [@"t", flowLevel] DO
      IF ( $ "BlueMesa.Pool Elevation" [@"t - 1"] <= $ "BlueMesaData.MinimumPoolElevation" [] )
      THEN
       "MaxItem"( { WaterRightsAtWW - GainsBMToGJ + tunnelDiv , $ "BlueMesaData.MinimumBlackCanyonFlow" [] - GainsAbvCrystal + tunnelDiv , $ "BlueMesaData.BlueMesaMinRelease" [] + tunnelDiv } ) COMMENTED_BY "If the Blue Mesa Pool Elevation is below 7,393 then only release enough to meet the Gunnison Tunnel <br>flow and base target flows at Whitewater and the Canyon.   <br>"
      ELSE
       "Max"( "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPoolElevation" [] ), $ "BlueMesa.Storage" [@"t - 1"], @"t" ), $ "BlueMesaData.BlueMesaMinRelease" [] ) COMMENTED_BY "If the Blue Mesa is above 7,393 ft in the previous time step, then release the amount necessary to meet <br>the downstream demands (handled in another function) but not more than what would lower Blue <br>Mesa to 7,393 ft  <br>"
      ENDIF
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{dd383d43-6619-4e47-a17a-44714058522e}";;

    FUNCTION       "ReleaseableVolumeRate" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: None <br>  <br>Description: Determine the maximum releaseable volume rate which is the max outlet works volume plus the volume above the spillway.  <br><br>These statements where added to MTOM in 2017 to check that the release to meet ROD objectives is doable so that the spillway at BM is available.  This is a work around that Mike came up with.  Ideally we would prefer to somehow model daily operations during the peeking period to insure that the max release rate at BM is sufficient to support storage in MP.  Without the spillway, if releases from CR exceed around 6500 cfs, MP releases will exceed max BM releases and MP storage will fall.  Any releases required releases above about 6030 cfs at BM must come through spillway.  <br>  <br>RETURNS: Outflow rate [L^3/T] <br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: CF<br>CF,20201210: This logic from BlueMesaOutflowCalc() moved to seperate function. <br>";
    BEGIN

      WITH NUMERIC BMPoolElevWithNoRelease = "TableInterpolation"( $ "BlueMesa.Elevation Volume Table", 1.00000000, 0.00000000, $ "BlueMesa.Storage" [@"t - 1"] + "FlowToVolume"( $ "BlueMesa.Inflow" [@"t"], @"t" ), @"t" ) DO
  WITH NUMERIC NoReleaseStorage = "ElevationToStorage"( % "BlueMesa", BMPoolElevWithNoRelease ) COMMENTED_BY "Calculate storage without release <br>" DO
   WITH NUMERIC SpillwayStorage = "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.SpillwayElevation" [] ) COMMENTED_BY "Calculate storage at the spillway invert <br>" DO
    WITH NUMERIC VolumeAboveSpillway = NoReleaseStorage - SpillwayStorage DO
     WITH NUMERIC ReleaseableVolumeRate = VolumeAboveSpillway / 1.00000000 "month" + $ "BlueMesa.Maximum Controlled Release" [0.00000000, 0.00000000] COMMENTED_BY "Here, this value represents only the max outlet works instead of also including <br>the Regulated Spill, which is how the RiverWare documentation considers it. <br>" DO
      ReleaseableVolumeRate
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{8372d435-91fc-42d2-b76a-235c2d89d7ba}";;

  END
  UUID "{6139a25f-0d0c-41dc-95f6-3a33d125e116}";;

  UTILITY_GROUP "Vallecito Functions - MTOM Only";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "VallecitoMinReleaseConstraint" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and returns the minimum release permitted on that date from Vallecito Reservoir.  Currently it is just the &quot;MinFlow&quot; slot on the VallecitoData object.  It is expected that this function will get more detail as the development of the model continues and may have unique calculations for each month of the year. - sc 12/16/10<br><br>RETURNS: Minimum release rate [L^3/T]<br><br>ARGUMENTS:<br>1. DATETIME date - date which is currently irrelevant to function<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: Remove function as unnecessary?";
    BEGIN

      $ "VallecitoData.MinFlow" [];

    END
    UUID "{1b023353-c615-4f5b-95a1-679d04334678}";;

    FUNCTION       "VallecitoMaxReleaseConstraint" ( DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and a previous elevation value and returns the maximum allowable release from Vallecito Reservoir on that date.  Currently it is calculated as the appropriate value on the &quot;Max Release&quot; table of the reservoir.  It is expected that this function will get more detailed as the model is developed and will likely have unique calculations for each month of the year.  - sc 12/17/10<br><br>RETURNS: Maximum release rate [L^3/T]<br><br>ARGUMENTS: <br>1. DATETIME date - date specifying timestep for which max release is desired<br>2. NUMERIC  prevElev - pool elevation at end of previous timestep<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "TableInterpolation"( $ "Vallecito.Max Release", 0.00000000, 1.00000000, prevElev, @"t" );

    END
    UUID "{53e87b31-912f-4c3d-b87a-84852b2c5ef0}";;

  END
  UUID "{90ae13a1-e8de-4a14-94b3-b82e4142dbed}";;

  UTILITY_GROUP "Navajo Functions - MTOM Only";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "DebugDailyNavajoFunction" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is used to debug the parent function, this should not have an impact on the result of the parent function and can be edited using the boolean function that allows this function to execute. <br><br>RETURN TYPE: Flow rate of 0.00 cfs<br><br>ARGUMENTS:<none><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/4/2015<br>";
    BEGIN

      0.00000000 "cfs";

    END
    UUID "{6191fdc1-aedd-4259-a8b0-511ca94eb60e}";;

    FUNCTION       "DetermineNavajoEoWYReleaseLevel" ( DATETIME date )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: <br>This Function returns the value of the release level for the Navajo Release<br>0 = No Release<br>1 = Release of 114,000 AF<br>2 = Relase greater of 166,000 or SpillAF<br>3 = Release of > 344,000 AF to get the reservoir back to full<br><br>The policy is based on the decision Tree used by the Navajo Dam Operator and is within the Flow Recomendations For the San Juan River published by the San Juan River Basin Recovery Implementation Program *1999 <br><br>RETURNS: List of the form &lcub;Water required for EOWY target pool elevation, Release level, Nose level, Nose volume, Excess release&rcub;<br><br>ARGUMENTS<br>1. DATETIME date - date used to determine calendar year of release level<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170502: Unclear to me whether Navajo operates on water year or calendar year at this point; a date is passed into the function as an argument, but the current timestep @&quot;t&quot; is also used in the function";
    BEGIN

      WITH NUMERIC waterRqdForEOWYTPE = "Max"( IF ( @"t" == @"Start Timestep" )
 THEN
  IF ( "GetMonth"( @"t" ) <= 2.00000000 OR "GetMonth"( @"t" ) >= 10.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   "WaterToAchieveEOYTPE"( "GetWaterYearEndDate"( @"t" ) )
  ENDIF
 ELSE
  "WaterToAchieveEOYTPE"( "GetWaterYearEndDate"( @"t" ) ) COMMENTED_BY "If the timestep is not the start timestep, it has to be March"
 ENDIF, 0.00000000 "acre-ft" ) + IF ( $ "NavajoData.Add6050SPRToAvailWater" ["Dec31ofYear"( @"t" )] == 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "ElevationToStorage"( % "Navajo", 6063.00000000 ) - "ElevationToStorage"( % "Navajo", 6050.00000000 )
 ENDIF COMMENTED_BY "In the event that an additional Spring Peak Release of water available to 6,050 ft. on Navajo is <br>requested, the flag NavajoData.Add6050SPRToAvailWater = 1, then the volume of water <br>between 6,063 and 6,050 is added to the Spring Peak Release. The approximate volume of that <br>water is 160.87 KAF. TP 8/4/2014" DO
  WITH NUMERIC releaseLevel = IF ( "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( date ) ) )
  THEN
   $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( date )]
  ELSE
   FOR ( NUMERIC iter IN "GetNumbers"( 1.00000000, 4.00000000, 1.00000000 ) ) WITH NUMERIC result = 0.00000000 DO
    IF ( waterRqdForEOWYTPE >= $ "NavajoData.SpringPeakReleaseLevels" ["Volume", iter - 1.00000000] )
    THEN
     iter
    ELSE
     result
    ENDIF
   ENDFOR
  ENDIF DO
   WITH NUMERIC noseLevel = IF ( releaseLevel == 4.00000000 )
   THEN
    FOR ( NUMERIC iter IN "GetNumbers"( 0.00000000, 10.00000000, 1.00000000 ) ) WITH NUMERIC result = 0.00000000 DO
     IF ( waterRqdForEOWYTPE - $ "NavajoData.SpringPeakReleaseLevels" ["Volume", 3.00000000] >= $ "NavajoData.SpringNoseLevels" ["Volume", iter] )
     THEN
      iter
     ELSE
      result
     ENDIF
    ENDFOR
   ELSE
    0.00000000
   ENDIF DO
    WITH NUMERIC noseVolume = IF ( releaseLevel == 4.00000000 )
    THEN
     waterRqdForEOWYTPE - $ "NavajoData.SpringPeakReleaseLevels" ["Volume", 3.00000000]
    ELSE
     0.00000000 "acre-ft"
    ENDIF DO
     WITH NUMERIC excessOfRelease = IF ( releaseLevel == 4.00000000 )
     THEN
      noseVolume - $ "NavajoData.SpringNoseLevels" ["Volume", noseLevel]
     ELSE
      IF ( NOT releaseLevel == 0.00000000 )
      THEN
       "Max"( waterRqdForEOWYTPE - $ "NavajoData.SpringPeakReleaseLevels" ["Volume", releaseLevel - 1.00000000], 0.00000000 "acre-ft" )
      ELSE
       "Max"( "WaterToAchieveEOYTPE"( "GetWaterYearEndDate"( @"t" ) ), 0.00000000 "acre-ft" )
      ENDIF
     ENDIF DO
      { waterRqdForEOWYTPE , releaseLevel , noseLevel , noseVolume , excessOfRelease }
     ENDWITH
    ENDWITH COMMENTED_BY "Calculate nose volume"
   ENDWITH COMMENTED_BY "Calculate the nose level"
  ENDWITH COMMENTED_BY "Calculate the release level"
 ENDWITH COMMENTED_BY "Water required to reach EOWY target pool elevation";

    END
    UUID "{496bde67-ac15-427a-9bef-f1f0f4608aa5}";;

    FUNCTION       "DetermineNavajoMonthlyFlowVolumeNew" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Sums flows for each month using the NavajoData.NavajoOuflowWithScale Slot.  These values will be returned as volume per month in Acre-ft and will become the Navajo.Outflow monthly values. <br><br>RETURNS: Monthly outflow as a sum of daily flows [L^3]<br><br>ARGUMENTS<br>1. DATETIME date - timestep date (end of month) specifying the month for which to calculate the outflow<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 8/7/2012";
    BEGIN

      "SumFlowsToVolume"( $ "NavajoData.MarchThruJulyDaily", "OffsetDate"( date, ( "GetDaysInMonth"( date ) / 1.00000000 "day" - 1.00000000 ) * - 1.00000000, "1 days" ), date );

    END
    UUID "{79e249a9-cc37-4d58-be6e-4c91191c552a}";;

    FUNCTION       "DailyOutflowsForNavajo" ( DATETIME date, NUMERIC releaseLevel, NUMERIC noseLevel, NUMERIC excessOfRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is called by the rule &quot;March through July Daily Release&quot; to calculate the daily release value from Navajo based on the date, release and nose levels for the year, and excess water available<br><br>RETURNS: Daily release rate<br><br>ARGUMENTS<br>1. DATETIME date - date on which to calculate the release rate<br>2. NUMERIC releaseLevel - annual release level for the reservoir<br>3. NUMERIC noseLevel - annual nose level for the reservoir<br>4. NUMERIC excessOfRelease - excess water available over base flow<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC peakReleaseValue = $ "NavajoData.SpringPeakReleaseByLevel" [date, releaseLevel] DO
  WITH NUMERIC noseReleaseValue = $ "NavajoData.SpringPeakNoseByLevel" [date, noseLevel] DO
   WITH NUMERIC peakAndNoseValue = peakReleaseValue + noseReleaseValue DO
    WITH LIST baseFlowDate = { 0.00000000 "day" , 6.00000000 "day" , 9.00000000 "day" , 13.00000000 "day" , 25.00000000 "day" } DO
     WITH NUMERIC baseFlowDays = "GetDayOfYear"( @"24:00:00 October 1, Current Year" ) - ( 155.00000000 "day" + GET @INDEX releaseLevel FROM baseFlowDate ) DO
      WITH NUMERIC baseFlowChange = excessOfRelease / baseFlowDays DO
       WITH NUMERIC flowValue = IF ( peakAndNoseValue > 0.00000000 "cfs" )
       THEN
        peakAndNoseValue
       ELSE
        IF ( "GetDayOfYear"( date ) < 155.00000000 "day" OR date > @"24:00:00 September 30, Current Year" )
        THEN
         $ "NavajoData.BaseRelease" []
        ELSE
         "Max"( $ "NavajoData.BaseRelease" [] + baseFlowChange, $ "NavajoData.BaseRelease" [] ) COMMENTED_BY "Release at least base flow, but more if available"
        ENDIF COMMENTED_BY "Release base flow prior to June 5 (June 4 in leap year) and after September 30"
       ENDIF DO
        flowValue + IF ( date > @"24:00:00 June 28, Current Year" )
        THEN
         "DebugDailyNavajoFunction"(  )
        ELSE
         0.00000000 "cfs"
        ENDIF
       ENDWITH
      ENDWITH COMMENTED_BY "Calculate amount by which to change base flow"
     ENDWITH COMMENTED_BY "Calculate the number of days at base flow based on the release level"
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{6833eac2-71db-4234-83de-3985ef3163c4}";;

    FUNCTION       "DetermineLowFlowsatNavajo" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: If the spring peak operations cause Navajo to go below 5,990 ft. determine the shortage sharing reduction in outflow and NIIP Diversion to keep Navajo from going below 5,990 ft.  5,990 ft is elevation for which NIIP can no longer divert water from Navajo Reservoir.<br><br>RETURN TYPE: List of lists of the form &lcub;Date, Navajo outflow, Navajo diversion&rcub;<br><br>ARGUMENTS: <none><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH DATETIME EndDate = "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12", @"Finish Timestep" ) DO
  FOR ( DATETIME date IN "GetDates"( @"t", EndDate, "1 months" ) ) WITH LIST result = {  } DO
   WITH LIST DateAndDiffStor = FOR ( DATETIME dateb IN "GetDates"( @"t", EndDate, "1 months" ) ) WITH LIST DateAndDiffStor = {  } DO
    APPEND { dateb , "Max"( "ElevationToStorage"( % "Navajo", $ "NavajoData.MinDesiredPoolElevation" [] ) - $ "Navajo.Storage" [dateb], 0.00000000 "acre-ft" ) } ONTO DateAndDiffStor
   ENDFOR DO
    WITH LIST DiffList = MAPLIST ( LIST DiffListCheck IN DateAndDiffStor ) DO
     GET @INDEX 1.00000000 FROM DiffListCheck
    ENDMAPLIST DO
     WITH NUMERIC MaxDiff = "MaxItem"( DiffList ) DO
      WITH NUMERIC MaxIndex = FIND MaxDiff WITHIN DiffList DO
       WITH NUMERIC MaxDiffWithEvap = MaxDiff + "SumSlot"( $ "Navajo.Evaporation", @"t", EndDate ) DO
        WITH LIST MaxDateLists = GET @INDEX MaxIndex FROM DateAndDiffStor DO
         WITH DATETIME MaxDate = "DateMin"( GET @INDEX 0.00000000 FROM MaxDateLists, @"Finish Timestep" ) DO
          WITH NUMERIC SummedOutflowValuesFromNavajo = "SumFlowsToVolume"( $ "Navajo.Outflow", @"t", MaxDate ) DO
           WITH NUMERIC SummedNIIPDiversions = "SumFlowsToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Depletion Requested", @"t", MaxDate ) DO
            WITH NUMERIC ReductionFactor = "Max"( ( SummedOutflowValuesFromNavajo + SummedNIIPDiversions - MaxDiffWithEvap ) / ( SummedOutflowValuesFromNavajo + SummedNIIPDiversions ), 0.00000000 ) DO
             IF ( date > MaxDate )
             THEN
              ( APPEND { date , $ "Navajo.Outflow" [date] , $ "Navajo.Diversion" [date] } ONTO result ) COMMENTED_BY "No reduction necessary"
             ELSE
              ( APPEND { date , "Max"( $ "Navajo.Outflow" [date] * ReductionFactor, "Min"( $ "NavajoData.MinimumOutflow" [], $ "Navajo.Inflow" [] ) ) , "Max"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [date] * ReductionFactor, 0.00000000 "cfs" ) } ONTO result ) COMMENTED_BY "Reduced outflows and diversions"
             ENDIF COMMENTED_BY "Append appropriate result to list"
            ENDWITH COMMENTED_BY "Calculate factor by which to reduce outflows and diversions"
           ENDWITH COMMENTED_BY "Calculate cumulative NIIP diversions"
          ENDWITH COMMENTED_BY "Calculate cumulative outflows"
         ENDWITH COMMENTED_BY "Find the earlier of MaxDate or the end of the model run"
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "Remove the dates from the prior list of lists and just keep the shortage values"
   ENDWITH COMMENTED_BY "Create list of lists with the form &lcub;Date, Storage shortage on the date&rcub;"
  ENDFOR
 ENDWITH COMMENTED_BY "Loop through dates between current timestep and the earlier of the finish timestep or the end of February of the next year";

    END
    UUID "{5aeea7c1-b321-415a-b7f7-be2e5d80fe8c}";;

    FUNCTION       "EstimateEvaporationNavajo" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This Function estimates the evaporation from March to July for the available water calculation.  The evaporation is calculated based on the total inflow to the reservoir and  a release of only the base flow.  An error was occuring where the area volume table was limiting the solving of the reservoir because taking an inflow and releasing only the base flow can result in higher storage levels than the table implies.  So the Min function with the equation and the 1,976,849 acre-ft is used right now because 1,977,850.0000999999 acre-ft is the maximum storage in the area volume table.  This limits the evaporation to be calculated based on the largest area in the table.  If the area volume curve is extended, then this min function can be removed. <br><br>RETURN TYPE: Estimate of the evaporation volume<br><br>ARGUMENTS<br>1. DATETIME startDate - beginning of the estimation period<br>2. DATETIME endDate - end of the estimation period<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/14/2012";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC evapCalc = 0.00000000 "acre-ft" DO
  evapCalc + "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( $ "Navajo.Storage" [@"t - 1"] + "SumFlowsToVolume"( $ "Navajo.Inflow", startDate, date ) - "SumNavajoBaseRelease"( startDate, date ) - FOR ( DATETIME niipDate IN startDate TO date ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
   "FlowToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [niipDate], niipDate ) + result
  ENDFOR, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000], date ) COMMENTED_BY "Estimated evaporation for &quot;date&quot;"
 ENDFOR COMMENTED_BY "Calculate estimate by adding the evaporation estimate for each date to a running total";

    END
    UUID "{b5ab81d9-cd8b-4cfe-876c-a0f8ad34d67d}";;

    FUNCTION       "IsLowFlowAdjustmentNecessary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a TRUE value if for any month between the current timestep and the earlier of the next February or the model Finish Timestep, the pool elevation drops below the MinDesiredPoolElevation value; otherwise, the function returns FALSE<br><br>RETURNS: TRUE (low flow adjustment necessary) or FALSE (no adjustment necessary)<br><br>ARGUMENTS:<none><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN "GetDates"( @"t", "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12", @"Finish Timestep" ), "1 months" ) ) WITH BOOLEAN result = FALSE DO
  IF ( $ "Navajo.Pool Elevation" [date] < $ "NavajoData.MinDesiredPoolElevation" [] )
  THEN
   TRUE
  ELSE
   result
  ENDIF
 ENDFOR;

    END
    UUID "{49e66a77-8e30-4633-9889-85593f4331a2}";;

    FUNCTION       "MaxDayOfMonth_pre201707" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the date for the end of the month containing the input argument &quot;date&quot;, including consideration for leap years.<br><br>RETURNS: Datetime representing the end of the month date [Datetime]<br><br>ARGUMENTS<br>1. DATETIME date<br><br>CONSTRAINTS: <NONE><br><br>.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Rewrite this function as MaxDayOfMonth = OffsetDate(date, [GetDaysInMonth(date)-GetDayOfMonth(date)]/1 ?day?, ?1 days?), and use it to replace calls to GetEndDayOfMonth also? Similar for MinDayOfMonth & GetStartDayOfMonth";
    BEGIN

      WITH NUMERIC MoNum = "GetMonth"( date ) DO
  IF ( MoNum == 1.00000000 )
  THEN
   "OffsetDate"( date, "Units NONE"( 31.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
  ELSE
   IF ( MoNum == 2.00000000 )
   THEN
    IF ( "LeapYear"( date ) )
    THEN
     "OffsetDate"( date, "Units NONE"( 60.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
    ELSE
     "OffsetDate"( date, "Units NONE"( 59.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
    ENDIF
   ELSE
    IF ( MoNum == 3.00000000 )
    THEN
     IF ( "LeapYear"( date ) )
     THEN
      "OffsetDate"( date, "Units NONE"( 91.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
     ELSE
      "OffsetDate"( date, "Units NONE"( 90.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
     ENDIF
    ELSE
     IF ( MoNum == 4.00000000 )
     THEN
      IF ( "LeapYear"( date ) )
      THEN
       "OffsetDate"( date, "Units NONE"( 121.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
      ELSE
       "OffsetDate"( date, "Units NONE"( 120.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
      ENDIF
     ELSE
      IF ( MoNum == 5.00000000 )
      THEN
       IF ( "LeapYear"( date ) )
       THEN
        "OffsetDate"( date, "Units NONE"( 152.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
       ELSE
        "OffsetDate"( date, "Units NONE"( 151.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
       ENDIF
      ELSE
       IF ( MoNum == 6.00000000 )
       THEN
        IF ( "LeapYear"( date ) )
        THEN
         "OffsetDate"( date, "Units NONE"( 182.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
        ELSE
         "OffsetDate"( date, "Units NONE"( 181.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
        ENDIF
       ELSE
        IF ( MoNum == 7.00000000 )
        THEN
         IF ( "LeapYear"( date ) )
         THEN
          "OffsetDate"( date, "Units NONE"( 213.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
         ELSE
          "OffsetDate"( date, "Units NONE"( 212.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
         ENDIF
        ELSE
         IF ( MoNum == 8.00000000 )
         THEN
          IF ( "LeapYear"( date ) )
          THEN
           "OffsetDate"( date, "Units NONE"( 244.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
          ELSE
           "OffsetDate"( date, "Units NONE"( 243.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
          ENDIF
         ELSE
          IF ( MoNum == 9.00000000 )
          THEN
           IF ( "LeapYear"( date ) )
           THEN
            "OffsetDate"( date, "Units NONE"( 274.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
           ELSE
            "OffsetDate"( date, "Units NONE"( 273.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
           ENDIF
          ELSE
           IF ( MoNum == 10.00000000 )
           THEN
            IF ( "LeapYear"( date ) )
            THEN
             "OffsetDate"( date, "Units NONE"( 305.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
            ELSE
             "OffsetDate"( date, "Units NONE"( 304.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
            ENDIF
           ELSE
            IF ( MoNum == 11.00000000 )
            THEN
             IF ( "LeapYear"( date ) )
             THEN
              "OffsetDate"( date, "Units NONE"( 335.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ELSE
              "OffsetDate"( date, "Units NONE"( 334.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ENDIF
            ELSE
             IF ( "LeapYear"( date ) )
             THEN
              "OffsetDate"( date, "Units NONE"( 366.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ELSE
              "OffsetDate"( date, "Units NONE"( 365.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ENDIF
            ENDIF
           ENDIF
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{6a819919-03ca-4846-8ab9-8ef361312e2f}";;

    FUNCTION       "MaxDayOfMonth" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the date for the end of the month containing the input argument &quot;date&quot;, including consideration for leap years.<br><br>RETURNS: Datetime representing the end of the month date [Datetime]<br><br>ARGUMENTS<br>1. DATETIME date<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Rewrite this function as MaxDayOfMonth = OffsetDate(date, [GetDaysInMonth(date)-GetDayOfMonth(date)]/1 ?day?, ?1 days?), and use it to replace calls to GetEndDayOfMonth also? Similar for MinDayOfMonth & GetStartDayOfMonth.";
    BEGIN

      "OffsetDate"( date, ( "GetDaysInMonth"( date ) - "GetDayOfMonth"( date ) ) / 1.00000000 "day", "1 days" );

    END
    UUID "{041cc47f-b813-4bf9-bf49-868a544cfb19}";;

    FUNCTION       "MinDayOfMonth" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date for the beginning of the month containing the input argument &quot;date&quot;. The function assumes that &quot;date&quot; represents the last day of a month.<br><br>RETURNS: Beginning date of month [Datetime]<br><br>ARGUMENTS<br>1. DATETIME date - end date of the month for which the beginning date is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Rewrite this function as MinDayOfMonth = OffsetDate(date, GetDayOfMonth(date)]/1 ?day? - 1, ?-1 days?), and use it to replace calls to GetStartDayOfMonth also? Similar for MaxDayOfMonth & GetEndDayOfMonth.";
    BEGIN

      WITH NUMERIC MoNum = "GetMonth"( date ) DO
  IF ( MoNum == 1.00000000 )
  THEN
   "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
  ELSE
   IF ( MoNum == 2.00000000 )
   THEN
    IF ( "LeapYear"( date ) )
    THEN
     "OffsetDate"( date, "Units NONE"( - 28.00000000 "day" ), "1 days" )
    ELSE
     "OffsetDate"( date, "Units NONE"( - 27.00000000 "day" ), "1 days" )
    ENDIF
   ELSE
    IF ( MoNum == 3.00000000 )
    THEN
     "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
    ELSE
     IF ( MoNum == 4.00000000 )
     THEN
      "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
     ELSE
      IF ( MoNum == 5.00000000 )
      THEN
       "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
      ELSE
       IF ( MoNum == 6.00000000 )
       THEN
        "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
       ELSE
        IF ( MoNum == 7.00000000 )
        THEN
         "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
        ELSE
         IF ( MoNum == 8.00000000 )
         THEN
          "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
         ELSE
          IF ( MoNum == 9.00000000 )
          THEN
           "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
          ELSE
           IF ( MoNum == 10.00000000 )
           THEN
            "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
           ELSE
            IF ( MoNum == 11.00000000 )
            THEN
             "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
            ELSE
             "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
            ENDIF
           ENDIF
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{fa5192c7-6284-4f04-ad38-b700b0554834}";;

    FUNCTION       "NavajoAboveMaxPEOperations" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: If the Navajo pool elevation is above the maximum then release water to reduce the pool elevation. Return the new outflow for Navajo, the ouflow change as a volume and the volume that needed to be released in order to get to the Dam Protection pool elevation.<br><br>RETURNS: List of form &lcub;Modified Outflow, Outflow volume change, Volume released&rcub;<br><br>ARGUMENTS:<none><br><br>CONSTRAINTS: Maximum release of 5,000 cfs based on Max Release table<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/4/2015";
    BEGIN

      WITH NUMERIC navajoMonthlyOutflow = "Min"( $ "Navajo.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] ), @"t" ), 5000.00000000 "cfs" ) DO
  WITH NUMERIC navajoMonthlyVolumeChange = "FlowToVolume"( navajoMonthlyOutflow - $ "Navajo.Outflow" [], @"t" ) DO
   WITH NUMERIC volReleasedForDamProtection = "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] ) DO
    { navajoMonthlyOutflow , navajoMonthlyVolumeChange , volReleasedForDamProtection }
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Find outflow <=5,000 cfs that will reduce pool elevation to dam protection level; <br>5,000 cfs is the approximate maximum release (at interpolated pool elevation of 6,103 ft)";

    END
    UUID "{e4f4f145-ab8a-4a47-b51e-fefe6e844a59}";;

    FUNCTION       "SumNavajoBaseRelease" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the sum of outflows from &quot;startDate&quot; to &quot;endDate&quot;<br><br>RETURNS: Volume released between startDate and endDate<br><br>ARGUMENTS:<br>1. DATETIME startDate - date on which to begin sum<br>2. DATETIME endDate - date on which to end sum<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
  result + "FlowToVolume"( $ "Navajo.Outflow" [], date )
 ENDFOR;

    END
    UUID "{d6ec78a9-2d26-4401-9524-ee8d5eb1a556}";;

    FUNCTION       "WaterToAchieveEOYTPE" ( DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses a water balance to calculate the water available (over base releases) between the current time and the date in the argument &quot;endDate&quot;, in order to achieve the end-of-water-year pool elevation target for the year containing &quot;endDate&quot;.<br><br>RETURNS: Water volume available for release<br><br>ARGUMENTS<br>1. DATETIME endDate - date that specifies the end of the period for which to calculate available water<br><br>CONSTRAINTS<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC AvailableWater = $ "Navajo.Storage" [@"t - 1"] COMMENTED_BY "Beginning storage" + "SumFlowsToVolume"( $ "Navajo.Inflow", @"t", endDate ) COMMENTED_BY "Inflow volume" - "SumNavajoBaseRelease"( @"t", endDate ) COMMENTED_BY "Base flow release volume" - "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" ["Dec31ofYear"( endDate )] ) COMMENTED_BY "Storage at target PE" - FOR ( DATETIME niipDate IN @"t" TO endDate ) WITH NUMERIC niipVol = 0.00000000 "acre-ft" DO
  "FlowToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [niipDate], niipDate ) + niipVol
 ENDFOR COMMENTED_BY "NIIP diversion volume requested" - "EstimateEvaporationNavajo"( @"t", endDate ) COMMENTED_BY "Evaporation volume" DO
  AvailableWater
 ENDWITH;

    END
    UUID "{d133f581-6804-4d86-833d-eb2380e91832}";;

  END
  UUID "{35cc74a6-b00a-43ae-a87a-4f0dbc4a9094}";;

  UTILITY_GROUP "Powell Functions - MTOM Only";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "B1_Branch_UpperBalancingTierVolume" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the Powell release volume when the tier has been designated as Upper Elevation Balancing, Branch B1. The release attempts to balance the Powell and Mead end of water year storages, within the release range of 8.23 MAF and 9.0 MAF, if the elevation criteria are met; otherwise, the release is set to 8.23 MAF<br><br>RETURNS: Annual release volume from Lake Powell<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date at which to compare the Powell and Mead storages<br><br>CONSTRAINTS: Releases no less than 8.23 MAF and no more than 9.0 MAF<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT $ "PowellData.UpperTierB4MinAnnualRelease" [];
    MAX_CONSTRAINT $ "PowellData.UpperTierB4MaxAnnualRelease" [];
    NOTES          "DEVELOPMENT NOTES<br>MC, 20160801: Included consideration for possible untransferred carryover volume between Powell and Mead<br>MC, 20170501: Added Post-Execution Checks and removed unneeded call to user-defined function EnsureReleaseLimits, which applied the same constraints that are now in the Post-Execution Checks<br>SB, 20180925: Added function 'GetProjectedPoolElevation' instead of using Mead and Powell Pool Elevation. ";
    BEGIN

      WITH DATETIME eoyDate = "Dec31ofYear"( eowyDate ) DO
  WITH NUMERIC CarryoverVolume = NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [eoyDate] ) DO
   WITH NUMERIC PowellEffectivePool = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", "GetProjectedPoolElevation"( "Powell", eowyDate ) ) - CarryoverVolume ) DO
    WITH NUMERIC MeadEffectivePool = "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", eowyDate ) ) + CarryoverVolume ) DO
     IF ( MeadEffectivePool <= 1075.00000000 "ft" AND PowellEffectivePool > 3575.00000000 "ft" OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", eoyDate ) AND $ "PowellData.UpperElevBalBranch" [eoyDate] == 1.40000000 ) COMMENTED_BY "If the tier specification is user input for UEB, then release what is suggested for <br>that tier. This is placed so that if a specific Tier and balancing branch for any <br>year, but specifically WY1 has been made, then the logic will honor that and <br>estimate a balancing release instead of an 8.23 MAF release. TP 10/17/2017 <br>" )
     THEN
      "EqualizationReleaseWithCarryover"( eowyDate )
     ELSE
      $ "PowellData.BaseAnnualRelease" [] COMMENTED_BY "BaseAnnualRelease is 8.23 MAF"
     ENDIF
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "Calculate effective pool elevations as if any carryover volume had been transferred for comparison to pool elevation trigger levels"
 ENDWITH COMMENTED_BY "If Mead's EOWY elevation is less than 1075' and Powell's EOWY elevation is greater than 3575' then release enough to balance <br>the storages up to 9.0 MAF and no less than 8.23 MAF annual release volume.  Otherwise just release 8.23 MAF.";

    END
    UUID "{7e791855-8808-430b-b105-c42fd45b445f}";;

    FUNCTION       "B2_Branch_UpperBalancingTierVolume" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the Powell release volume when the tier has been designated as Upper Elevation Balancing, Branch B2. The release attempts to balance the Powell and Mead end of water year storages, within the release range of 7.0 MAF and 9.0 MAF<br><br>RETURNS: Annual release volume from Lake Powell<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date at which to compare the Powell and Mead storages<br><br>CONSTRAINTS: Releases no less than 7.0 MAF and no more than 9.0 MAF<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>MC, 20160801: Included consideration for possible untransferred carryover volume between Powell and Mead";
    BEGIN

      "EnsureReleaseLimits"( "EqualizationReleaseWithCarryover"( eowyDate ), $ "PowellData.UpperTierB2MinAnnualRelease" [], $ "PowellData.UpperTierB2MaxAnnualRelease" [] );

    END
    UUID "{4317492b-9af3-4cbc-9483-47a9cf351e77}";;

    FUNCTION       "CalcReleaseForMaxPoolElevation" ( LIST waterYearDates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: this function calculates a minimum annual volume needed to be released from Powell in order to keep the reservoir from overfilling and crashing the run during the preliminary annual volume setting phase.  The preliminary volume will be 8.23 MAF in most cases, but if the inflows are high or the starting storage in Powell is high and 8.23 MAF is not enough to keep Powell from overfilling, then this function calculates the annual volume needing to be released in order to just prevent overfilling and crashing the model (does not currently include terms for evap and bankstorage).  An exact annual release volume will be calculated in subsequent rules. - sc 03/25/11<br><br>RETURNS: Water volume required to be released from Lake Powell to prevent overfilling [L^3]<br><br>ARGUMENTS:<br>1. LIST waterYearDates - list of the dates remaining in the water year<br><br>CONSTRAINTS: Value greater than or equal to 0 acre-feet<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT 0.00000000 "acre-ft";
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 03/25/2011";
    BEGIN

      WITH DATETIME firstTimestep = GET @INDEX 0.00000000 FROM waterYearDates DO
  WITH DATETIME lastTimestep = IF ( ( LENGTH waterYearDates ) >= 3.00000000 )
  THEN
   GET @INDEX ( LENGTH waterYearDates ) - 3.00000000 FROM waterYearDates
  ELSE
   GET @INDEX ( LENGTH waterYearDates ) - 1.00000000 FROM waterYearDates
  ENDIF DO
   ( ( $ "Powell.Storage" ["OffsetDate"( firstTimestep, - 1.00000000, " 1 months" )] + "SumFlowsToVolume"( $ "Powell.Inflow", firstTimestep, lastTimestep ) - "ElevationToStorage"( % "Powell", 3711.00000000 "feet" ) ) / ( ( ( lastTimestep - firstTimestep ) + 1.00000000 "month" ) * 0.90000000 ) ) COMMENTED_BY "The factor 0.9 in the denominator ensures the calculated volume is slightly greater than the volume that takes the pool elevation just to its maximum"
  ENDWITH COMMENTED_BY "lastTimestep date is July 31 unless firstTimestep is August or September, in which case lastTimestep is September 30"
 ENDWITH COMMENTED_BY "The period firstTimestep to lastTimestep is used to calculate an annualized volume to release from Powell to avoid overfilling." * 1.00000000 "year";

    END
    UUID "{af7f1ac0-1027-4da1-9c77-dc3f6ef8fe75}";;

    FUNCTION       "CurrentAnnualVolume" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and returns the annual release volume for Powell for the water year in which the passed-in date lies.<br><br>RETURNS: Target annual release volume in 1000 acre-feet<br><br>ARGUMENTS:<br>1. DATETIME date - a date within the run period<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: sc, 20110215";
    BEGIN

      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( date ) )];

    END
    UUID "{201aa2ce-bf55-497b-82f3-185c94ca607b}";;

    FUNCTION       "EqualizationRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function attempts to equalize the end of water year Powell and Mead storages by adding half the difference between the currently calculated end of water year storages to the target annual release from Powell<br><br>RETURNS: Annual release volume in 1000 kaf<br><br>ARGUMENTS:<br>1. DATETIME EOWYdate - the end of water year date for which the storages should be compared<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 2018/10/17: Remove carryover volume from Powell Storage and add to Mead storage when determining equalization volume. Equalization needs to know about carryover volume from the previous year in some functions in order to calculate the correct TARV, specifically when in equalization with a release of 8.23 MAF.  ";
    BEGIN

      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( ( $ "Powell.Storage" [EOWYDate] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) - ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) ) / ( 2.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] );

    END
    UUID "{c504226f-f71b-4e0f-a225-90e236233058}";;

    FUNCTION       "EqualizationTierCalculationForRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the target annual release volume and the controlling equalization condition (constraint) when Powell is operating in the Equalization tier; the controlling equalization condition represents the condition constraining the calculated release volume<br><br>RETURNS: List of the form &lcub;Annual release volume in 1000 kaf, Controlling Equalization Condition&rcub;<br><br>ARGUMENTS:<br>1. DATETIME EOWYdate - the end of water year date <br><br>CONSTRAINTS: The calculated release volume may be constrained by: the Powell equalization level for the water year; equalized storage in Powell and Mead; Mead pool elevation reaches 1,105 ft; Powell pool elevation reaches 20 ft less than the equalization level for the water year<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 2018/10/17: Equalization needs to know about carryover volume from the previous year in this function in order to calculate the correct TARV, specifically when in equalization with a release of 8.23 MAF. This occurs in multiple places in the ?EqualizationTierCalculationForRelease? function. ";
    BEGIN

      WITH NUMERIC PowellVolumeOverEqLevel = "Max"( ( $ "Powell.Storage" [EOWYDate] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) ), 0.00000000 "acre-ft" ) DO
  WITH NUMERIC EqualizationReleaseVolume = "EqualizationRelease"( EOWYDate ) DO
   WITH NUMERIC PreliminaryReleaseVolume = "Min"( PowellVolumeOverEqLevel / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )], EqualizationReleaseVolume ) DO
    WITH NUMERIC MeadElevationWithPrelimRelease = IF ( ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) + ( PreliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) * ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) >= "ElevationToStorage"( % "Mead", 1229.00000000 "feet" ) )
    THEN
     1229.00000000 "feet"
    ELSE
     "StorageToElevation"( % "Mead", ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) + ( PreliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) * ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) )
    ENDIF DO
     IF ( MeadElevationWithPrelimRelease < 1105.00000000 "ft" )
     THEN
      WITH NUMERIC totalVolumeToRaiseMeadTo1105 = "Max"( ( "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) ) / ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ), 0.00000000 "acre-ft" ) DO
       WITH NUMERIC PowellVolumeOverEqLevelLess20ft = "Max"( ( $ "Powell.Storage" [EOWYDate] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ), 0.00000000 "acre-ft" ) DO
        IF ( EqualizationReleaseVolume < totalVolumeToRaiseMeadTo1105 AND EqualizationReleaseVolume < PowellVolumeOverEqLevelLess20ft / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) )
        THEN
         { EqualizationReleaseVolume + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.30000000 }
        ELSE
         IF ( totalVolumeToRaiseMeadTo1105 < EqualizationReleaseVolume AND totalVolumeToRaiseMeadTo1105 < PowellVolumeOverEqLevelLess20ft )
         THEN
          { totalVolumeToRaiseMeadTo1105 + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.40000000 }
         ELSE
          { PowellVolumeOverEqLevelLess20ft / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.50000000 }
         ENDIF
        ENDIF COMMENTED_BY "Choose the minimum of the equalization release, the release to take Mead to 1105 and the release to take Powell down to the equalization level less 20'"
       ENDWITH COMMENTED_BY "Volume of Powell storage above the equalization level minus 20 feet"
      ENDWITH COMMENTED_BY "Volume needed to release from Powell to raise Mead elevation to 1105'"
     ELSE
      IF ( PreliminaryReleaseVolume == PowellVolumeOverEqLevel / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] )
      THEN
       { PreliminaryReleaseVolume , 0.10000000 }
      ELSE
       { PreliminaryReleaseVolume , 0.20000000 }
      ENDIF
     ENDIF COMMENTED_BY "Check if the preliminary release volume takes Mead above 1105'.  If so the preliminary volume is chosen, if not continue."
    ENDWITH COMMENTED_BY "EOWY Elevation of Mead with the preliminaryReleaseVolume release from Powell"
   ENDWITH COMMENTED_BY "Preliminary annual volume release before the Mead elevation check."
  ENDWITH COMMENTED_BY "Total volume that would need to be released to equalize storage"
 ENDWITH COMMENTED_BY "Total Volume in Powell above the Current Equalization Level";

    END
    UUID "{4ae12457-0e73-4438-9240-5d4adc10db15}";;

    FUNCTION       "FindReleaseUpperBoundColumn" ( NUMERIC release )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function finds the index corresponding to the first column in PowellData.PowellMonthlyReleaseTable with an annual total value greater than the release volume value provided as a parameter. <br><br>RETURNS: Column index value<br><br>ARGUMENTS:<br>1. NUMERIC release - annual release volume for Powell<br><br>CONSTRAINTS: Min - 0; Max - Number of columns in table - 1<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  WHILE ( release - releaseTable ["AnnualTotal", result] > 0.01000000 "1000 acre-ft" ) WITH NUMERIC result = 0.00000000 DO
   result + 1.00000000
  ENDWHILE
 ENDWITH COMMENTED_BY "While the annual total of the column with index &quot;result&quot; is less than the provided release volume, increment the value of &quot;result&quot;";

    END
    UUID "{bf341ebe-8f1e-447a-962b-02eeb4aea9cf}";;

    FUNCTION       "FindReleaseLowerBoundColumn" ( NUMERIC release, NUMERIC upperbound )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function finds the index corresponding to the first column in PowellData.PowellMonthlyReleaseTable with an annual total value less than the release volume value provided as a parameter. If the provided release volume is exactly equal to a column total, the lower bound index and upper bound index are equal. <br><br>RETURNS: Column index value<br><br>ARGUMENTS:<br>1. NUMERIC release - annual release volume for Powell<br>2. NUMERIC upperbound - index of the upper bound column in the table<br><br>CONSTRAINTS: Min - 0; Max - Number of columns in table - 1<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  IF ( releaseTable ["AnnualTotal", upperbound] - release < 0.10000000 "1000 acre-ft" )
  THEN
   upperbound
  ELSE
   upperbound - 1.00000000
  ENDIF
 ENDWITH;

    END
    UUID "{68a19f44-fe2e-4dfd-aee8-38f7dddb7056}";;

    FUNCTION       "GetPowellReleasesCorrectedForBypass" ( LIST InitialDateRelease )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list in the form of &lcub;Date, Release, Carryover Volume&rcub; and estimates a pool elevation for each month with those releases. The function creates a series of  item lists in the form &lcub;Date, Release, Pool elevation, Carryover Volume, Bypass Constrained Volume&rcub; where if the estimated pool elevation is too low a bypass release is calculated. The pool elevation that goes into the three item list is the calculated pool elevation from the lesser of the outflow that was passed in or the determined bypass outflow. This is passed into the rule Set Powell Outflow and the outflow for Powell is set with these values.<br><br>RETURNS: List of lists of the form &lcub;Date, Release, Pool elevation, Carryover Volume, Bypass Constrained Volume&rcub;<br><br>ARGUMENTS:<br>1. LIST initialDateRelease - list of lists of the form &lcub;Date, Release, Carryover Volume&rcub;<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "AUTHOR, DATE: TP, 20130701<br><br>SB, 20210216: Added bypass constrained volume as new item and allow for this volume to be released during the current WY.<br>SB, 20190711: The rule was not setting carryover when bypass constrained the outflow below TARV. The calculation of 'addCarryoverIfAny' was altered to add in any carryover created due to bypass constrained outflows.<br>MC, 20170501: Updated internal variable names and removed some internal variables for readability";
    BEGIN

      WITH LIST sortedInitDateRelease = "Sort"( InitialDateRelease ) DO
  WITH DATETIME InitialDate = "OffsetDate"( GET @INDEX 0.00000000 FROM GET @INDEX 0.00000000 FROM sortedInitDateRelease, - 1.00000000, "1 Months" ) DO
   WITH LIST listWithInitDate = FOR ( LIST index IN sortedInitDateRelease ) WITH LIST result = { { InitialDate , "null" , $ "Powell.Pool Elevation" [InitialDate] , GET @INDEX 2.00000000 FROM GET @INDEX 0.00000000 FROM InitialDateRelease , 0.00000000 "acre-ft" } } DO
    WITH NUMERIC PreviousResultPE = GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
     WITH DATETIME PreviousDate = GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
      WITH DATETIME CurrentDate = "OffsetDate"( PreviousDate, 1.00000000, "1 Months" ) DO
       WITH NUMERIC PreviousCarryover = GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
        WITH NUMERIC CurrentEstRelease = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM sortedInitDateRelease DO
         WITH NUMERIC PreviousVolConstrained = GET @INDEX 4.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
          WITH NUMERIC AdjOutflow = IF ( PreviousVolConstrained > 0.00000000 "acre-ft" )
          THEN
           IF ( "EstimatePowellPEGivenOutflow"( PreviousResultPE, CurrentEstRelease, CurrentDate ) <= $ "PowellData.PowellMinPowerPoolElevation" [] )
           THEN
            "Min"( "IterateBypassCapacity"( PreviousResultPE, CurrentEstRelease, CurrentDate ), "VolumeToFlow"( PreviousVolConstrained, CurrentDate ) + CurrentEstRelease )
           ELSE
            "VolumeToFlow"( "Min"( "ElevationToStorage"( % "Powell", PreviousResultPE ) - "ElevationToStorage"( % "Powell", $ "PowellData.PowellMinPowerPoolElevation" [] ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "PowellEvapEstimation"( CurrentDate, PreviousResultPE, $ "PowellData.PowellMinPowerPoolElevation" [] ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ), PreviousVolConstrained + "FlowToVolume"( CurrentEstRelease, CurrentDate ) ), CurrentDate ) COMMENTED_BY "Try to release previously constrained volume if possible while trying to keep Powell power pool <br>elevation <br>"
           ENDIF
          ELSE
           IF ( "EstimatePowellPEGivenOutflow"( PreviousResultPE, CurrentEstRelease, CurrentDate ) <= $ "PowellData.PowellMinPowerPoolElevation" [] )
           THEN
            "Min"( "IterateBypassCapacity"( PreviousResultPE, CurrentEstRelease, CurrentDate ), CurrentEstRelease )
           ELSE
            CurrentEstRelease
           ENDIF
          ENDIF DO
           WITH NUMERIC NewPE = "EstimatePowellPEGivenOutflow"( PreviousResultPE, AdjOutflow, CurrentDate ) DO
            WITH NUMERIC NewVolConstrained = "FlowToVolume"( CurrentEstRelease - AdjOutflow, CurrentDate ) + PreviousVolConstrained DO
             WITH NUMERIC addCarryoverIfAny = IF ( ( ( LENGTH result ) == LENGTH InitialDateRelease ) AND PreviousCarryover < 0.05000000 "acre-ft" )
             THEN
              "Min"( PreviousCarryover, GET @INDEX 2.00000000 FROM index ) + GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH InitialDateRelease ) - 1.00000000 FROM InitialDateRelease
             ELSE
              "Min"( PreviousCarryover, GET @INDEX 2.00000000 FROM index ) + NewVolConstrained
             ENDIF COMMENTED_BY "Want to use the original InitialDateRelease because the sorted version does not <br>have any carryover that needs to be released next year. <br>" DO
              APPEND { CurrentDate , AdjOutflow , NewPE , addCarryoverIfAny * "DebuggerStop"(  ) , NewVolConstrained } ONTO result
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH COMMENTED_BY "Adjust outflow when Powell falls below a buffered power pool elevation or when the outflow was <br>previously constrained by the bypass tubes  <br>"
         ENDWITH COMMENTED_BY "Retrieve the previous volume not released due to bypass constraints <br>"
        ENDWITH COMMENTED_BY "Retrieve the release passed into the function for the current date"
       ENDWITH COMMENTED_BY "Retrieve the carryover created from the previous month <br>"
      ENDWITH COMMENTED_BY "Set current date"
     ENDWITH COMMENTED_BY "Retrieve previous result date"
    ENDWITH COMMENTED_BY "Retrieve previous result PE"
   ENDFOR DO
    ( REMOVE ITEM @INDEX 0.00000000 FROM listWithInitDate ) COMMENTED_BY "Remove the unneeded first element of the list of lists"
   ENDWITH COMMENTED_BY "Initialize the list with the timestep and pool elevation prior to the first date in the argument list"
  ENDWITH
 ENDWITH;

    END
    UUID "{9be1bf79-1934-4d5f-a4cd-8142ad37ca25}";;

    FUNCTION       "CalculatePowellMonthlyRelease" ( LIST datesToEOWY, NUMERIC UpperColumn, NUMERIC LowerColumn, NUMERIC RemainingAnnualVolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume does a linear interpolation on that table to find releases that sum up exactly to the annual volume set for Powell.  If the passed in set of dates is the first water year in the run, ie starts with the run's start timestep, then this function will make an adjustment to the releases that were calculated by doing the linear interpolation to account for what was released int he months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List of lists of the form &lcub;date, release, remaining volume over the lower bound to be released&rcub;<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates to the end of the water year<br>2. NUMERIC UpperColumn - index specifying the upper bound column in the table PowellData.PowellMontlhlyReleaseTable<br>3. NUMERIC LowerColumn - index specifying the lower bound column<br>4. NUMERIC RemainingAnnualVolume - the remaining annual volume to be released; <br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR/DATE: SC, 20110325<br>MC, 20170501: The original version of the model did not have RemainingAnnualVolume as an input, but calculated the remaining volume based on the target annual volume and the volume released prior to the model run; this version provides more flexibility to calculate releases for time periods different than those that begin with the current timestep<br>MC, 20170608: See note about necessity of check on volume in light of that type of check in calling function, GetPowellMonthlyReleases<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  WITH LIST UpperBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
   WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
    APPEND releaseTable [monthsSinceEOWY + 1.00000000, UpperColumn] ONTO result
   ENDWITH
  ENDFOR DO
   WITH LIST LowerBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
    WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
     APPEND releaseTable [monthsSinceEOWY + 1.00000000, LowerColumn] ONTO result
    ENDWITH
   ENDFOR DO
    WITH NUMERIC RemainingVolumeAboveLowerBounds = RemainingAnnualVolume - "Sum"( LowerBoundList ) DO
     WITH LIST differenceList = FOR ( NUMERIC index IN UpperBoundList ) WITH LIST result = {  } DO
      WITH NUMERIC diff = ( GET @INDEX LENGTH result FROM UpperBoundList ) - GET @INDEX LENGTH result FROM LowerBoundList DO
       APPEND diff ONTO result
      ENDWITH
     ENDFOR DO
      WITH LIST tempList = WHILE ( ( LENGTH result ) < LENGTH differenceList ) WITH LIST result = {  } DO
       APPEND { { GET @INDEX LENGTH result FROM datesToEOWY , GET @INDEX LENGTH result FROM differenceList , GET @INDEX LENGTH result FROM LowerBoundList } , GET @INDEX LENGTH result FROM differenceList } ONTO result
      ENDWHILE DO
       WITH LIST sortedList = "SortPairsDescending"( tempList ) DO
        WITH LIST AlteredReleaseFromTable = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = { { 0.00000000 , 0.00000000 , RemainingVolumeAboveLowerBounds } } DO
         WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
          WITH NUMERIC addedRelease = "Min"( GET @INDEX 1.00000000 FROM GET @INDEX index FROM sortedList, GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) DO
           WITH NUMERIC NewVolRemainAbvLB = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - addedRelease DO
            APPEND { GET @INDEX 0.00000000 FROM GET @INDEX index FROM sortedList , "VolumeToFlow"( "Min"( ( ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM sortedList ) + addedRelease ), RemainingAnnualVolume ) COMMENTED_BY "Do not release more than the total remaining annual volume (MC, 20160907)", GET @INDEX 0.00000000 FROM GET @INDEX index FROM sortedList ) , NewVolRemainAbvLB * "DebuggerStop"(  ) } ONTO result
           ENDWITH COMMENTED_BY "Update remaining total volume over LB to be released"
          ENDWITH COMMENTED_BY "Minimum of monthly capacity available over LB and remaining total volume over LB to be released"
         ENDWITH
        ENDFOR COMMENTED_BY "Initial list element is &lcub;0, 0, RemainingVolumeAboveLowerBounds&rcub;, subsequent elements are of the form: <br>&lcub;Month i, Flow rate for month i, Remaining vol over LB after month i release&rcub;" DO
         WITH NUMERIC RemainingVol = GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH AlteredReleaseFromTable ) - 1.00000000 FROM AlteredReleaseFromTable DO
          IF ( RemainingVol <= 1.00000000 "acre-feet" )
          THEN
           WITH LIST AdjMonthlyReleases = REMOVE ITEM @INDEX 0.00000000 FROM AlteredReleaseFromTable DO
            AdjMonthlyReleases
           ENDWITH
          ELSE
           WITH LIST AlteredReleases = REMOVE ITEM @INDEX 0.00000000 FROM AlteredReleaseFromTable DO
            WITH LIST NextLowerBoundList = UpperBoundList DO
             WITH NUMERIC NextUpperColumn = UpperColumn + 1.00000000 DO
              WITH LIST NextUpperBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
               WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
                APPEND releaseTable [monthsSinceEOWY + 1.00000000, NextUpperColumn] ONTO result
               ENDWITH
              ENDFOR DO
               WITH LIST NextDifferenceList = FOR ( NUMERIC index IN NextUpperBoundList ) WITH LIST result = {  } DO
                WITH NUMERIC diff = ( GET @INDEX LENGTH result FROM NextUpperBoundList ) - GET @INDEX LENGTH result FROM NextLowerBoundList DO
                 APPEND diff ONTO result
                ENDWITH
               ENDFOR DO
                WITH LIST tempAlteredList = WHILE ( ( LENGTH result ) < LENGTH AlteredReleases ) WITH LIST result = {  } DO
                 APPEND { GET @INDEX LENGTH result FROM AlteredReleases , GET @INDEX 0.00000000 FROM GET @INDEX LENGTH result FROM AlteredReleases } ONTO result
                ENDWHILE DO
                 WITH LIST ResortedAlteredList = "SortPairsAscending"( tempAlteredList ) DO
                  WITH LIST NextTempList = WHILE ( ( LENGTH result ) < LENGTH NextDifferenceList ) WITH LIST result = {  } DO
                   APPEND { { GET @INDEX LENGTH result FROM datesToEOWY , GET @INDEX LENGTH result FROM NextDifferenceList , GET @INDEX 1.00000000 FROM GET @INDEX LENGTH result FROM ResortedAlteredList } , GET @INDEX LENGTH result FROM NextDifferenceList } ONTO result
                  ENDWHILE DO
                   WITH LIST NextSortedList = "SortPairsDescending"( NextTempList ) DO
                    WITH LIST NextAlteredReleaseFromTable = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = { { 0.00000000 , 0.00000000 , RemainingVol } } DO
                     WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                      WITH NUMERIC NextAddedRelease = "Min"( GET @INDEX 1.00000000 FROM GET @INDEX index FROM NextSortedList, GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) DO
                       WITH NUMERIC NextDiffInVol = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - NextAddedRelease DO
                        APPEND { GET @INDEX 0.00000000 FROM GET @INDEX index FROM NextSortedList , "VolumeToFlow"( ( NextAddedRelease + "FlowToVolume"( GET @INDEX 2.00000000 FROM GET @INDEX index FROM NextSortedList, GET @INDEX 0.00000000 FROM GET @INDEX index FROM NextSortedList ) ), GET @INDEX 0.00000000 FROM GET @INDEX index FROM NextSortedList ) , NextDiffInVol * "DebuggerStop"(  ) } ONTO result
                       ENDWITH
                      ENDWITH
                     ENDWITH
                    ENDFOR DO
                     WITH LIST AdjMonthlyReleases = REMOVE ITEM @INDEX 0.00000000 FROM NextAlteredReleaseFromTable DO
                      AdjMonthlyReleases
                     ENDWITH
                    ENDWITH
                   ENDWITH
                  ENDWITH
                 ENDWITH COMMENTED_BY "Need to re-sort the AlteredList by date in order to have indices consistent with <br>other lists used"
                ENDWITH COMMENTED_BY "Create a temporary altered list for resorting by month"
               ENDWITH COMMENTED_BY "Recalculate the differences between the upper and lower bounds"
              ENDWITH COMMENTED_BY "Create the new upper bound list for the months remaining in WY"
             ENDWITH COMMENTED_BY "Increase the upper bound index by one"
            ENDWITH COMMENTED_BY "Make previous upper bound list the new lower bound list"
           ENDWITH COMMENTED_BY "Not all remaining volume was released; can happen when not enough capacity in remainder of WY"
          ENDIF COMMENTED_BY "If total volume is within tolerance, use the calculated releases"
         ENDWITH COMMENTED_BY "Check to see if there is any remaining unreleased volume<br>MC, 20170608: Not sure if this is really necessary; seems like the check on volume in <br>  GetPowellMonthlyReleases should address the problem?"
        ENDWITH
       ENDWITH COMMENTED_BY "Create list of the form &lcub;Month i, UB(i)-LB(i), LB(i)&rcub;, sorted by UB(i)-LB(i)"
      ENDWITH COMMENTED_BY "Create list of the form: &lcub; &lcub;Remaining month i, UB(i)-LB(i), LB(month i)&rcub;, UB(i)-LB(i) &rcub;<br>The second occurrence of UB(i)-LB(i) is used to sort the first list"
     ENDWITH COMMENTED_BY "Calculate the difference between the UB and LB release for each remaining month"
    ENDWITH COMMENTED_BY "Calculate the remaining annual volume greater than the cumulative lower bound volume"
   ENDWITH COMMENTED_BY "Retrieve the release values for the lower bound column"
  ENDWITH
 ENDWITH COMMENTED_BY "Retrieve the release values for the upper bound column";

    END
    UUID "{3d3f891f-7e83-45ff-97ca-171f2e7e0c3b}";;

    FUNCTION       "CalculatePowellUEBToEqualizePowellMonRel" ( LIST datesToEOWY, NUMERIC UpperColumn, NUMERIC LowerColumn, NUMERIC RemainingAnnualVolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Takes a list of dates that go from the current timestep to the end of the water year. It returns a list of two items each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  If the Equalization outflow has been calculated by Branch 1.3 of the Upper Elevation Balancing Tier, then the outflows from the current date until April 1 have to follow a path of a 9.0 MAF release and then will be either the maximum power plant release (based on an estimation using engineering functions of RW) or the remaining amount of volume to meet the equalization volume determined by previous rules.  The post march releases will be estimated in this function and any carryover volume from not being able to release the water due to power plant capacity will need to be determined. <br><br>RETURNS: List of lists in the form &lcub;date, release, remaining volume over capacity to be released&rcub;<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates to the end of the water year<br>2. NUMERIC UpperColumn - index specifying the upper bound column in the table PowellData.PowellMontlhlyReleaseTable<br>3. NUMERIC LowerColumn - index specifying the lower bound column<br>4. NUMERIC RemainingAnnualVolume - the remaining annual volume to be released; <br><br>CONSTRAINTS: None<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR/DATE: TP, 20171013<br><br>TP, 20180226: startMonth is the month in which to increase releases to try to balance reservoirs. If the month is set to 4, it simulates the April Adjustment that this function is trying to accomplish. Carryover can be created in this scenario. By entering a 3 (March) the simulation is doing a March Adjustment instead, which may be necessary to not violate Power Plant Capacity and not create carryover.  If this operation is ever desired by the Powell Operator, this could be moved to a scalar slot in the model where it can be edited by the operator for a model simulation and not have to come into this function to make that change.<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.<br><br>S.Baker 2018/10/17: Removed hard coded column value and added function NumCol() - 1 <br><br>S.Baker 2018/11/26: It does not seem the function was tested in scenarios when the start date was April through September and there was an April adjustment (1.3 - Upper Elev Bal Tier, B3 branch). The changes to this function are meant to fix issues for start dates in this time frame. <br>- Add Boolean, ?startMonAprToSept?, to check if start month is April through September. In these specific months, the function breaks since part of the function is trying to calculate releases from October through March. The T/F value will be used to bypass calculations that would break the function. <br>- Edit the calculation of ?RelThruMar? to create an empty list if ?startMonAprToSept? is true. If false, the original calculation is performed. <br>- In calculation of ?scalVal?, add IF statement to check if sum(?baselist') is greater than 0 acre-ft (eg. list is not empty). Originally, model failed when ?baselist? was empty because it was trying to divide a number by zero. <br>- In calculation of ?TempList?, there was improper indexing of ?AdjustBaseList? when start date was April through September. An IF statement was added to index differently if ?startMonAprToSept? is true. <br><br>S.Baker, 20200909: Remove reference to Powell.Peak Flow, which caused max iterations to be exceeded at Powelll. The Peak Flow was replaced with the function: GetMaxReleaseGivenInflow(Powell, Powell.Inflow[date], date). Worked with CADSWES to determine this fix.<br><br>S.Baker, 20210216: add function EstimatePowellPEGivenOutflow() to estimate PE.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  WITH NUMERIC ColumnNoFor9MAF = "FindReleaseUpperBoundColumn"( 9000000.00000000 "acre-ft" ) DO
   WITH NUMERIC startMonth = 4.00000000 DO
    WITH BOOLEAN startMonAprToSept = IF ( "GetMonth"( GET @INDEX 0.00000000 FROM datesToEOWY ) >= startMonth AND "GetMonth"( GET @INDEX 0.00000000 FROM datesToEOWY ) <= 9.00000000 )
    THEN
     TRUE
    ELSE
     FALSE
    ENDIF DO
     WITH LIST RelThruMar = IF ( startMonAprToSept )
     THEN
      { 0.00000000 "acre-ft" }
     ELSE
      FOR ( DATETIME date IN datesToEOWY ) WITH LIST resultb = {  } DO
       WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
        IF ( "GetMonth"( date ) < startMonth OR "GetMonth"( date ) > 9.00000000 )
        THEN
         APPEND releaseTable [monthsSinceEOWY + 1.00000000, ColumnNoFor9MAF] ONTO resultb
        ELSE
         resultb
        ENDIF
       ENDWITH
      ENDFOR
     ENDIF COMMENTED_BY "Determine what the Release are necessary for the Oct through March pattern for a 9 MAF <br>release.  <br>" DO
      WITH NUMERIC TobeReleasedThruMar = "Sum"( RelThruMar ) COMMENTED_BY "Sum the October to March Release volume for 9.0 MAF release <br>" DO
       WITH NUMERIC remainingVolumeRelAprThruSep = ( RemainingAnnualVolume - TobeReleasedThruMar ) COMMENTED_BY "Determine the outflow that needs to be released between the Start Month and September to <br>meet the TARV <br>" DO
        WITH NUMERIC lowerColToReleaseRemaining = FOR ( NUMERIC col IN "GetNumbers"( LowerColumn, "NumColumns"( releaseTable ) - 1.00000000, 1.00000000 ) ) WITH NUMERIC newCol = LowerColumn DO
         WITH NUMERIC sumAprToSep = "SumTableColumn"( releaseTable, col, 7.00000000, 12.00000000 ) DO
          IF ( remainingVolumeRelAprThruSep > sumAprToSep )
          THEN
           newCol + 1.00000000
          ELSE
           newCol
          ENDIF
         ENDWITH
        ENDFOR COMMENTED_BY "Determine the column in the LTEMP Powell Release Table that contains the Start month to <br>September volume necessary to mee the TARV  <br>" DO
         WITH LIST LowerBoundListAprThruSep = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
          WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
           IF ( "GetMonth"( date ) < 10.00000000 AND "GetMonth"( date ) > startMonth - 1.00000000 )
           THEN
            APPEND releaseTable [monthsSinceEOWY + 1.00000000, lowerColToReleaseRemaining] ONTO result
           ELSE
            result
           ENDIF
          ENDWITH
         ENDFOR COMMENTED_BY "Determine the releases for the column determined in the previous step <br>" DO
          WITH LIST UpperBoundListAprThruSep = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
           WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
            IF ( "GetMonth"( date ) < 10.00000000 AND "GetMonth"( date ) > startMonth - 1.00000000 )
            THEN
             APPEND releaseTable [monthsSinceEOWY + 1.00000000, lowerColToReleaseRemaining + 1.00000000] ONTO result
            ELSE
             result
            ENDIF
           ENDWITH
          ENDFOR COMMENTED_BY "Determine the releases for the upper column of the determined lower column <br>" DO
           WITH NUMERIC LowersSum = "Sum"( LowerBoundListAprThruSep ) COMMENTED_BY "Sum the volumes for the Upper and lower columns <br>" DO
            WITH NUMERIC UpperSum = "Sum"( UpperBoundListAprThruSep ) DO
             WITH LIST baseList = IF ( remainingVolumeRelAprThruSep > UpperSum )
             THEN
              UpperBoundListAprThruSep
             ELSE
              LowerBoundListAprThruSep
             ENDIF COMMENTED_BY "Determine which pattern to use, lower column pattern or upper column pattern <br>" DO
              WITH NUMERIC scalVal = IF ( "Sum"( baseList ) > 0.00000000 "acre-ft" )
              THEN
               ( remainingVolumeRelAprThruSep / "Sum"( baseList ) )
              ELSE
               1.00000000
              ENDIF COMMENTED_BY "Determine a scale value that will increase or decrease a pattern to meet the remaining TARV <br>Volume <br>" DO
               WITH NUMERIC sumPowerPlantCapAprToSep = FOR ( DATETIME dateb IN datesToEOWY ) STAT_SUM
                IF ( "GetMonth"( dateb ) < startMonth OR "GetMonth"( dateb ) > 9.00000000 )
                THEN
                 0.00000000 "acre-ft"
                ELSE
                 "FlowToVolume"( "GetMaxReleaseGivenInflow"( % "Powell", $ "Powell.Inflow" [dateb], dateb ), dateb )
                ENDIF
               ENDFOR COMMENTED_BY "Determine the volume of Power Plant Capacity between the start month and September <br>" DO
                WITH LIST AdjustedBaseList = FOR ( NUMERIC Rel IN baseList ) WITH LIST result = {  } DO
                 APPEND Rel * scalVal ONTO result
                ENDFOR COMMENTED_BY "Scale the base list to the TARV Volume <br>" DO
                 WITH LIST TempList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST resultb = {  } DO
                  IF ( startMonAprToSept )
                  THEN
                   WITH NUMERIC index = ( LENGTH resultb ) DO
                    APPEND { date , GET @INDEX index FROM AdjustedBaseList } ONTO resultb
                   ENDWITH
                  ELSE
                   WITH NUMERIC index = ( LENGTH resultb ) DO
                    IF ( "GetMonth"( date ) < startMonth OR "GetMonth"( date ) > 9.00000000 )
                    THEN
                     APPEND { date , GET @INDEX index FROM RelThruMar } ONTO resultb
                    ELSE
                     APPEND { date , GET @INDEX index - ( ( LENGTH datesToEOWY ) - ( 10.00000000 - startMonth ) ) FROM AdjustedBaseList } ONTO resultb
                    ENDIF
                   ENDWITH
                  ENDIF
                 ENDFOR COMMENTED_BY "Build a Water Year Release Pattern with 9.0 MAF pattern from Oct to the start month, and the <br>adjusted pattern from the start month to September to meet the TARV.  <br>" DO
                  WITH NUMERIC prevPoolElev = $ "Powell.Pool Elevation" ["OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 Months" )] COMMENTED_BY "Get the Previous Pool Elevation for the following List construction <br>" DO
                   WITH LIST ListWithMaxPowerRel = FOR ( LIST index IN TempList ) WITH LIST result = { { "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 Months" ) , "null" , prevPoolElev , RemainingAnnualVolume } COMMENTED_BY "Build the first list in the list of lists with information that will be used in the first iteration of the list <br>" } DO
                    WITH NUMERIC PreviousResultPE = GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
                     WITH DATETIME PreviousDate = GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
                      WITH DATETIME CurrentDate = "OffsetDate"( PreviousDate, 1.00000000, "1 Months" ) DO
                       WITH NUMERIC CurrentEstRelease = IF ( ( LENGTH result ) == ( LENGTH TempList ) )
                       THEN
                        "Max"( "VolumeToFlow"( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM TempList, CurrentDate ), "VolumeToFlow"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result, CurrentDate ) ) COMMENTED_BY "If in the last month, try to release all remaining volume <br>"
                       ELSE
                        "VolumeToFlow"( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM TempList, CurrentDate )
                       ENDIF DO
                        WITH NUMERIC PowerPlantHeadRow = "Min"( "Floor"( ( PreviousResultPE - $ "Powell.Minimum Power Elevation" [0.00000000, "Min Power Elev"] ), 1.00000000 "ft" ), 212.00000000 "feet" ) DO
                         WITH NUMERIC MaxGeneratorRelease = "GetMaxReleaseGivenInflow"( % "Powell", $ "Powell.Inflow" [CurrentDate], CurrentDate ) DO
                          WITH NUMERIC NextOutflow = IF ( "GetMonth"( CurrentDate ) > 9.00000000 OR "GetMonth"( CurrentDate ) < startMonth OR sumPowerPlantCapAprToSep > remainingVolumeRelAprThruSep )
                          THEN
                           "Min"( CurrentEstRelease, MaxGeneratorRelease )
                          ELSE
                           "Min"( "VolumeToFlow"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result, CurrentDate ) COMMENTED_BY "Remaining Volume<br>", MaxGeneratorRelease )
                          ENDIF DO
                           WITH NUMERIC NewPE = "EstimatePowellPEGivenOutflow"( PreviousResultPE, NextOutflow, CurrentDate ) COMMENTED_BY "Determine the Pool Elevation estimation with Evaporation  <br>" DO
                            WITH NUMERIC newRemVol = ( ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) - "FlowToVolume"( NextOutflow, CurrentDate ) ) COMMENTED_BY "Determine the remaining Volume that was not released from the TARV. At the end of the Water <br>Year, any value calculated here, will be considered Carryover.   <br>" DO
                             APPEND { CurrentDate , NextOutflow , NewPE , newRemVol } ONTO result
                            ENDWITH
                           ENDWITH COMMENTED_BY "Calculate the PE for CurrentDate based on the updated outflow without Evap, for use in the <br>Evap function for Powell <br>"
                          ENDWITH COMMENTED_BY "Calculate the outflow as the minimum of the estimate passed in or the calculated maximum bypass"
                         ENDWITH COMMENTED_BY "Calculate the maximum bypass possible based on the previous result PE value"
                        ENDWITH COMMENTED_BY "Calculate the head value for the current PE <br>"
                       ENDWITH COMMENTED_BY "Retrieve the release passed into the function for the current date"
                      ENDWITH COMMENTED_BY "Set current date"
                     ENDWITH COMMENTED_BY "Retrieve previous result date"
                    ENDWITH COMMENTED_BY "Retrieve previous result PE"
                   ENDFOR COMMENTED_BY "Determine the outflows for the Water Year that meets the 9.0 MAF release pattern from October <br>to the start month, and the remaining releases limited to the release of the TARV or the Power <br>Plant Capacity. The result of the function will be a list of lists with the form &lcub;&lcub;Date, Outflow, Pool <br>Elevation, remaining TARV&rcub;,&lcub;Date, Outflow, Pool Eleavation, remaining TARV&rcub;,...&rcub; <br>" DO
                    WITH NUMERIC carryoverVol = ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH ListWithMaxPowerRel ) - 1.00000000 FROM ListWithMaxPowerRel ) COMMENTED_BY "If there is any carryover volume remaining, this could be due to months in the last months of the <br>Water Year where the TARV pattern in the &quot;Base List&quot; could not be met due to Power Plant <br>Capacity Restrictions. If the early months in the &quot;Base List&quot; after the Start Month, TARV <br>patterned release is not as high as the Power Plant Capacity for that month, the carryover <br>created in the later part of the Water Year, could be released in the earlier part, after the start <br>month.  <br>" DO
                     WITH LIST TryToReleaseAllCarryover = FOR ( LIST DRPEVol IN REMOVE ITEM @INDEX 0.00000000 FROM ListWithMaxPowerRel ) WITH LIST result = { { 1.00000000 , 1.00000000 , 1.00000000 , carryoverVol } } DO
                      WITH NUMERIC maxFlow = "GetMaxReleaseGivenInflow"( % "Powell", $ "Powell.Inflow" [GET @INDEX 0.00000000 FROM DRPEVol], GET @INDEX 0.00000000 FROM DRPEVol ) COMMENTED_BY "Power Plant Capacity <br>" DO
                       WITH NUMERIC DiffCurFlowandMaxFlow = IF ( "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) > 9.00000000 OR "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) < startMonth )
                       THEN
                        0.00000000 "acre-ft/month"
                       ELSE
                        "Max"( maxFlow - GET @INDEX 1.00000000 FROM DRPEVol, 0.00000000 "acre-ft/month" )
                       ENDIF COMMENTED_BY "Determine the amount of possible space available for a given month <br>" DO
                        WITH NUMERIC CarryoverLeftToRelease = ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) COMMENTED_BY "amount of carryover that is needed to be released <br>" DO
                         WITH NUMERIC ChangeInRelease = ( ( GET @INDEX 1.00000000 FROM DRPEVol ) + "Min"( "VolumeToFlow"( CarryoverLeftToRelease, GET @INDEX 0.00000000 FROM DRPEVol ), DiffCurFlowandMaxFlow ) ) COMMENTED_BY "Determine new change in outflow <br>" DO
                          WITH NUMERIC CarryoverLeft = ( CarryoverLeftToRelease - "Min"( CarryoverLeftToRelease, "FlowToVolume"( DiffCurFlowandMaxFlow, GET @INDEX 0.00000000 FROM DRPEVol ) ) ) COMMENTED_BY "Determine if carryover is left to be released in the next months if possible.  <br>" DO
                           APPEND { GET @INDEX 0.00000000 FROM DRPEVol , ChangeInRelease , GET @INDEX 2.00000000 FROM DRPEVol , CarryoverLeft * "DebuggerStop"(  ) } ONTO result
                          ENDWITH
                         ENDWITH
                        ENDWITH
                       ENDWITH
                      ENDWITH
                     ENDFOR COMMENTED_BY "This List tries to insert the Carryover generated from the preivous list, into months where there <br>might be room below the Power Plant Capacity.  This loop could be removed if this operation is <br>not desired and the carryover is better for modeling purposes.  This list generations creates a list <br>of lists in the form &lcub;&lcub;Date, Outflow, Pool Elevation, CarryoverLeft&rcub;,...&rcub; <br>" DO
                      WITH LIST DateFlowVol = FOR ( LIST DFV IN TryToReleaseAllCarryover ) WITH LIST result = {  } DO
                       APPEND { GET @INDEX 0.00000000 FROM DFV , GET @INDEX 1.00000000 FROM DFV , GET @INDEX 3.00000000 FROM DFV } ONTO result
                      ENDFOR COMMENTED_BY "If the previous list is found to be undesirred, then insert &quot; ListWithMaxPowerRel&quot; into where <br>&quot;TryToReleaseAllCarryover&quot; exists.  Then remove the Pool Elevation element from that list. and <br>Return a list of lists in the form &lcub;&lcub;Date, Outflow, Carryover Remaining&rcub;,...&rcub; <br>" DO
                       WITH LIST AdjMonthlyReleases = ( REMOVE ITEM @INDEX 0.00000000 FROM DateFlowVol ) COMMENTED_BY "Remove the first element from the list in the form &lcub;1, 1, 1, Carryover Volume&rcub; <br>" DO
                        AdjMonthlyReleases
                       ENDWITH
                      ENDWITH
                     ENDWITH
                    ENDWITH
                   ENDWITH
                  ENDWITH
                 ENDWITH
                ENDWITH
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "Check start month for function execution to determine calculations based on month <br>"
   ENDWITH COMMENTED_BY "startMonth is the month in which to increase releases to try to balance reservoirs.  <br>"
  ENDWITH
 ENDWITH;

    END
    UUID "{0fa2f445-7915-4ecb-9d11-430351f1ba30}";;

    FUNCTION       "MonthsSinceEOWY" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the number of months since the end of the previous water year<br><br>RETURNS: The number of months since the end of the previous water year<br><br>ARGUMENTS:<br>1. DATETIME date - a date within the run period<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "PowellData.MonthsToFromEOWY" ["GetMonthAsString"( date ), "Since"];

    END
    UUID "{918e4906-0442-4d49-b817-8f6ad6ce60eb}";;

    FUNCTION       "MonthsUntilEOWY" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the number of months until the end of the water year<br><br>RETURNS: The number of months until the end of the water year<br><br>ARGUMENTS:<br>1. DATETIME date - a date within the run period<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "PowellData.MonthsToFromEOWY" ["GetMonthAsString"( date ), "Until"];

    END
    UUID "{3cce8abb-c3ad-4d9d-b7ee-48781cf266db}";;

    FUNCTION       "PowellEvapEstimation" ( DATETIME date, NUMERIC curPE, NUMERIC prevPE )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function follows the method Periodic Net Evaporation (Look up details in RiverWare Help). The function calculates the evaporation that is a function of the reservoir and removes the amount that would have evaporated if the resroivr had not been built. The evaporation is calculated as the Gross Evap from the reservoir less the river, streamside, terrace, and remaining evap that would have occured if the reservoir was not there. TP 2/20/2018<br><br>RETURNS: NUMERIC, Estimate of evaporation volume [L^3]<br><br>ARGUMENTS: <br>1.DATETIME date, The current date of interest<br>2. NUMERIC curPE, The pool elevation estimated without Evaporation for the date<br>3. NUMERIC prevPE, The pool elevation estiatmed in the previous version of the loop that uses this function.<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: TP, 20180220";
    BEGIN

      WITH NUMERIC AvgSurfaceArea = ( ( "ElevationToArea"( % "Powell", prevPE ) + "ElevationToArea"( % "Powell", curPE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average Surface area using an estimated Powell Pool Elevation without <br>Evaporation removed.  <br>" DO
  WITH NUMERIC GrosEvap = ( AvgSurfaceArea * $ "Powell.Gross Evaporation Coefficient" [date, 0.00000000] ) COMMENTED_BY "This is the Gross Evaporation for Powell <br>" DO
   WITH NUMERIC AvgRiverArea = ( ( "TableLookupDefaultTol"( $ "Powell.Elevation River Area", 0.00000000, 1.00000000, prevPE, date, TRUE ) + "TableLookupDefaultTol"( $ "Powell.Elevation River Area", 0.00000000, 1.00000000, curPE, date, TRUE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average River Area  <br>" DO
    WITH NUMERIC RiverEvap = ( AvgRiverArea * $ "Powell.River Evaporation Coefficient" [date, 0.00000000] ) COMMENTED_BY "Determine the amount of Evaporation from the River Area <br>" DO
     WITH NUMERIC AvgStreamsideArea = ( ( "TableLookupDefaultTol"( $ "Powell.Elevation Streamside Area", 0.00000000, 1.00000000, prevPE, date, TRUE ) + "TableLookupDefaultTol"( $ "Powell.Elevation Streamside Area", 0.00000000, 1.00000000, curPE, date, TRUE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average Streamside Area with no Reservor <br>" DO
      WITH NUMERIC StreamsideEvap = ( AvgStreamsideArea * $ "Powell.Streamside Coefficient" [date, 0.00000000] * $ "Powell.Average Air Temperature" [date, 0.00000000] ) COMMENTED_BY "Determine the amount of Evaporation from the Streamside Area, need to use the Average Air <br>Temperature to determine this value. <br>" DO
       WITH NUMERIC AvgTerraceArea = ( ( "TableLookupDefaultTol"( $ "Powell.Elevation Terrace Area", 0.00000000, 1.00000000, prevPE, date, TRUE ) + "TableLookupDefaultTol"( $ "Powell.Elevation Terrace Area", 0.00000000, 1.00000000, curPE, date, TRUE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average Terrace Area of the River with no reservoir <br>" DO
        WITH NUMERIC TerraceEvap = ( AvgTerraceArea * $ "Powell.Terrace Coefficient" [date, 0.00000000] * $ "Powell.Average Air Temperature" [date, 0.00000000] ) COMMENTED_BY "Determine the amount of Evaporation from the Terrace Area, need to use the Average Air <br>Temperature to determine this value. <br>" DO
         WITH NUMERIC RemainingArea = "Max"( AvgSurfaceArea - AvgRiverArea - AvgStreamsideArea - AvgTerraceArea, 0.00000000 "acre" ) COMMENTED_BY "Determine the Remaining area that would simulate the area outside of the river, streamside, or <br>terrace that is covered by the reservoir.  <br>" DO
          WITH NUMERIC RemainingEvap = ( RemainingArea * $ "Powell.Average Precipitation" [date, 0.00000000] ) COMMENTED_BY "Multiply that remaining area by the precipitation rate, it is assumed that any precipitation in the <br>remaining area is evaporated, so it is included in this estimation. See &quot;Periodic Net Evaporation&quot; in <br>section 17.1.18.7 in Objects of the RiverWare Help Documentation.  <br>" DO
           WITH NUMERIC SalvageEvap = ( RiverEvap + StreamsideEvap + TerraceEvap + RemainingEvap ) COMMENTED_BY "Determine the Salvage Evap (The amount of Evap that would occur if the reservoir were not <br>there) <br>" DO
            WITH NUMERIC Evap = "Max"( "FlowToVolume"( GrosEvap - SalvageEvap, date ), 0.00000000 "acre-ft" ) COMMENTED_BY "The Net Evap (Gross - Salvage) is the value that is returned from this function <br>" DO
             Evap
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{040aead3-3666-42f7-a71d-e4a3593dd3e4}";;

    FUNCTION       "PowellReleaseTier" ( NUMERIC Jan1Elev, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a numeric code designating the release tier for Powell based on the provided date and January 1 pool elevation<br><br>RETURNS: Numeric code associated with a release tier<br><br>ARGUMENTS:<br>1. NUMERIC Jan1Elev - pool elevation for January 1<br>2. DATETIME date - date used to specify the water year for calculating the equalization level pool elevation<br><br>CONSTRAINTS: Value is between 0 & 3<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( Jan1Elev >= "EqLevel"( date ) )
 THEN
  0.00000000 COMMENTED_BY "Equalization"
 ELSE
  IF ( Jan1Elev >= $ "PowellData.TierBreaks" ["UpperMid", 0.00000000] )
  THEN
   1.00000000 COMMENTED_BY "Upper Elevation Balancing"
  ELSE
   IF ( Jan1Elev >= $ "PowellData.TierBreaks" ["MidLower", 0.00000000] )
   THEN
    2.00000000 COMMENTED_BY "Mid-Elevation Release"
   ELSE
    3.00000000 COMMENTED_BY "Lower Elevation Balancing"
   ENDIF
  ENDIF
 ENDIF;

    END
    UUID "{fd54c24a-b992-44fc-b0da-597e0adecba3}";;

    FUNCTION       "DebuggerStop" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is a placeholder function that provdes a location for setting a breakpoint in the debugger and allows investigation of LIST of LISTs elements as they are created, instead of after the entire list is created<br><br>RETURNS: Value specified in body of function [NONE]<br><br>ARGUMENTS: NONE<br><br>CONSTRAINTS: NONE";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: Unknown";
    BEGIN

      1.00000000;

    END
    UUID "{d6afcf39-031f-43eb-9e35-d216212b3ad4}";;

    FUNCTION       "TierIs" ( STRING tier, DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns TRUE or FALSE signifying whether or not Powell is operating under the specified release tier in the water year containing the provided date<br><br>RETURNS: Boolean TRUE or FALSE<br><br>ARGUMENTS:<br>1. STRING tier - the name of the tier<br>2. DATETIME date - date used to determine the water year<br>3. BOOLEAN startYear - specifies whether or not the water year is the first water year (TRUE) in the model run or not (FALSE)<br><br>CONSTRAINTS: Returns FALSE if the release tier for the appropriate year is NaN<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( startYear AND date <= @"24:00:00 September 30" )
 THEN
  IF ( NOT IsNaN $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Current Year"] )
  THEN
   $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Current Year"] == $ "PowellData.TierNames" [tier, 0.00000000]
  ELSE
   FALSE
  ENDIF
 ELSE
  IF ( NOT IsNaN $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Next Year"] )
  THEN
   $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Next Year"] == $ "PowellData.TierNames" [tier, 0.00000000]
  ELSE
   FALSE
  ENDIF
 ENDIF;

    END
    UUID "{77f293b3-2180-4235-961e-c3af63b7bf87}";;

    FUNCTION       "UpperElevationBalancingBranchCalculation" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates a code to specify which branch of the Upper Elevation Balancing Tier is used to calculate the release volume<br><br>RETURNS: Value representing the appropriate Upper Elevation Balancing tier branch<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date for which the branch should be calculated<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 20120601<br><br>See the &quot;Interim Guidelines Flow Chart&quot; for reference.  This slot shows the branch within the Upper Elevation Balancing Tier that was taken for each year's calculation of Powell annual release volume.  It can take the following values for the following conditions:<br>1.1 - Upper Elev Bal Tier, B1 branch (8.23 MAF release)<br>1.2 - Upper Elev Bal Tier, B2 branch (release between 7 MAF and 9MAF)<br>1.3 - Upper Elev Bal Tier, B3 branch (Equalization Tier Calc)<br>1.4 - Upper Elev Bal Tier, B4 branch (release between 8.23 MAF and 9MAF)<br>999 - Any other Tier<br><br>MC, 20160908: Changed MeadProjectionDate to be dependent on input parameter eowyDate, instead of on @&quot;t&quot;; added Boolean input parameter 'startYear'  for determining which Mead PE to use; added MeadProjectedElevation variable<br><br>SB, 20180829: Changed how the 'MeadProjectedElevation' in calculated. If the projection date is within the current or previous water year, we need to look at the AugEOYMeadPEProjection value. This function is used in instances where the startYear input could be True/False depending on the controller timestep. The above change will allow the function to know where to look for the PE projection opposed to have it be input.  ";
    BEGIN

      WITH DATETIME MeadProjectionDate = "Dec31ofYear"( eowyDate - 1.00000000 "year" ) DO
  WITH NUMERIC MeadProjectedElevation = "GetProjectedPoolElevation"( "Mead", MeadProjectionDate ) DO
   IF ( $ "Powell.Pool Elevation" [eowyDate] > "EqLevel"( eowyDate ) )
   THEN
    1.30000000
   ELSE
    IF ( MeadProjectedElevation >= 1075.00000000 "ft" )
    THEN
     IF ( $ "Mead.Pool Elevation" [eowyDate] <= 1075.00000000 "ft" AND $ "Powell.Pool Elevation" [eowyDate] > 3575.00000000 "ft" )
     THEN
      1.40000000
     ELSE
      1.10000000
     ENDIF COMMENTED_BY "If Mead's EOWY elevation is less than 1075' and Powell's EOWY elevation is greater than 3575' then release enough to balance <br>the storages up to 9.0 MAF and no less than 8.23 MAF annual release volume (Branch 4).  Otherwise just release 8.23 MAF (Branch 1)"
    ELSE
     IF ( "EnsureReleaseLimits"( "EqualizationRelease"( eowyDate ), $ "PowellData.UpperTierB2MinAnnualRelease" [], $ "PowellData.UpperTierB2MaxAnnualRelease" [] ) > 8230.00000000 "1000 acre-ft" )
     THEN
      1.29000000
     ELSE
      1.27000000
     ENDIF COMMENTED_BY "Branch 2"
    ENDIF
   ENDIF COMMENTED_BY "If greater than the Equalization level, Branch 3"
  ENDWITH COMMENTED_BY "Retrieve the pool elevation for the projection date"
 ENDWITH COMMENTED_BY "Set the date on which to check the Mead pool elevation";

    END
    UUID "{a607f2d8-571a-4b39-a35f-a5c868426df7}";;

    FUNCTION       "UpperElevationBalancingBranchCalculation_old" ( DATETIME eowyDate, BOOLEAN startYear )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates a code to specify which branch of the Upper Elevation Balancing Tier is used to calculate the release volume<br><br>RETURNS: Value representing the appropriate Upper Elevation Balancing tier branch<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date for which the branch should be calculated<br>2. BOOLEAN startYear - specifies whether the water year in question is the first water year (TRUE) or an out year (FALSE)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 20120601<br><br>See the &quot;Interim Guidelines Flow Chart&quot; for reference.  This slot shows the branch within the Upper Elevation Balancing Tier that was taken for each year's calculation of Powell annual release volume.  It can take the following values for the following conditions:<br>1.1 - Upper Elev Bal Tier, B1 branch (8.23 MAF release)<br>1.2 - Upper Elev Bal Tier, B2 branch (release between 7 MAF and 9MAF)<br>1.3 - Upper Elev Bal Tier, B3 branch (Equalization Tier Calc)<br>1.4 - Upper Elev Bal Tier, B4 branch (release between 8.23 MAF and 9MAF)<br>999 - Any other Tier<br><br>MC, 20160908: Changed MeadProjectionDate to be dependent on input parameter eowyDate, instead of on @&quot;t&quot;; added Boolean input parameter 'startYear'  for determining which Mead PE to use; added MeadProjectedElevation variable";
    BEGIN

      WITH DATETIME MeadProjectionDate = "Dec31ofYear"( eowyDate - 1.00000000 "year" ) DO
  WITH NUMERIC MeadProjectedElevation = IF ( startYear )
  THEN
   $ "PowellToMeadData.AugEOYMeadPEProjection" [MeadProjectionDate]
  ELSE
   $ "Mead.Pool Elevation" [MeadProjectionDate]
  ENDIF DO
   IF ( $ "Powell.Pool Elevation" [eowyDate] > "EqLevel"( eowyDate ) )
   THEN
    1.30000000
   ELSE
    IF ( MeadProjectedElevation >= 1075.00000000 "ft" )
    THEN
     IF ( $ "Mead.Pool Elevation" [eowyDate] <= 1075.00000000 "ft" AND $ "Powell.Pool Elevation" [eowyDate] > 3575.00000000 "ft" )
     THEN
      1.40000000
     ELSE
      1.10000000
     ENDIF COMMENTED_BY "If Mead's EOWY elevation is less than 1075' and Powell's EOWY elevation is greater than 3575' then release enough to balance <br>the storages up to 9.0 MAF and no less than 8.23 MAF annual release volume (Branch 4).  Otherwise just release 8.23 MAF (Branch 1)"
    ELSE
     IF ( "EnsureReleaseLimits"( "EqualizationRelease"( eowyDate ), $ "PowellData.UpperTierB2MinAnnualRelease" [], $ "PowellData.UpperTierB2MaxAnnualRelease" [] ) > 8230.00000000 "1000 acre-ft" )
     THEN
      1.29000000
     ELSE
      1.27000000
     ENDIF COMMENTED_BY "Branch 2"
    ENDIF
   ENDIF COMMENTED_BY "If greater than the Equalization level, Branch 3"
  ENDWITH COMMENTED_BY "Retrieve the pool elevation for the projection date"
 ENDWITH COMMENTED_BY "Set the date on which to check the Mead pool elevation";

    END
    UUID "{c895b415-eb94-40c0-9c8e-5f7e9eca8557}";;

    FUNCTION       "VolumeDeviationFromEOWYTarget" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the volume deviation of the end-of-water-year storage at Powell and Mead from their appropriate target levels according to the Equalization Tier logic.  The condition that is operative for setting the annual volume in a given year is stored in the PowellData.ControllingEqualizationCondition slot.  See the slot for further description of what the values actually mean.  This deviation volume is then added to the annual release volume to more precisely hit the end of water year (EOWY) target. Carryover created in the current and previous water year is accounted for each time a reservoir storage is used.<br><br>RETURNS: Difference between Powell storage volume and the desired end of water year storage volume [L^3]<br><br>ARGUMENTS:<br>1. DATETIME EOWYDate - end of water year date used to specify the appropriate water year<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 2018/10/17: This function calculates a VolumeDeviation in the rule ?Refine Equalization Release Volume?.  This function needs to account for carryover volume that is created for the current year; without accounting for carryover, MTOM continuously increase the TARV and eventually aborts. Added two 'WITH' statements to use for current and previous year's carryover volume.<br>";
    BEGIN

      WITH NUMERIC carryoverCurrentWY = $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "OffsetDate"( EOWYDate, 12.00000000, "1 months" ) )] DO
  WITH NUMERIC carryoverPreviousWY = $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] DO
   IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.10000000 )
   THEN
    $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) ) - carryoverCurrentWY
   ELSE
    IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.20000000 OR NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.30000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWYDate )] ) == 1.27000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWYDate )] ) == 1.29000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWYDate )] ) == 1.40000000 )
    THEN
     ( ( $ "Powell.Storage" [EOWYDate] - carryoverCurrentWY - carryoverPreviousWY ) - ( $ "Mead.Storage" [EOWYDate] + carryoverCurrentWY + carryoverPreviousWY ) ) / 2.00000000
    ELSE
     IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.40000000 )
     THEN
      "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - ( $ "Mead.Storage" [EOWYDate] + carryoverCurrentWY + carryoverPreviousWY )
     ELSE
      IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.50000000 )
      THEN
       $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ) - carryoverCurrentWY - carryoverPreviousWY
      ELSE
       0.00000000 "acre-ft"
      ENDIF COMMENTED_BY "Fourth possible condition is that Powell elevation needs to be at 20ft below the equalization level by the end-of-water-year"
     ENDIF COMMENTED_BY "Third possible condition is that Mead needs to be at elevation 1105 ft by the end-of-water-year"
    ENDIF COMMENTED_BY "Second possible condition is that the end-of-water-year storages need to be equal between Powell and Mead."
   ENDIF
  ENDWITH
 ENDWITH COMMENTED_BY "First condition is that Powell needs to be to its equalization level by end-of-water-year";

    END
    UUID "{4f23703c-2252-4729-b6be-28b01dfc099e}";;

    FUNCTION       "WaterYearDatesByGroup" ( NUMERIC inputGroupNumber )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a list of the dates in the same WY group (all dates in a water year have the same group number) &quot;inputGroupNumber&quot;. Note that for the initial water year, only the remaining months in the water year (beginning with that of the Start Timestep) are included in the output.<br><br>RETURNS: List of dates remaining in the water year specified by the input argument<br><br>ARGUMENTS:<br>1. NUMERIC inputGroupNumber - numeric value specifying the water year for which the dates are desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST prelimList = FOR ( DATETIME date IN @"Start Timestep + 1" TO @"Finish Timestep" ) WITH LIST result = { { @"Start Timestep" , 1.00000000 } } DO
  WITH NUMERIC groupNumber = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
   IF ( "GetMonthAsString"( date ) == "October" )
   THEN
    APPEND { date , groupNumber + 1.00000000 } ONTO result
   ELSE
    APPEND { date , groupNumber } ONTO result
   ENDIF
  ENDWITH
 ENDFOR DO
  IF ( ( inputGroupNumber == 7.00000000 AND @"Start Timestep" == @"October 31" ) COMMENTED_BY "If the start month is October then there is no third water year in the run window.  Thus we need this function to be <br>non-empty and return a date that will definitely be outside of the run window. - sc 11/03/11" )
  THEN
   { @"24:00:00 December 31, 1900" }
  ELSE
   FOR ( LIST dateGroupNumber IN prelimList ) WITH LIST result = {  } DO
    IF ( ( GET @INDEX 1.00000000 FROM dateGroupNumber ) == inputGroupNumber )
    THEN
     APPEND GET @INDEX 0.00000000 FROM dateGroupNumber ONTO result
    ELSE
     result
    ENDIF
   ENDFOR COMMENTED_BY "Loop through prelimList and keep the &lcub;Date, Group Number&rcub; pairs for which Group Number matches inputGroupNumber"
  ENDIF
 ENDWITH COMMENTED_BY "prelimList contains all dates within the model run period and their associated water year numbers";

    END
    UUID "{f08863a4-fa24-4d07-9cc7-fe9637030bef}";;

    FUNCTION       "GetPowellMonthlyReleases_pre20171024" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume calculates each month's release.  If the set of dates passed to the function is the first water year in the run (i.e., begins with the run's start timestep), then, if necessary, this function will make an adjustment to the calculated releases to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List with members of the form &lcub;date, release&rcub; where date is a member of the list of dates passed to the function<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates within the model run period<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 20110325<br><br>MC, 20160907: In calculation of AdjustedMonthlyReleases, moved subRelList<1> (and multiplied by 1 &quot;month&quot;) into call to VolumeToFlow to get desired volume; previous version was not giving correct desired volume (at least in some cases when UserInput_MinimumAnnualRelease sets the TARV) due to conversion associated with monthly flow and time scale (i.e., RW was making an unwanted conversion based on the number of days in a month); Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1><br>MC, 20170501: Renamed variables for better understanding";
    BEGIN

      WITH NUMERIC AnnualVolume = "CurrentAnnualVolume"( GET @INDEX 0.00000000 FROM datesToEOWY ) DO
  WITH BOOLEAN EqualizationbyAprAdjust = IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] ) == 1.30000000 )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF DO
   WITH NUMERIC VolumeReleasedPreRun = IF ( "GetMonthAsString"( GET @INDEX 0.00000000 FROM datesToEOWY ) == "October" )
   THEN
    0.00000000 "acre-feet"
   ELSE
    "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), @"Start Timestep - 1" ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] )
   ENDIF DO
    WITH NUMERIC RemainingWYReleaseVolume = AnnualVolume - VolumeReleasedPreRun DO
     WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( AnnualVolume ) DO
      WITH NUMERIC LowerColumnBound = "FindReleaseLowerBoundColumn"( AnnualVolume, UpperColumnBound ) DO
       WITH LIST RemainingMonthlyReleases = IF ( EqualizationbyAprAdjust )
       THEN
        "CalculatePowellUEBToEqualizePowellMonRel"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYReleaseVolume )
       ELSE
        "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYReleaseVolume )
       ENDIF DO
        IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
        THEN
         WITH NUMERIC MonthlyReleaseSum = FOR ( LIST monthlyReleaseVol IN RemainingMonthlyReleases ) STAT_SUM
          "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
         ENDFOR DO
          WITH NUMERIC Tolerance = 5.00000000 "acre-feet" DO
           WITH NUMERIC VolumeDifference = RemainingWYReleaseVolume - MonthlyReleaseSum DO
            IF ( "Abs"( VolumeDifference ) < Tolerance )
            THEN
             RemainingMonthlyReleases
            ELSE
             WITH NUMERIC MonthlyVolumeAdjustment = VolumeDifference / LENGTH RemainingMonthlyReleases DO
              WITH LIST AdjustedMonthlyReleases = FOR ( LIST subRelList IN RemainingMonthlyReleases ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
               WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - MonthlyVolumeAdjustment DO
                 ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( MonthlyVolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
                ENDWITH
               ENDWITH
              ENDFOR DO
               REMOVE ITEM @INDEX 0.00000000 FROM AdjustedMonthlyReleases
              ENDWITH
             ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170607: Why not adjust porportionately to monthly releases?<br>"
            ENDIF
           ENDWITH
          ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
         ENDWITH COMMENTED_BY "Calculate total remaining releases from RemainingMonthlyReleases"
        ELSE
         RemainingMonthlyReleases
        ENDIF
       ENDWITH COMMENTED_BY "Calculate list of the form &lcub;Month, Adjusted monthly release rate, Remaining volume above lower bound column&rcub;"
      ENDWITH COMMENTED_BY "Detemine index of first column in monthly release table with total annual volume <= annualVolume<br>(Same as UpperColumnBound if annualVolume is equal to a column total)"
     ENDWITH COMMENTED_BY "Calculate index of first column in monthly release table with total annual volume >= annualVolume"
    ENDWITH
   ENDWITH COMMENTED_BY "Determine volume released prior to model run start"
  ENDWITH
 ENDWITH COMMENTED_BY "Retrieve TargetAnnualReleaseVolume for water year containing datesToEOWY<0>";

    END
    UUID "{bab7bcd2-87ea-481f-b79a-33793faaf46a}";;

    FUNCTION       "GetPowellMonthlyReleases_v2" ( LIST datesToEOWY, NUMERIC TargetAnnualReleaseVolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume calculates each month's release.  If the set of dates passed to the function is the first water year in the run (i.e., begins with the run's start timestep), then, if necessary, this function will make an adjustment to the calculated releases to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List with members of the form &lcub;date, release&rcub; where date is a member of the list of dates passed to the function<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates within the model run period<br>2. NUMERIC TotalVolumeToRelease - the total volume of water to be released during a water year<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 20110325<br><br>MC, 20160728: This version of the function takes a second argument, TotalVolumeToRelease, instead of using an annual volume calculated by the user-defined function CurrentAnnualVolume; it was originally created for use in handling carryover years";
    BEGIN

      WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( TargetAnnualReleaseVolume ) DO
  WITH NUMERIC LowerColumnBound = "FindReleaseLowerBoundColumn"( TargetAnnualReleaseVolume, UpperColumnBound ) DO
   WITH NUMERIC VolumeReleasedPreRun = IF ( "GetMonthAsString"( ( GET @INDEX 0.00000000 FROM datesToEOWY ) ) == "October" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, 1.00000000, "-1 months" ) )
   ENDIF DO
    WITH NUMERIC CarryoverReleasedPreRun = "Min"( VolumeReleasedPreRun, $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] ) DO
     WITH NUMERIC TARVReleasedPreRun = VolumeReleasedPreRun - CarryoverReleasedPreRun DO
      WITH NUMERIC TARVRemaining = TargetAnnualReleaseVolume - TARVReleasedPreRun DO
       WITH LIST RemainingMonthlyReleases = "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, TARVRemaining ) DO
        IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
        THEN
         WITH NUMERIC SumRemainingReleases = FOR ( LIST monthlyReleaseVol IN RemainingMonthlyReleases ) STAT_SUM
          "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
         ENDFOR DO
          WITH NUMERIC VolumeDifference = TARVRemaining - SumRemainingReleases DO
           WITH NUMERIC Tolerance = 5.00000000 "acre-feet" DO
            IF ( "Abs"( VolumeDifference ) < Tolerance )
            THEN
             RemainingMonthlyReleases
            ELSE
             WITH NUMERIC MonthlyVolumeAdjustment = VolumeDifference / LENGTH RemainingMonthlyReleases DO
              WITH LIST AdjustedMonthlyReleases = FOR ( LIST subRelList IN RemainingMonthlyReleases ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
               WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - MonthlyVolumeAdjustment DO
                 ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( MonthlyVolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
                ENDWITH
               ENDWITH
              ENDFOR DO
               REMOVE ITEM @INDEX 0.00000000 FROM AdjustedMonthlyReleases
              ENDWITH
             ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170607: Why not distribute the difference proportionately to releases?"
            ENDIF
           ENDWITH
          ENDWITH
         ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
        ELSE
         RemainingMonthlyReleases
        ENDIF
       ENDWITH COMMENTED_BY "Calculate list of the form &lcub;Month, Monthly release rate, Remaining volume above lower bound column&rcub;"
      ENDWITH COMMENTED_BY "Calculate annual volume that remains to be released"
     ENDWITH COMMENTED_BY "Calculate annual volume previously released "
    ENDWITH COMMENTED_BY "Calculate carryover volume previously released"
   ENDWITH COMMENTED_BY "Calculate total volume previously released"
  ENDWITH
 ENDWITH COMMENTED_BY "Find upper and lower bound columns for annual release";

    END
    UUID "{e216fafe-b67f-4ec5-800a-43bc820a374f}";;

    FUNCTION       "GetPowellMonthlyReleases" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume calculates each month's release.  If the set of dates passed to the function is the first water year in the run (i.e., begins with the run's start timestep), then, if necessary, this function will make an adjustment to the calculated releases to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List with members of the form &lcub;date, release, remaining volume&rcub; where date is a member of the list of dates passed to the function<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates within the model run period<br>2. NUMERIC TotalVolumeToRelease - the total volume of water to be released during a water year<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 20110325<br><br>MC, 20160728: This version of the function takes a second argument, TotalVolumeToRelease, instead of using an annual volume calculated by the user-defined function CurrentAnnualVolume; it was originally created for use in handling carryover years<br><br>MC, 20171024: Tried to combine all functions that develop release schedules into a single one here. Old version renamed GetPowellMonthlyReleases_pre20171024; this version finds bounding release schedule columns based on remaining volume, which Paul D. previously indicated should be okay<br><br>S.Baker, 2018/10/17: <br>(1) 'AnnualCarryoverVolume' - Function needs to know the carryover volume no matter the equalization tier. <br>(2) 'RemainingMonthlyReleases' - The ?CalculatePowellUEBToEqualizePowellMonRel? function uses ?Powell.Peak Flow? which isn?t solved for until Powell has successfully dispatched. Therefore, the statement setting the ?RemainingMonthlyRelease? checks to see of Powell.Outflow is NaN. This normally occurs when the TARV is initially set to 8.23 MAF. Once Powell resets the TARV, the function will re-execute and will enter the function ?CalculatePowellUEBToEqualizePowellMonRel? if Powell is equalizing with an April adjustment. <br>(3) IF statement for ?RemainingMonthlyReleases? - A new conditions was added to ensure the model didn?t enter this part of the function unless it was not an April Adjustment. Originally, the model would solve for carryover, but would spread the carryover out by spilling water out of Powell in this part of the function. <br><br>S.Baker, 2018/11/26: subracted VolumeReleasedPreRun from TARV in the calculation of RemaininWYRelease.";
    BEGIN

      WITH DATETIME WaterYear = "Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) ) DO
  WITH BOOLEAN EqualizationbyAprAdjust = IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" [WaterYear] ) == 1.30000000 )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF DO
   WITH NUMERIC VolumeReleasedPreRun = IF ( "GetMonthAsString"( ( GET @INDEX 0.00000000 FROM datesToEOWY ) ) == "October" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, 1.00000000, "-1 months" ) )
   ENDIF DO
    WITH NUMERIC TargetAnnualVolume = $ "PowellData.TargetAnnualReleaseVolume" [WaterYear] DO
     WITH NUMERIC AnnualCarryoverVolume = NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [WaterYear] ) DO
      WITH LIST TARVVolReleases = WITH NUMERIC RemainingWYRelease = IF ( VolumeReleasedPreRun >= AnnualCarryoverVolume )
      THEN
       TargetAnnualVolume + AnnualCarryoverVolume - VolumeReleasedPreRun
      ELSE
       TargetAnnualVolume - VolumeReleasedPreRun
      ENDIF COMMENTED_BY "If carryover still needs to be released, use TARV. Carryover will <br>be added in the CalculateCarryoverReleases function.  <br>" DO
       WITH NUMERIC UpperColumnBound = "FindRemainingReleaseUpperBoundColumn"( RemainingWYRelease, datesToEOWY ) COMMENTED_BY "If the dates end with a water year end, use remaining release to determine column bound<br>If run ends in Dec, using remaining release function leads to all annual volume being released in <br>Oct, Nov, Dec  <br>" DO
        WITH NUMERIC LowerColumnBound = "FindRemainingReleaseLowerBoundColumn"( RemainingWYRelease, datesToEOWY, UpperColumnBound ) DO
         WITH LIST RemainingMonthlyReleases = IF ( EqualizationbyAprAdjust AND NOT IsNaN $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM datesToEOWY] )
         THEN
          "CalculatePowellUEBToEqualizePowellMonRel"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYRelease )
         ELSE
          "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYRelease )
         ENDIF COMMENTED_BY "List of lists of form: &lcub;Date, Release, Remaining Volume&rcub; <br>" DO
          IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" AND NOT EqualizationbyAprAdjust )
          THEN
           WITH NUMERIC SumRemainingReleases = FOR ( LIST monthlyReleaseVol IN RemainingMonthlyReleases ) STAT_SUM
            "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
           ENDFOR DO
            WITH NUMERIC VolumeDifference = RemainingWYRelease - SumRemainingReleases DO
             WITH NUMERIC Tolerance = 5.00000000 "acre-feet" DO
              IF ( "Abs"( VolumeDifference ) < Tolerance )
              THEN
               RemainingMonthlyReleases
              ELSE
               WITH NUMERIC MonthlyVolumeAdjustment = VolumeDifference / LENGTH RemainingMonthlyReleases DO
                WITH LIST AdjustedMonthlyReleases = FOR ( LIST subRelList IN RemainingMonthlyReleases ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
                 WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                  WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - MonthlyVolumeAdjustment DO
                   ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( MonthlyVolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
                  ENDWITH
                 ENDWITH
                ENDFOR DO
                 REMOVE ITEM @INDEX 0.00000000 FROM AdjustedMonthlyReleases
                ENDWITH
               ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170607: Why not distribute the difference proportionately to releases?"
              ENDIF
             ENDWITH
            ENDWITH
           ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
          ELSE
           RemainingMonthlyReleases
          ENDIF
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH DO
       IF ( ( VolumeReleasedPreRun >= AnnualCarryoverVolume ) OR IF ( IsNaN $ "PowellData.ReleaseVolumeSetFlag" [WaterYear] )
       THEN
        ( LENGTH datesToEOWY ) < 11.00000000 AND IsNaN $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM datesToEOWY]
       ELSE
        ( $ "PowellData.ReleaseVolumeSetFlag" [WaterYear] == 0.00000000 )
       ENDIF COMMENTED_BY "Carryover will not be added until annual release volume is finalized <br>" )
       THEN
        TARVVolReleases COMMENTED_BY "Schedule remaining volume normally <br>"
       ELSE
        "CalculateCarryoverReleases"( datesToEOWY, AnnualCarryoverVolume, TARVVolReleases ) COMMENTED_BY "Add the Carryover that was created in the previous year to the schedule that is passed into the <br>function, &quot;TARVVolReleases&quot; <br>"
       ENDIF
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{54e8e1fd-8449-40e7-8454-d97f29e0be3b}";;

    FUNCTION       "CalculateCarryoverReleases" ( LIST datesToEOWY, NUMERIC InitialCarryoverVolume, LIST TARVVolReleases )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the maximum powerplant capacity release for the case when there is remaining carryover volume between Powell and Mead from one water year to the next. It assumes the monthly releases for the remainder of the year based on the annual release volume have already been calculated<br><br>RETURNS: List of the form &lcub;Date, Release, Carryover Remaining&rcub;. The third (CarryoverRemaining) element in the list are needed internally by the function to track which water is being released through the loop.<br><br>ARGUMENTS: <br>1. LIST datesToEOWY, a list of the months remaining in the current water year<br>2. NUMERIC InitialCarryoverVolume, the carryover volume remaining that was not released prior to the start date of the current model run<br>3. LIST TARVVolReleases, a list of outflows that should sum to the current setting of the TARV.  <br><br>CONSTRAINTS:<br><br> <br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20160711<br>MC, 20160711: The GetMaxReleaseGivenInflow predefined function for future months is dependent on the operating head from pool elevation, which will not be strictly accurate because each month's value is calculated from the previously set typical outflow<br>MC, 20170503: Rewrote function using initial element of list, which allowed condensing code by removing separate sections for first element of list and subsequent elements<br>TP, 2017 11/16/2017: The function needs to know the current setting of the TARV in order to release on top of what needs to be released for the WY.  The function now estimates an upated Pool Elevation and Power Plant Capacity within the function.<br>S.Baker, 20200909: Remove reference to Powell.Peak Flow, which caused max iterations to be exceeded at Powelll. The Peak Flow was replaced with the function: GetMaxReleaseGivenInflow(Powell, Powell.Inflow[date], date). Worked with CADSWES to determine this fix.<br>S.Baker, 20210216: add function EstimatePowellPEGivenOutflow() to estimate PE.";
    BEGIN

      WITH DATETIME InitialDate = "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 months" ) DO
  WITH LIST sortedTARVRel = "Sort"( TARVVolReleases ) DO
   WITH NUMERIC TargetAnnualReleaseVolume = $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] DO
    WITH LIST ListWithInit = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = { { InitialDate , "null" , InitialCarryoverVolume , $ "Powell.Pool Elevation" ["OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 Months" )] } } COMMENTED_BY "Build the beginning structure of the list that contains the month prior to when the releases will be <br>start, in an out year, this date will be September of the previous Water Year. Then a &quot;null&quot; value <br>where the outflow that will be calculated will be entered in subsequent sub lists, the initial <br>carryover volume that is to be released (ideally, this will be reduced throughout the construction <br>of the loop), and the initial pool elevation that will help simulate Powell.  <br>" DO
     WITH NUMERIC index = ( FIND date WITHIN datesToEOWY ) + 1.00000000 DO
      WITH NUMERIC TARVOut = ( GET @INDEX 1.00000000 FROM GET @INDEX index - 1.00000000 FROM sortedTARVRel ) COMMENTED_BY "Get the current release, for the current iteration <br>" DO
       WITH NUMERIC PreviousCarryoverRemaining = ( GET @INDEX 2.00000000 FROM GET @INDEX index - 1.00000000 FROM result ) COMMENTED_BY "Get the current carryover volume that still needs to be released <br>" DO
        WITH NUMERIC PreviousResultPE = ( GET @INDEX 3.00000000 FROM GET @INDEX index - 1.00000000 FROM result ) COMMENTED_BY "Get the Previous Pool Elevation, as the loop grows, the simulated Pool Elevation from the <br>previous iteration will be used here. <br>" DO
         WITH NUMERIC Qmax = "GetMaxReleaseGivenInflow"( % "Powell", $ "Powell.Inflow" [date], date ) COMMENTED_BY "Calculates Peak Flow instead of using the slot, which caused the model to abort.  <br>" DO
          WITH NUMERIC Release = "Min"( Qmax, "VolumeToFlow"( PreviousCarryoverRemaining, date ) + TARVOut ) COMMENTED_BY "Determine the new release for the month <br>" DO
           WITH NUMERIC CarryoverRemaining = IF ( ( LENGTH result ) == LENGTH TARVVolReleases )
           THEN
            "Max"( PreviousCarryoverRemaining - "FlowToVolume"( Release - TARVOut, date ), 0.00000000 "acre-ft" ) + GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH TARVVolReleases ) - 1.00000000 FROM TARVVolReleases
           ELSE
            "Max"( PreviousCarryoverRemaining - "FlowToVolume"( Release - TARVOut, date ), 0.00000000 "acre-ft" )
           ENDIF DO
            WITH NUMERIC NewPE = "EstimatePowellPEGivenOutflow"( PreviousResultPE, Release, date ) COMMENTED_BY "Determine the new Pool Elevation with the estimated Powell Evaporation <br>" DO
             APPEND { date , Release , CarryoverRemaining , NewPE * "DebuggerStop"(  ) } ONTO result
            ENDWITH COMMENTED_BY "Estimate the new Pool Eleavtion without Evaporation, which is necessary to determine the <br>Evaporation estimate in the next function.  <br>"
           ENDWITH COMMENTED_BY "Determine if Carryover was all released or if some is still needed to be released <br>"
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Get the current index in the list that is being created <br>"
    ENDFOR DO
     WITH NUMERIC carryoverVol = ( GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH ListWithInit ) - 1.00000000 FROM ListWithInit ) DO
      WITH LIST getAllCarryoverOut = FOR ( LIST DRPEVol IN REMOVE ITEM @INDEX 0.00000000 FROM ListWithInit ) WITH LIST result = { { 1.00000000 , 1.00000000 , 1.00000000 , carryoverVol } } DO
       WITH NUMERIC maxFlow = "GetMaxReleaseGivenInflow"( % "Powell", $ "Powell.Inflow" [GET @INDEX 0.00000000 FROM DRPEVol], GET @INDEX 0.00000000 FROM DRPEVol ) DO
        WITH NUMERIC DiffCurFlowandMaxFlow = IF ( "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) > 9.00000000 OR "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) < 4.00000000 )
        THEN
         0.00000000 "acre-ft/month"
        ELSE
         "Max"( maxFlow - GET @INDEX 1.00000000 FROM DRPEVol, 0.00000000 "acre-ft/month" )
        ENDIF DO
         WITH NUMERIC CarryoverLeftToRelease = ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) DO
          WITH NUMERIC ChangeInRelease = ( GET @INDEX 1.00000000 FROM DRPEVol ) + "Min"( "VolumeToFlow"( CarryoverLeftToRelease, GET @INDEX 0.00000000 FROM DRPEVol ), DiffCurFlowandMaxFlow ) DO
           WITH NUMERIC CarryoverLeft = CarryoverLeftToRelease - "Min"( CarryoverLeftToRelease, "FlowToVolume"( DiffCurFlowandMaxFlow, GET @INDEX 0.00000000 FROM DRPEVol ) ) DO
            APPEND { GET @INDEX 0.00000000 FROM DRPEVol , ChangeInRelease , GET @INDEX 3.00000000 FROM DRPEVol , CarryoverLeft * "DebuggerStop"(  ) } ONTO result
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDFOR DO
       WITH LIST DateFlowVol = FOR ( LIST DFV IN getAllCarryoverOut ) WITH LIST result = {  } DO
        APPEND { GET @INDEX 0.00000000 FROM DFV , GET @INDEX 1.00000000 FROM DFV , GET @INDEX 3.00000000 FROM DFV } ONTO result
       ENDFOR DO
        ( REMOVE ITEM @INDEX 0.00000000 FROM DateFlowVol )
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Remove unneeded first element in list of lists"
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{021913fb-8e2b-46de-84a7-6bda7b717ac0}";;

    FUNCTION       "EqualizationReleaseWithCarryover" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: Created this function to account for the effects of carryover volume in the equalization calculation, which are not needed in the original EqualizationRelease function. If there is carryover volume for the water year, in order to calculate the correct annual volume to release, the calculation needs to 'virtually' move the carryover water from Powell to Mead<br><br>RETURNS: Powell release volume<br><br>ARGUMENTS:<br>1. DATETIME EOWYdate - the end of water year date used to specify the water year of interest<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20160801<br>";
    BEGIN

      ( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( $ "Powell.Storage" [EOWYDate] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["OffsetDate"( "Dec31ofYear"( EOWYDate ), 12.00000000, "1 months" )] ) - ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["OffsetDate"( "Dec31ofYear"( EOWYDate ), 12.00000000, "1 months" )] ) ) ) / ( 2.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) ) COMMENTED_BY "Add half of the storage difference that would be present if the carryover volume had been moved from Powell to Mead to the annual release volume";

    END
    UUID "{22d86c2e-089c-4dcd-9a1b-63f26ec5440b}";;

    FUNCTION       "GetWaterYearNumber" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the water year number (relative water year within the model run) of the water year containing the argument &quot;date&quot;<br><br>RETURNS: Numeric index of the water year<br><br>ARGUMENTS<br>1. DATETIME date<br><br>CONSTRAINTS:<br><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170209";
    BEGIN

      "GetYear"( date ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 AND "GetMonth"( date ) <= 9.00000000 )
 THEN
  0.00000000
 ELSE
  IF ( "GetMonth"( @"Start Timestep" ) <= 9.00000000 AND "GetMonth"( date ) > 9.00000000 )
  THEN
   2.00000000
  ELSE
   1.00000000
  ENDIF COMMENTED_BY "Start<Oct & date>=Oct, add 2"
 ENDIF COMMENTED_BY "If Start>= Oct & date<Oct, then difference in water years is the same as between <br>calendar years";

    END
    UUID "{1c0a64f4-b119-4610-bdae-8e581aa2cbc7}";;

    FUNCTION       "FindRemainingReleaseUpperBoundColumn" ( NUMERIC RemainingRelease, LIST datesToEOWY )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the column index for the column in PowellData.PowellMonthlyReleaseTable with the smallest capacity for the remainder of the water year that is greater than the remaining required water year release (Least Upper Bound).<br><br>RETURNS: Numeric index for column [No units]<br><br>ARGUMENTS: <br>1. NUMERIC RemainingRelease - volume of water remaining to be released in the water year of interest<br>2. LIST datesToEOWY - list of dates remaining in the water year of interest<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 20170627 (previously developed for Sarah Baker's research model)<br><br>MC, 20180116: Added second condition to IF statement regarding last element in datesToEOWY being equal to September. In the January run, the Finish Timestep is Dec resulting in the final outyear selecting a Powell release schedule that allowed the total annual volume to be released during Oct-Dec. Adding the condition allows that case to select the release schedule based on the annual volume, which results in an appropriate release schedule for Oct-Dec<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  IF ( ( LENGTH datesToEOWY ) < 3.00000000 OR "GetMonth"( GET @INDEX ( LENGTH datesToEOWY ) - 1.00000000 FROM datesToEOWY ) != 9.00000000 )
  THEN
   WHILE ( RemainingRelease - releaseTable ["AnnualTotal", result] > 0.01000000 "1000 acre-ft" ) WITH NUMERIC result = 0.00000000 DO
    result + 1.00000000
   ENDWHILE
  ELSE
   WHILE ( RemainingRelease - FOR ( DATETIME date IN ( GET @INDEX 0.00000000 FROM datesToEOWY ) TO GET @INDEX ( LENGTH datesToEOWY ) - 1.00000000 FROM datesToEOWY ) STAT_SUM
    releaseTable ["GetMonthAsString"( date ), result]
   ENDFOR > 1.00000000 "acre-feet" AND result < "NumColumns"( releaseTable ) ) WITH NUMERIC result = 1.00000000 DO
    result + 1.00000000
   ENDWHILE
  ENDIF
 ENDWITH COMMENTED_BY "If difference between remaining volume and remaining UB capacity > 1 acre-foot, increment UB column index";

    END
    UUID "{5ef9441d-d0a5-42f4-bedc-5fea0ffef920}";;

    FUNCTION       "FindRemainingReleaseLowerBoundColumn" ( NUMERIC RemainingRelease, LIST datesToEOWY, NUMERIC upperbound )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the column index for the column in PowellData.PowellMonthlyReleaseTable with the greatest capacity for the remainder of the water year that is less than the remaining required water year release (Greatest Lower Bound).<br><br>RETURNS: Numeric index for column [No units]<br><br>ARGUMENTS: <br>1. NUMERIC RemainingRelease - volume of water remaining to be released in the water year of interest<br>2. LIST datesToEOWY - list of dates remaining in the water year of interest<br>3. NUMERIC upperbound - the index of the previously-determined upper bound column<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170627 (previously developed for Sarah Baker's research model)<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  WITH NUMERIC UBSum = FOR ( DATETIME date IN ( GET @INDEX 0.00000000 FROM datesToEOWY ) TO GET @INDEX ( LENGTH datesToEOWY ) - 1.00000000 FROM datesToEOWY ) STAT_SUM
   releaseTable ["GetMonthAsString"( date ), upperbound]
  ENDFOR DO
   IF ( ( UBSum - RemainingRelease < 1.00000000 "acre-feet" ) OR ( upperbound == 1.00000000 "acre-feet" ) COMMENTED_BY "Upper bound is first populated column <br>" )
   THEN
    upperbound
   ELSE
    upperbound - 1.00000000
   ENDIF
  ENDWITH
 ENDWITH COMMENTED_BY "If the remaining release volume is within 1 acre-foot of the previously determined upper bound sum, use it as <br>the lower bound also; otherwise, decrease the lower bound index";

    END
    UUID "{069ee7fb-5d26-462a-8b96-91fc757d936c}";;

    FUNCTION       "ReleaseAdjustment" ( NUMERIC VolumeDeviation, DATETIME EOWY )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the adjustment to the Powell release required to meet the condition specified by the ControllingEqualizationCondition, incorporating Mead and Powell bank storage estimates where necessary.<br><br>RETURNS: Adjustment to the Powell release necessary to correct the VolumeDeviation [L^3]<br><br>ARGUMENTS:<br>1. VolumeDeviation - the volume by which Powell and/or Mead deviate from their respective storages that would satisfy the controlling condition<br>2. EOWY - the end of water year date for the water year under consideration<br><br>CONSTRAINTS: NONE";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 201801";
    BEGIN

      IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.10000000 )
 THEN
  VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] )
 ELSE
  IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.20000000 OR NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.30000000 )
  THEN
   VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] )
  ELSE
   IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.40000000 )
   THEN
    VolumeDeviation / ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] )
   ELSE
    IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.50000000 )
    THEN
     VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] )
    ELSE
     IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWY )] ) == 1.27000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWY )] ) == 1.29000000 )
     THEN
      IF ( VolumeDeviation < 0.00000000 "acre-feet" )
      THEN
       "Max"( $ "PowellData.UpperTierB2MinAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )], VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) )
      ELSE
       "Min"( VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ), $ "PowellData.UpperTierB2MaxAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )] )
      ENDIF
     ELSE
      IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWY )] ) == 1.40000000 )
      THEN
       "Min"( "Max"( $ "PowellData.UpperTierB4MinAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )], VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) ), $ "PowellData.UpperTierB4MaxAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )] )
      ELSE
       0.00000000 "acre-ft"
      ENDIF
     ENDIF COMMENTED_BY "If refining a UEB volume, have to restrict adjustment to keep total annual release within allowable bounds   <br>"
    ENDIF COMMENTED_BY "Fourth possible condition is that Powell elevation needs to be at 20ft below the equalization level by the end-of-water-year"
   ENDIF COMMENTED_BY "Third possible condition is that Mead needs to be at elevation 1105 ft by the end-of-water-year"
  ENDIF COMMENTED_BY "Second possible condition is that the end-of-water-year storages need to be equal between Powell and Mead."
 ENDIF;

    END
    UUID "{c5193736-68cb-48c8-b8a8-8b51289afaa4}";;

    FUNCTION       "GetMeadProjectedPoolElevation" ( DATETIME MeadProjectionDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines which Mead pool elevation projection to use based on the start timestep and MeadProjectionDate. If start timestep is Jan-July, use only previous years' AugEOYMeadPEProjection. If Aug-Dec, use the previous and current year's AugEOYMeadPEProjection.<br><br>RETURNS: Pool elevation value from either the Aug 24MS projection or from MTOM's projection<br><br>ARGUMENTS:<br>1. DATETIME MeadProjectionDate - the EOCY date which Mead pool elevation is desired<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author, Date: SB, 20180917";
    BEGIN

      IF ( IF ( "GetMonth"( @"Start Timestep" ) < "GetMonth"( @"August" ) )
 THEN
  MeadProjectionDate == "Dec31ofYear"( @"Start Timestep" - 1.00000000 "year" )
 ELSE
  MeadProjectionDate == "Dec31ofYear"( @"Start Timestep" ) OR MeadProjectionDate == "Dec31ofYear"( @"Start Timestep" - 1.00000000 "year" )
 ENDIF )
 THEN
  $ "PowellToMeadData.AugEOYMeadPEProjection" [MeadProjectionDate]
 ELSE
  $ "Mead.Pool Elevation" [MeadProjectionDate]
 ENDIF COMMENTED_BY "Look at the Start Timestep to determine which Mead PE projection to use <br>";

    END
    UUID "{7a8bd6b0-635f-4559-94ec-4ae1684707c6}";;

    FUNCTION       "GetProjectedPoolElevation" ( STRING Reservoir, DATETIME ProjectionDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines which Mead or Powell pool elevation projection to use based on the start timestep and ProjectionDate. If start timestep is Jan-July, use only previous years' AugEOYPEProjection. If Aug-Dec, use the previous and current year's AugEOYPEProjection.<br><br>RETURNS: Pool elevation value from either the Aug 24MS projection or from MTOM's projection<br><br>ARGUMENTS:<br>1. STRING Reservoir - &quot;Powell&quot; or &quot;Mead&quot; the reservoir pool elevation is desired<br>2. DATETIME ProjectionDate - the EOCY date which pool elevation is desired<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author, Date: SB, 20180917";
    BEGIN

      IF ( IF ( "GetMonth"( @"Start Timestep" ) < "GetMonth"( @"August" ) )
 THEN
  ProjectionDate == "Dec31ofYear"( @"Start Timestep" - 1.00000000 "year" )
 ELSE
  ProjectionDate == "Dec31ofYear"( @"Start Timestep" ) OR ProjectionDate == "Dec31ofYear"( @"Start Timestep" - 1.00000000 "year" )
 ENDIF )
 THEN
  "GetSlot"( "PowellToMeadData.AugEOY" CONCAT Reservoir CONCAT "PEProjection" ) [ProjectionDate]
 ELSE
  "GetSlot"( Reservoir CONCAT ".Pool Elevation" ) [ProjectionDate]
 ENDIF COMMENTED_BY "Look at the Start Timestep to determine which PE projection to use  <br>";

    END
    UUID "{080db095-e752-440c-a59f-1a860c152bb4}";;

    FUNCTION       "EstimatePowellPEGivenOutflow" ( NUMERIC PreviousPE, NUMERIC Outflow, DATETIME CurrentDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function estimates the current month's pool elevation using a mass balance. The mass balance includes previous storage, current inflow, current outflow, evaporation and bank storage. <br><br>RETURNS: Estimate of current timestep's pool elevation<br><br>ARGUMENTS:<br>1. NUMERIC PreviousPE: previous timestep pool elevation<br>2. NUMERIC Outlfow: release <br>3. DATETIME CurrentDate: current date<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: unknown<br><br>SB 20210216: pulled out of other functions into a general function for calculation";
    BEGIN

      WITH NUMERIC tempPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousPE ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "FlowToVolume"( Outflow, CurrentDate ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ) ) DO
  WITH NUMERIC NewPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousPE ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "PowellEvapEstimation"( CurrentDate, PreviousPE, tempPE ) - "FlowToVolume"( Outflow, CurrentDate ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ) ) DO
   NewPE
  ENDWITH
 ENDWITH;

    END
    UUID "{cce70394-ccf1-498c-b483-e003db440517}";;

    FUNCTION       "BypassCapacity" ( NUMERIC PreviousElevation, NUMERIC EstimatedRelease, DATETIME CurrentDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function interpolates the bypass capacity from the average of the previous month and current month's pool elevation. The current month's pool elevation is estimated using the previous pool elevation and current estimated release.  <br><br>RETURNS: Estimate of Capacity of Bypass Tubes<br><br>ARGUMENTS:<br>1. NUMERIC PreviousElevation: previous timestep pool elevation<br>2. NUMERIC EstimatedRelease: estimated release from previous function<br>3. DATETIME CurrentDate: current date<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: SB 20210216<br>";
    BEGIN

      "TableInterpolation"( $ "PowellMinObjRelData.Bypass Tube Capacity", 0.00000000, 1.00000000, ( PreviousElevation + "EstimatePowellPEGivenOutflow"( PreviousElevation, EstimatedRelease, CurrentDate ) ) / 2.00000000, CurrentDate ) * 4.00000000;

    END
    UUID "{2e0e6d8e-0b06-4f93-82fc-8fec1ab2cb83}";;

    FUNCTION       "IterateBypassCapacity" ( NUMERIC PreviousElevation, NUMERIC InitRelease, DATETIME CurrentDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function iterates to calculate the current capacity of the bypass tubes based on the previous pool elevation and current estimated release for the current date. <br><br>RETURNS: Capacity of Bypass Tubes<br><br>ARGUMENTS:<br>1. NUMERIC PreviousElevation: previous timestep pool elevation<br>2. NUMERIC InitRelease: estimated release from previous function<br>3. DATETIME CurrentDate: current date<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: SB 20210216<br>";
    BEGIN

      WHILE ( "Abs"( capacity - "BypassCapacity"( PreviousElevation, capacity, CurrentDate ) ) > 50.00000000 "cfs" ) WITH NUMERIC capacity = "BypassCapacity"( PreviousElevation, InitRelease, CurrentDate ) DO
  "BypassCapacity"( PreviousElevation, capacity, CurrentDate )
 ENDWHILE;

    END
    UUID "{13b189dc-fa05-4447-8515-38fa12968fa2}";;

  END
  UUID "{267a21f3-36f2-4491-b419-b55c628ab94c}";;

  UTILITY_GROUP "Powell Steady Flow Experiment Functions - MTOM Only";
  DESCRIPTION   "";
  ACTIVE        FALSE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetSeptemberSteadyFlowRelease" ( NUMERIC AnnualReleaseVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "PowellData.SteadyFlowExperimentRelease" ["SteadyFlowTableRow"( AnnualReleaseVolume ), 1.00000000];

    END
    UUID "{4994050c-ecae-4e0a-9116-0866a2abe1ff}";;

    FUNCTION       "GetOctoberSteadyFlowRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns the october release volume of the current water year under steady flow experiment conditions. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "MonthIs"( { "October" , "November" , "December" } ) )
 THEN
  $ "Powell.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"]
 ELSE
  $ "Powell.Outflow" [@"24:00:00 September Max DayOfMonth, Previous Year"]
 ENDIF;

    END
    UUID "{488b3c34-c78d-447c-aa97-b512ef5a0f04}";;

    FUNCTION       "GetInitialPowellMonthlyVolumes" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function is invalide due to function input GetSeptemberSteadFlowRelease()";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      APPEND "FlowToVolume"( "GetSeptemberSteadyFlowRelease"( $ "PowellData.TargetAnnualReleaseVolume" [] ), @"24:00:00 September Max DayOfMonth, Current Year" ) ONTO INSERT "FlowToVolume"( "GetOctoberSteadyFlowRelease"(  ), @"24:00:00 October Max DayOfMonth, Current Year" ) INTO FOR ( NUMERIC i IN "GetNumbers"( 2.00000000, 11.00000000, 1.00000000 ) ) WITH LIST result = {  } DO
  APPEND "Interpolate"( "CurrentAnnualVolume"( @"t" ), $ "PowellData.PowellMonthlyReleaseTable" [0.00000000, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) )], $ "PowellData.PowellMonthlyReleaseTable" [0.00000000, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) ) + 1.00000000], $ "PowellData.PowellMonthlyReleaseTable" [i, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) )], $ "PowellData.PowellMonthlyReleaseTable" [i, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) ) + 1.00000000] ) ONTO result
 ENDFOR;

    END
    UUID "{38636fd6-f1b2-479e-996e-8942f8ada50c}";;

    FUNCTION       "SteadyFlowTableRow" ( NUMERIC AnnualReleaseVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WHILE ( AnnualReleaseVolume >= $ "PowellData.SteadyFlowExperimentRelease" [i, 0.00000000] ) WITH NUMERIC i = 0.00000000 DO
  i + 1.00000000
 ENDWHILE;

    END
    UUID "{bc254638-8834-4b52-adbb-36d7e5c93071}";;

    FUNCTION       "SteadyFlowReduce_1_July" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  IF ( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] >= 0.00000000 "acre-ft" )
  THEN
   "Min"( "GetElement"( monthlyRelease, 2.00000000 ) - 800.00000000 "1000 acre-ft", "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] ) COMMENTED_BY "Return either the amount of reduction in july down to 800 kaf <br>or the total reduction (if it all occurs in July)"
  ELSE
   "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" []
  ENDIF COMMENTED_BY "If the monthly releases exceed the annual release volume, then decrease july first"
 ENDWITH;

    END
    UUID "{ae62f1ac-a1ea-451f-b621-df30a580306c}";;

    FUNCTION       "SteadyFlowReduce_2_August" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 1.00000000 ) COMMENTED_BY "1 in reverse order is august" - 800.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in August down to 800 kaf <br>or the total reduction (if it all occurs in August)"
 ENDWITH;

    END
    UUID "{8c8bec06-a173-486b-8ca9-925a6086971c}";;

    FUNCTION       "SteadyFlowReduce_3_June1" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 3.00000000 ) - 800.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 800 kaf <br>or the total reduction (if it all occurs in June), In both cases negatives <br>can occur, so zero these out "
 ENDWITH;

    END
    UUID "{4b972d2b-f2f1-4aff-90a1-1703d94933e6}";;

    FUNCTION       "SteadyFlowReduce_4_June2" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 3.00000000 ) COMMENTED_BY "3 in reverse order is june" - 600.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 600 kaf <br>or the total reduction (if it all occurs in June)"
 ENDWITH;

    END
    UUID "{f782029f-8998-422d-bcf9-52ad52e24aad}";;

    FUNCTION       "SteadyFlowReduce_5_April" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 5.00000000 ) COMMENTED_BY "5 in reverse order is april" - 500.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ) - "SteadyFlowReduce_4_June2"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in April down to 500 kaf<br>or the total reduction (if it all occurs in June)"
 ENDWITH;

    END
    UUID "{27e62804-9b38-44f9-aa69-77a89b45c073}";;

    FUNCTION       "SteadyFlowReduce_6_May" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 4.00000000 ) COMMENTED_BY "4 in reverse order is may" - 500.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ) - "SteadyFlowReduce_4_June2"(  ) - "SteadyFlowReduce_5_April"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 600 kaf <br>or the total reduction (if it all occurs in June)"
 ENDWITH;

    END
    UUID "{9b51a539-9b3a-43a6-9fb3-5f5d948e6398}";;

    FUNCTION       "DepletionToDiversionRatio" ( STRING depletionSlot, STRING diversionSlot, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( depletionSlot [date] == 0.00000000 "cms" )
 THEN
  0.00000000
 ELSE
  diversionSlot [date] / depletionSlot [date]
 ENDIF;

    END
    UUID "{eedbc123-91eb-4933-b188-38702f653964}";;

    FUNCTION       "SubbasinShortage" ( STRING subbasin, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( OBJECT obj IN "ListSubbasin"( subbasin ) SET_INTERSECTION ( "ListSubbasin"( "AggDiversionSite" ) COMMENTED_BY "Can eliminate after bug 4914 is fixed.  Have to do this now because we are <br>expecting only aggregate diversion sites not individual water users" ) ) WITH NUMERIC totalShortage = 0.00000000 "acre-ft" DO
  FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC userShortage = 0.00000000 "acre-ft" DO
   userShortage + ( "FlowToVolume"( % "SanJuanNewMexicoDiversionSchedules" & ( ( STRINGIFY obj ) CONCAT "_" CONCAT "Depletion" ) [date], date ) - "FlowToVolume"( obj & "Total Depletion Requested" [date], date ) ) COMMENTED_BY "Subtract off depletion requested because this slot <br>has already been reduced by the WSA rule"
  ENDFOR + totalShortage
 ENDFOR;

    END
    UUID "{569b9fcf-44da-4528-9547-d02032e6aa9b}";;

  END
  UUID "{cb59d52f-1f58-4997-b3b0-06ccd064bf4a}";;

  UTILITY_GROUP "Lower Basin Schedules - MTOM Only";
  DESCRIPTION   "9/18/2018, AP: This utility group is for functions used in the calculation of LB Schedules and recalculation of schedules when the tier switches between RC 3 and RC 4. ";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "SNWP_Schedules" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "9/18/2018, AP: used in the calculation of SNWP schedules. Changed original logic to refernce Nevada_CU_Schedules instead of PumpingfromMead<br><br>6/16/2020, AP: Changed outyear calculation to match the 24 MS";
    BEGIN

      IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
 THEN
  ( "VolumeToFlow"( $ "Nevada_CU_Schedules.SNWP" [date], date ) + ( "VolumeToFlow"( $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"], date ) ) / ( 12.00000000 - "GetMonth"( @"Start Timestep" ) + 1.00000000 ) )
 ELSE
  "VolumeToFlow"( $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) * ( "FlowToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date], date ) / "SumFlowsToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" ) )
 ENDIF;

    END
    UUID "{b67f7c86-19a1-44b3-861c-d130e19d1d17}";;

    FUNCTION       "CAP_Outyear_Schedules" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "9/18/2018, AP: logic used in the calculation of CAP outyear schedules. Logic orignally came from Reset Monthly Forecast Use CAP - all month outyears.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( ( ( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"], date ) ) / "GetDaysBasedOnFirstDate"( @"t" ) + "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date ) ) COMMENTED_BY "LC CHECK<br><br>In the SNWP rule, we redistribute outyear schedules based on the distribution percentage per <br>month. Should this be the same??? <br>" );

    END
    UUID "{31225d56-0749-4049-bdc7-0a8d76c06994}";;

    FUNCTION       "MWD_Outyear_Schedules" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "9/18/2018, AP: This function is used in the calculation of MWD schedules. Logic originally from rule Reset Monthly forecast use MWD - All months outyears";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( "VolumeToFlow"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "California_CU_Forecast1.MWD" [@"24:00:00 December 31, Current Year"], date ) ) / "GetDaysBasedOnFirstDate"( @"t" ) + "VolumeToFlow"( $ "California_CU_Schedules.MWD" [date], date );

    END
    UUID "{0e388d7f-ee1d-4709-b1c5-d27b9bd42158}";;

    FUNCTION       "LBConditionDetermination" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the operating condition of the lower basin.<br><br>RETURNS: Lower Basin condition flag<br><br>ARGUMENTS:<br>NA<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: AP 9/18/2018<br><br>S.Baker, 20180925: Changed IF statements to use function 'GetProjectedPoolElevation' instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). ";
    BEGIN

      IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
 THEN
  1.00000000 COMMENTED_BY "If Mead is below 1,075 ft, then set the Basin Condition value to 1 for Shortage"
 ELSE
  IF ( "QuantifiedSurplusVolume"(  ) > 0.00000000 "acre-ft" )
  THEN
   3.00000000 COMMENTED_BY "If the Quantified Surplus Volume Calculation is greater than zero, <br> then set the Basin Condition value to 3 for Quantified Surplus"
  ELSE
   IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Surplus.Domestic Surplus Trigger Elevation" [] )
   THEN
    2.00000000 COMMENTED_BY "If Mead is greater than 1,145 ft, then set the Basin Condition value to 2 for Domestic Surplus"
   ELSE
    0.00000000 COMMENTED_BY "If the Mead Elevation is between 1,075 and 1,145 and there is not enough water to <br>warrent a quantified surplus condition, set the Basin Condition value to 0 for a <br>normal condition"
   ENDIF
  ENDIF
 ENDIF;

    END
    UUID "{1c46abdf-5158-4df5-8faa-843d756c060a}";;

    FUNCTION       "Monthly Sum Non SNWP Nevada Users" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Function added 4/29/2020 by AJP<br><br>Sums Non SNWP Water User in Nevada";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "FlowToVolume"( $ "FtMohaveIndRes:NV.Diversion Requested" [date], date ) + "FlowToVolume"( $ "NvDvsToPkr:BigBend.Diversion Requested" [date], date ) + "FlowToVolume"( $ "NvDvsToPkr:SCE.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date], date );

    END
    UUID "{ecc51a7f-8770-4cdc-be84-c04ca39aa8d5}";;

    FUNCTION       "Annual Sum Non SNWP Nevada Users" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Function added 4/29/2020 by AJP<br><br>Sums Non SNWP Water User in Nevada";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( $ "Nevada_CU_Forecast1.BigBend" [date] + $ "Nevada_CU_Forecast1.LMNRA Mohave" [date] + $ "Nevada_CU_Forecast1.SCE" [date] + $ "Nevada_CU_Forecast1.FtMohaveNv" [date] );

    END
    UUID "{261d4118-915a-4fa1-aa27-8607ce06f94f}";;

  END
  UUID "{e12722c5-cd2e-4fc8-a9c7-df9184cd5532}";;

  UTILITY_GROUP "DCP and ICS Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "DCP Users" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      { "AZ" , "NV" , "CA" , "MWD" , "Coachella" , "MX" };

    END
    UUID "{6d8a55e4-b48e-4374-a4a6-6472c2f18ce9}";;

    FUNCTION       "TaxedECICS" ( NUMERIC annualCreation, NUMERIC previousDelivery )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( annualCreation - previousDelivery, 0.00000000 "acre-feet" ) COMMENTED_BY "Per Section IV.A.3, Replenishment Incentive, there shall be no assement made upon the creation <br>of ECICS to the extent of the volume of EC ICS delivered to the same contractor in the preceding <br>year<br><br>AP 7/11/19  <br>";

    END
    UUID "{a6e83404-f9a3-4083-86af-ff1e3a6d9d3a}";;

    FUNCTION       "NonTaxedECICS" ( NUMERIC annualCreation, NUMERIC previousDelivery )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Min"( annualCreation, previousDelivery ) COMMENTED_BY "Per Section IV.A.3, Replenishment Incentive, there shall be no assement made upon the creation <br>of ECICS to the extent of the volume of EC ICS delivered to the same contractor in the preceding <br>year<br><br>AP 7/11/19  <br>";

    END
    UUID "{692236dd-d545-45fb-968d-b35496cae6db}";;

    FUNCTION       "Current Year ECICS into Bank" ( NUMERIC AnnualCreation, NUMERIC PreviousDelivery, STRING State )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( "TaxedECICS"( AnnualCreation, PreviousDelivery ) * "SystemTaxAdjustment_DCP"(  ) + "NonTaxedECICS"( AnnualCreation, PreviousDelivery ) ) + IF ( State == "Nevada" )
 THEN
  $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December 31, Previous Year"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

    END
    UUID "{eac40aed-9d69-40d5-bf49-2974b9138165}";;

    FUNCTION       "CAWCD Requested ICS" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( $ "ICS Credits.AnnualICSDelivery_CAWCD" [@"24:00:00 December 31, Current Year"] + "CAWCD Mitigation Water"(  ) + "CAWCD DCP ICS Delivery"(  ) + "CAWCD Post 2026 ICS Delivery"(  ) ) COMMENTED_BY "Not used in MTOM but in 24 MS. Should this be deleted? <br>";

    END
    UUID "{33f11602-8300-4c10-8ade-5bf2495fc704}";;

    FUNCTION       "CAWCD Mitigation Water" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] <= 2.00000000 AND $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] >= 1.00000000 AND "GetYear"( @"t" ) <= 2025.00000000 )
 THEN
  $ "ICS Credits.CAWCD Mitigation Water" []
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

    END
    UUID "{44cfadd3-ed14-4deb-9489-7c52ef05b70f}";;

    FUNCTION       "CAWCD DCP ICS Delivery" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "S.Baker, 20200310: Added function IsMeadAboveDCPRecoveryElevation() to replace frequently used boolean. ";
    BEGIN

      IF ( "IsMeadAboveDCPRecoveryElevation"( @"24:00:00 December 31, Previous Year" ) )
 THEN
  $ "ICS Credits.DCPICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

    END
    UUID "{22ddeac4-2ef3-4f80-b754-68ec2aa9b6bb}";;

    FUNCTION       "CAWCD Available Canal Space" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "LC, 20200416: adjust the second half of the statement.<br>APivarnik, 20200929: Added CAWCD mitigation water and note to function.";
    BEGIN

      ( $ "AnnualWaterUse.CAPCanal_AnnualCapacity" [] + "CAWCD Mitigation Water"(  ) COMMENTED_BY "This ensures that CAP takes the full amount of mitigation water under a shortage condition when <br>LBDV makes excess water available to CAP. The ruleset will take out the neccessary shortage/D<br>CP water later in the ruleset. This was implemented because at this point in the ruleset, LBDV <br>reduced the canal space to less than the mitigation volume and it did not take into account that <br>the diversion would be reduced later on due to shortage/DCP (thus making more space <br>available).     <br>" ) - IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Surplus.Domestic Surplus Trigger Elevation" [] )
 THEN
  $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"]
 ELSE
  $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"]
 ENDIF;

    END
    UUID "{7478f1a7-9e89-4d19-8daa-6825b3214a40}";;

    FUNCTION       "CVWD DCP Contribution" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Function added on 20200506 by APivarnik<br><br>Sets DCP adjustment to 0 if in start year. It is assumed the DCP adjustment by CVWD (per intrastate CA agreement) is already in the start year schedule";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "ICS Credits.AnnualDCPContribution_Coachella" [@"24:00:00 December Max DayOfMonth, Current Year"]
 ENDIF;

    END
    UUID "{0d307bfa-3004-47ff-8290-997c31a96c5c}";;

    FUNCTION       "IID ICS Diversion Adjustment" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Function added 20200506 by A Pivarnik<br><br>Checks whether there was a difference in the ICS passed from 24 MS to MTOM and what MTOM calculated via rules";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.AnnualCreationEC_IID_Default" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.AnnualDeliveryEC_IID" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationEC_IID" ["Dec31ofYear"( @"t" )] );

    END
    UUID "{f961dc05-228a-4f62-8d55-fe8abb44881b}";;

    FUNCTION       "DeliveryAndCreationMWDICS" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the volumes of ICS delivered and EC ICS created for California, taking into account Lower Basin Demand Variability <br><br>RETURNS: List of lists of the form &lcub;&lcub;ICS delivered, EC ICS created&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20180125: Removed SystemTaxAdjustment from Annual Max in MinItem for creationOfCACEICS local variable based on USBR changes to ruleset<br>CH, 4/27/18: Changed totaldeliveryofCAICS assignment so that the available ICS water was was referencing total CA ICS, not just CA EC ICS<br>CH, 5/8/18: In MWD EC ICS creation assignment, maximum creation of MWD EC ICS edited to be CA max put - IID EC creation; in MWD ICS delivery assignment, available ICS water edited to be min of (MWD max take - IID total ICS) and (total MWD ICS + creation EC ICS*system tax) in order to separate MWD ICS creation and delivery from IID ICS creation and delivery <br>CH, 5/10/18: renamed function and internal variables to refer to MWD ICS instead of CA ICS to avoid confusion<br>AP, 4/11/19: Added constraint to make sure the deterministic run uses the default 24 MS inputs<br>S. Baker, 20200311: Add function IsDomesticSurplus() to replace Or statement to improve readability. ";
    BEGIN

      IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" OR NOT "IsMRM"(  ) )
 THEN
  { $ "ICSProjectionData.AnnualDeliveryBiNat_MWD_Default" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.AnnualDeliverySysEff_MWD_Default" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.AnnualDeliveryEC_MWD_Default" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.AnnualDeliveryDCPICS_MWD_Default" ["Dec31ofYear"( @"t" )] , $ "ICSProjectionData.AnnualCreationEC_MWD_Default" ["Dec31ofYear"( @"t" )] }
 ELSE
  WITH NUMERIC creationOfMWDECICS = IF ( ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NOT "IsMRM"(  ) ) COMMENTED_BY "If a Quantified Surplus Year, a Flood Control Year, or if the run is a deterministic Min, Max or <br>Most run, do not Create any ICS TP 12/18/2017, updated for DCP AP 10/21/19<br>" )
  THEN
   0.00000000 "acre-ft"
  ELSE
   "MinItem"( { $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Put Step 1"] COMMENTED_BY "Annual Max <br>" , "Max"( ( $ "ICS Credits.MeadBankParameters" ["MWD", "Max Capacity"] - ( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December 31, Previous Year"] ) ), 0.00000000 "acre-ft" ) COMMENTED_BY "Account Space <br>" , ( $ "ICS Credits.MeadBankParameters" ["California", "Max Creation"] - $ "ICSProjectionData.AnnualCreationEC_IID_Default" [@"24:00:00 December 31, Current Year"] ) COMMENTED_BY "Maximum Creation of MWD ICS <br>" , "Max"( "SumFlowsToVolume"( $ "MWDDiversion:MWD.Diversion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) - $ "AnnualWaterUse.MWDMinimumAnnualDelivery" [], 0.00000000 "acre-ft" ) COMMENTED_BY "Difference between Diversion Requests and Minimum Required MWD Delivery <br>" } )
  ENDIF DO
   WITH NUMERIC totalDeliveryOfMWDICS = "ICSDeliveryReduction_DCP"( "MinItem"( { IF ( NOT "IsMRM"(  ) )
   THEN
    0.00000000 "acre-ft"
   ELSE
    IF ( "IsDomesticSurplus"(  ) COMMENTED_BY "If the year has domestic surplus, reduce the ICS Delivery by the amount of <br>Domestic surplus entitlement for MWD. TP 12/18/2017 <br>" )
    THEN
     "Max"( ( $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] - $ "Surplus Volume Entitlements.MWD Domestic" ["Dec31ofYear"( @"t" )] ), 0.00000000 "acre-ft" )
    ELSE
     $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] COMMENTED_BY "Not Surplus or Shortage <br>"
    ENDIF COMMENTED_BY "flood control <br>"
   ENDIF , ( $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) <= $ "Surplus.Domestic Surplus Trigger Elevation" [] )
   THEN
    $ "AnnualWaterUse.MWD_NormalOpMax" []
   ELSE
    $ "ICS Credits.TotalICS_MWD" [@"24:00:00 December 31, Current Year"]
   ENDIF ) COMMENTED_BY "MWD at full ditch (Conveyance Capacity)<br>" , "Min"( $ "ICS Credits.MeadBankParameters" ["California", "Max Take"] - ( $ "ICSProjectionData.AnnualDeliveryBiNat_IID_Default" [@"24:00:00 December 31, Current Year"] + $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" [@"24:00:00 December 31, Current Year"] ), $ "ICS Credits.TotalICS_MWD" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "Make sure the amount of Delivery taken is within the MWD ICS bank or below <br>the Maximum Take that MWD can have. TP 12/18/2017  <br>" + creationOfMWDECICS * "SystemTaxAdjustment_DCP"(  ) ) COMMENTED_BY "Available ICS Water <br>" } ), "California", "Max Delivery", $ "ICS Credits.AnnualConversionECtoDCP_MWD" [@"24:00:00 December 31, Current Year"] ) DO
    { totalDeliveryOfMWDICS , creationOfMWDECICS }
   ENDWITH
  ENDWITH
 ENDIF;

    END
    UUID "{7041b37d-1172-484e-aec6-cf16887c9756}";;

    FUNCTION       "FloodControlECICSBalance" ( NUMERIC fcvolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes the passed in flood control volume and uses the resulting EC ICS volumes for each state to determine the balance for each state. Then determines a reduction ratio which is the flood control volume divided by the total EC ICS volume.  If this value is greater than 1, the flood control volume is greater than the total EC ICS volume and the resulting EC Volumes need to be set to 0 AF. If the ratio is less than one, then the EC ICS volumes need to be reduced by the ratio proportional to the volume for each state.  The function returns the volumes for each state in AF. - TP 11/4/2014<br><br>RETURNS: List of lists of the form &lcub;&lcub;CA EC balance, NV EC balance, AZ EC balance, CA Total ICS, NV Total ICS, AZ Total ICS&rcub;&rcub;<br><br>ARGUMENTS:<br>1. NUMERIC fcvolume - Flood control release rate<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 11/4/2014<br><br>12/11/18, AP: edited to include MWD / IID ICS CA split, edited to more accurately reflect ICS  flood control in interim guidlines (% ICS change)";
    BEGIN

      WITH NUMERIC mwdECICS = $ "ICS Credits.ExtraordinaryConservationICS_MWD" ["Dec31ofYear"( @"t" )] DO
  WITH NUMERIC iidECICS = $ "ICS Credits.ExtraordinaryConservationICS_IID" ["Dec31ofYear"( @"t" )] DO
   WITH NUMERIC nvECICS = $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] DO
    WITH NUMERIC cawcdECICS = $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" ["Dec31ofYear"( @"t" )] DO
     WITH NUMERIC critECICS = $ "ICS Credits.ExtraordinaryConservationICS_CRIT" ["Dec31ofYear"( @"t" )] DO
      WITH NUMERIC gricECICS = $ "ICS Credits.ExtraordinaryConservationICS_GRIC" ["Dec31ofYear"( @"t" )] DO
       WITH NUMERIC mviddECICS = $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" ["Dec31ofYear"( @"t" )] DO
        WITH NUMERIC wmECICS = $ "ICS Credits.ExtraordinaryConservationICS_WM" ["Dec31ofYear"( @"t" )] DO
         WITH NUMERIC totalECICS = mwdECICS + iidECICS + nvECICS + cawcdECICS + critECICS + gricECICS + mviddECICS + wmECICS DO
          WITH NUMERIC mwdOtherICS = $ "ICS Credits.TotalICS_MWD" ["Dec31ofYear"( @"t" )] - mwdECICS DO
           WITH NUMERIC iidOtherICS = $ "ICS Credits.TotalICS_IID" ["Dec31ofYear"( @"t" )] - iidECICS DO
            WITH NUMERIC nvOtherICS = $ "ICS Credits.TotalICS_NV" ["Dec31ofYear"( @"t" )] - nvECICS DO
             WITH NUMERIC cawcdOtherICS = $ "ICS Credits.TotalICS_CAWCD" ["Dec31ofYear"( @"t" )] - cawcdECICS DO
              IF ( fcvolume < totalECICS )
              THEN
               WITH LIST stateECBalLista = { mwdECICS - ( mwdECICS / totalECICS ) * fcvolume , iidECICS - ( iidECICS / totalECICS ) * fcvolume , nvECICS - ( nvECICS / totalECICS ) * fcvolume , cawcdECICS - ( cawcdECICS / totalECICS ) * fcvolume , critECICS - ( critECICS / totalECICS ) * fcvolume , gricECICS - ( gricECICS / totalECICS ) * fcvolume , mviddECICS - ( mviddECICS / totalECICS ) * fcvolume , wmECICS - ( wmECICS / totalECICS ) * fcvolume } DO
                WITH LIST totalICSBalList = { mwdOtherICS + GET @INDEX 0.00000000 FROM stateECBalLista , iidOtherICS + GET @INDEX 1.00000000 FROM stateECBalLista , nvOtherICS + GET @INDEX 2.00000000 FROM stateECBalLista , cawcdOtherICS + GET @INDEX 3.00000000 FROM stateECBalLista } DO
                 { 0.00000000 "acre-ft" , GET @INDEX 0.00000000 FROM stateECBalLista , GET @INDEX 1.00000000 FROM stateECBalLista , GET @INDEX 2.00000000 FROM stateECBalLista , GET @INDEX 3.00000000 FROM stateECBalLista , GET @INDEX 4.00000000 FROM stateECBalLista , GET @INDEX 5.00000000 FROM stateECBalLista , GET @INDEX 6.00000000 FROM stateECBalLista , GET @INDEX 7.00000000 FROM stateECBalLista , GET @INDEX 0.00000000 FROM totalICSBalList , GET @INDEX 1.00000000 FROM totalICSBalList , GET @INDEX 2.00000000 FROM totalICSBalList , GET @INDEX 3.00000000 FROM totalICSBalList }
                ENDWITH
               ENDWITH
              ELSE
               { 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , mwdOtherICS , iidOtherICS , nvOtherICS , cawcdOtherICS } COMMENTED_BY "if the FC volume is greater than the EC ICS total delivery volume and EC ICS volume, then reduce the state values for delivery and volume to 0 AF and the total ICS volume for each state <br>will be equal to the other ICS Volumes in the system. "
              ENDIF COMMENTED_BY "If the Flood Control is greater than the delivery volume, but less than the total EC ICS volume plus the EC ICS Delivery, reduce the state EC ICS volume by the amount<br>of the Flood Control volume less the EC ICS total delivery volume. Reduce the current EC ICS volumes for each state by the ratio derived and reduce the Total ICS Volume <br>for each state by the difference each state volume of EC ICS "
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH COMMENTED_BY "Get the Total ICS Volume for each stat minuse the EC water"
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Get the EC ICS Volumes for each state and compute <br>the total volume. ";

    END
    UUID "{7232ee59-42ea-44fa-804c-baab7f95b193}";;

    BREAKPOINT AFTER_EXEC FALSE;
    FUNCTION       "ICSAccountingForAZ" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the ICS categories Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat) and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total Arizona ICS Volume. <br>The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>For the delivery of AZ ICS: <br>If the projected January Lake Mead elevation is 1,100 ft or higher, then set the ICS delivery to the Total ICS Created / 10. <br> In the case that the Lower Basin is in Surplus, CAP would take delivery of 1/10 ICS Created in addition to any Surplus entitlement. <br> In cases where the projected January Lake Mead elevation is under 1,100 ft, set the delivery volume to 0 af, regardless of Normal or Shortage condition. <br><br>RETURNS: List of lists of the form &lcub;&lcub;Delivery charged to EC, Delivery charged to SE, Delivery charged to Binational, AZ EC ICS, AZ SE ICS, Binational AZ ICS, Total AZ ICS, Total AZ ICS delivery, Total AZ ICS creation&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014<br><br>CH, 4/27/18: Deleted if else statements in creation of SE and Binat ICS so that AZ is allowed to created these types of ICS even in Shortage condition (only EC ICS cannot be created during a shortage). Cleaned up list the function returns and unused with statments: only 7 out of the 9 that were included are being used. <br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation).<br>AP, 11/30/18: Changed all evap tax references  from *0.97 to the EvapTaxAdjustment function, changed all system tax references  from *0.95 to the SystemTaxAdjustment function.<br>AP, 20191130: Updated for DCP.<br>A.Pivarnik, 20200714: Integration effort. Rewrote ICS accounting for AZ function to match the other states. Also rewrote all neccessary ICS creation/delivery rules and functions in ruleset for AZ to better match other states. This prevented the ICSAccountingforAZ function from getting too big during the integration effort (was solving for approx 34 variables, some twice depending on 24 MS mode vs MTOM mode)";
    BEGIN

      WITH NUMERIC SysEff_CAWCD = ( $ "ICS Credits.SystemEfficiencyICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliverySysEff_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
  WITH NUMERIC BiNat_CAWCD = ( $ "ICS Credits.BiNationalICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryBiNat_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
   WITH NUMERIC nontaxableECICScreation = $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] DO
    WITH NUMERIC CAWCDpreliminaryECICScreation = $ "ICSProjectionData.AnnualCreationEC_CAWCD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
     WITH NUMERIC ConversionofExcessDCPICStoICSprovisionVolume = ( GET @INDEX 0.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "AZ" ) ) DO
      WITH NUMERIC AnnualDCPcontribution = $ "ICS Credits.AnnualDCPContribution_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
       WITH NUMERIC CAWCDcreationECICSforDCPcontribution = "Min"( $ "ICS Credits.AnnualRemainingDCPContribution_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"], CAWCDpreliminaryECICScreation ) DO
        WITH NUMERIC CAWCDdcpCONTRIBUTIONasECICS = "Min"( ConversionofExcessDCPICStoICSprovisionVolume, CAWCDcreationECICSforDCPcontribution ) DO
         WITH NUMERIC CAWCDdcpCONTRIBUTIONasDCPICS = CAWCDcreationECICSforDCPcontribution - CAWCDdcpCONTRIBUTIONasECICS DO
          WITH NUMERIC CAWCDsyswaterDCPContribution = AnnualDCPcontribution - CAWCDdcpCONTRIBUTIONasDCPICS - CAWCDdcpCONTRIBUTIONasECICS DO
           WITH NUMERIC AnnualCreationEC_CAWCD = "SetNegativeToZero"( CAWCDpreliminaryECICScreation - CAWCDcreationECICSforDCPcontribution ) + CAWCDdcpCONTRIBUTIONasECICS DO
            WITH LIST EC_DCP_accounting = FOR ( NUMERIC account IN { AnnualCreationEC_CAWCD , CAWCDdcpCONTRIBUTIONasDCPICS } ) WITH LIST result = {  } DO
             WITH NUMERIC remainingNONTAXABLEics = IF ( ( LENGTH result ) == 0.00000000 )
             THEN
              nontaxableECICScreation
             ELSE
              nontaxableECICScreation - "SumByIndex"( result, 0.00000000 )
             ENDIF DO
              WITH NUMERIC nontaxedICS = "Min"( account, remainingNONTAXABLEics ) DO
               WITH NUMERIC taxedICS = account - nontaxedICS DO
                APPEND { nontaxedICS , taxedICS } ONTO result
               ENDWITH
              ENDWITH
             ENDWITH
            ENDFOR DO
             WITH LIST AnnualCreationEC_CAWCDlist = GET @INDEX 0.00000000 FROM EC_DCP_accounting DO
              WITH LIST CAWCDdcpCONTRIBUTIONasDCPICSlist = GET @INDEX 1.00000000 FROM EC_DCP_accounting DO
               WITH NUMERIC AnnualCreationEC_CAWCDnontaxed = GET @INDEX 0.00000000 FROM AnnualCreationEC_CAWCDlist DO
                WITH NUMERIC AnnualCreationEC_CAWCDtaxed = GET @INDEX 1.00000000 FROM AnnualCreationEC_CAWCDlist DO
                 WITH NUMERIC CAWCDdcpCONTRIBUTIONasDCPICSnontaxed = GET @INDEX 0.00000000 FROM CAWCDdcpCONTRIBUTIONasDCPICSlist DO
                  WITH NUMERIC CAWCDdcpCONTRIBUTIONasDCPICStaxed = GET @INDEX 1.00000000 FROM CAWCDdcpCONTRIBUTIONasDCPICSlist DO
                   WITH NUMERIC SimultaneousCreationDCPICS_CAWCD = CAWCDdcpCONTRIBUTIONasDCPICSnontaxed + CAWCDdcpCONTRIBUTIONasDCPICStaxed * "SystemTaxAdjustment_DCP"(  ) DO
                    WITH LIST AZFiming = "AZ Firming Agreement"(  ) DO
                     WITH NUMERIC FirmingBalanceAZ = $ "ICS Credits.FirmingAgreementBalance_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] - GET @INDEX 1.00000000 FROM AZFiming DO
                      WITH NUMERIC FirmingBalanceUS = $ "ICS Credits.FirmingAgreementBalance_US" [@"24:00:00 December Max DayOfMonth, Previous Year"] - GET @INDEX 2.00000000 FROM AZFiming DO
                       WITH NUMERIC ECICS_CAWCD = ( $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + AnnualCreationEC_CAWCDnontaxed + AnnualCreationEC_CAWCDtaxed * "SystemTaxAdjustment_DCP"(  ) - $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
                        WITH NUMERIC DCP_CAWCD = $ "ICS Credits.DCPICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualDeliveryDCP_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] + SimultaneousCreationDCPICS_CAWCD DO
                         WITH NUMERIC Bank_CAWCD = DCP_CAWCD + BiNat_CAWCD + ECICS_CAWCD DO
                          WITH NUMERIC TotalICS_CAWCD = ECICS_CAWCD + BiNat_CAWCD + SysEff_CAWCD + DCP_CAWCD DO
                           WITH NUMERIC ICSDivAdjustment = $ "ICS Credits.AnnualICSDelivery_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] - CAWCDsyswaterDCPContribution - ( CAWCDdcpCONTRIBUTIONasDCPICSnontaxed + CAWCDdcpCONTRIBUTIONasDCPICStaxed ) DO
                            { SysEff_CAWCD , BiNat_CAWCD , SimultaneousCreationDCPICS_CAWCD , CAWCDsyswaterDCPContribution , AnnualCreationEC_CAWCD , FirmingBalanceAZ , FirmingBalanceUS , ECICS_CAWCD , DCP_CAWCD , Bank_CAWCD , TotalICS_CAWCD , ICSDivAdjustment }
                           ENDWITH
                          ENDWITH
                         ENDWITH
                        ENDWITH
                       ENDWITH
                      ENDWITH
                     ENDWITH
                    ENDWITH COMMENTED_BY "########################################  <br>"
                   ENDWITH
                  ENDWITH
                 ENDWITH
                ENDWITH
               ENDWITH COMMENTED_BY "Store the list values as indivdual variables <br>"
              ENDWITH
             ENDWITH COMMENTED_BY "Pull out the individual lists <br>"
            ENDWITH COMMENTED_BY "########################################  <br>5. Using the following FOR loop, categorize the ICS creation as either non taxed or taxed for the <br>ICS going into EC or DCP accounts. The result of this FOR loop is a list of lists, with the first list <br>being the nontaxed/taxed EC ICS values, and the second list being the nontaxed/taxed DCP ICS <br>values. These values are then taken out of the lists and stored in temporary variables to be used <br>in the following balance calculations.    <br>"
           ENDWITH COMMENTED_BY "######################################## <br>4. Calculate the Annual Creation of EC ICS for CAWCD. The logic above converted as much of <br>the preliminary EC ICS creation as it needed to help meet the required DCP contribution, so <br>subtract that value (CAWCDcreationECICSforDCPcontribution) from the preliminary EC ICS <br>creation. Add back in any of the DCP contribution which can be made as EC ICS under the <br>provision previously discussed.    <br>"
          ENDWITH COMMENTED_BY "In year 1, the Conversion of Excess DCP ICS to ICS Provision function splits the DCP <br>contribution into 2 values, the DCP contribution based on actual EOY elevation, <1>, and the <br>difference between the DCP contribution based on the actual EOY elevation and projected <br>EOY elevation from the August 24 MS, <0>. This does not happen in outyears, it will pass 0 <br>acre-ft for <0> and the DCP creation required for the year as <1>.<br><br>So year 1, the system water calculation is: <1> + <0> - DCP ICS creation - EC ICS creation <br>calculated above.<br><br>In outyears the calculation is the following:  <1> - DCP ICS creation<br><br>The logic is calculating system water contribution the following way : (<1> - DCP ICS <br>creation) + (<0> - any EC ICS)<br><br>         <br>"
         ENDWITH
        ENDWITH COMMENTED_BY "########################################<br>3. Categorize the DCP Contribution as either the Excess DCP ICS to ICS Conversion volume (DCP <br>contirbution as EC ICS) or  DCP ICS. By setting the DCP contribution as EC ICS first, it prioritizes <br>putting ICS into the EC ICS account. <br><br>This takes as much of the CAWCDcreationECICSforDCPcontribution creation volume as you can <br>and puts it into DCP contribution as EC ICS. The remaining is going to be placed in the DCP ICS <br>account. If there is no ConversionofExcessDCPICStoICSvolume then the contribution will solve as <br>0 acre-ft.    <br>"
       ENDWITH COMMENTED_BY "########################################<br>2. EC to DCP Conversion (simultaneous creation)  <br>"
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH COMMENTED_BY "The following section of code calculates the DCP contribution and takes into account the <br>replinshment incentive and the Conversion of Excess DCP ICS to ICS provision in the DCP <br>exhibit.<br><br>Since the DCP assessment is post contribution, most of these calculations are pretax.<br><br>It does this by the following:<br><br>1. Defining the following key variables: nontaxableECICScreation, <br>CAWCDpreliminaryECICScreation, Conversion of ExcessDCPICStoICSprovision volume (only <br>needed in year 1). <br><br>2. Simultaneous creation. Looking at the remaining DCP contribution, convert as much of the <br>preliminary EC ICS to DCP ICS as needed. This value is stored as the <br>CAWCDcreationECICSforDCPcontribution. As of this point, this variable includes both the DCP <br>contribution as DCP ICS and the potential EC contribution under the Conversion of Excess <br>DCP ICS to ICS provision (III.E.3, bottom of page 6 of the DCP exhibit).<br><br>3. Categorize the DCP contrbution. This part splits the DCP contribution into either the <br>contribution being made as EC ICS (only an issue in year 1, III.E.3) or DCP ICS. After this is <br>done, calculate the system water needed to finish the DCP contribution.<br><br>4. Calculate the Annual EC ICS creation for CAWCD. This is a pretax value.<br><br>5. Calculate the post tax values for both EC ICS creation and DCP ICS. This part takes into <br>account the replenishment incentive (whether the creation gets taxed or not)<br><br><br>########################################<br>1. Definition of key variables              <br>"
  ENDWITH COMMENTED_BY "CAWCD BiNat ICS Balance <br>"
 ENDWITH COMMENTED_BY "CAWCD SysEff ICS Balance <br>";

    END
    UUID "{e0e3d1dc-285e-4568-aff5-33d074d303a5}";;

    FUNCTION       "ICSAccountingForMWD" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the MWD ICS categories Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat) and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total MWD ICS Volume. The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>RETURNS: List of lists of the form &lcub;&lcub;EC delivery, SE delivery, BiNat delivery, EC ICS created, CA EC ICS, CA SE ICS, CA BiNat ICS, Total CA ICS, MWD diversion reduction&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 9/10/2014<br>CH, 5/10/18: Renamed function from ICSAccountingForCA to ICSAccountingForMWD and renamed internal variables to refer to MWD ICS instead of CA ICS<br><br>A.Pivarnik, 20200714: Integration effort. Added if statement to replace the AnnualDCPContribution slot call in the system water variable. If conditional uses the StartYEarDCP contribution function to solve for the DCP contribution needed in YR1 if Lake Mead ends the previous calendar year at a different (lower) DCP elevation. <br>A.Pivarnik, 20201105: Added logic to just check against the preliminary value if in 24 MS mode when doing simultaneous conversion calculation. <br>A.Pivarnik, 20201106: changed MWDcurrentEICStoDCPICSconversion variable calculation by changing the mathmatical operator to plus (instead of minus) when calculating the amount of EC ICS in the bank";
    BEGIN

      WITH NUMERIC MWD_SysEffICS = $ "ICS Credits.SystemEfficiencyICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliverySysEff_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
  WITH NUMERIC MWD_BiNatICS = $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryBiNat_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
   WITH NUMERIC MWDcurrentECICStoDCPconversion = "Min"( $ "ICS Credits.AnnualRemainingDCPContribution_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"], IF ( "Is24MonthStudy"(  ) )
   THEN
    $ "ICSProjectionData.AnnualCreationEC_MWD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"]
   ELSE
    "Max"( 0.00000000 "acre-ft", ( ( ( $ "ICS Credits.MeadBankParameters" ["MWD", "Max Capacity"] - $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) - ( ( MWD_BiNatICS + $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + ( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) COMMENTED_BY "No need to take into account DCP delivery since it wont happen if Lower basin is operating under <br>DCP, no need to take into account any conversion from previous EC to DCP ICS because it is just <br>a paper transfer, the water is already accounted for in the EC ICS balance from the previous <br>year. <br><br>AP 11/19/19     <br>" ) ) / "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) COMMENTED_BY "Calculation of bank space for additional ICS creation to meet DCP calculation <br>" )
   ENDIF ) DO
    WITH NUMERIC MWDsyswaterDCPcontribution = ( ( GET @INDEX 1.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "CA" ) ) - $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - MWDcurrentECICStoDCPconversion + IF ( "IsStartYear"(  ) )
    THEN
     IF ( $ "ICSProjectionData.AnnualCreationEC_MWD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] >= 0.00000000 "acre-ft" )
     THEN
      "Max"( ( GET @INDEX 0.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "CA" ) ) - $ "ICSProjectionData.AnnualCreationEC_MWD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"], 0.00000000 "acre-ft" )
     ELSE
      0.00000000 "acre-ft"
     ENDIF
    ELSE
     0.00000000 "acre-ft"
    ENDIF ) COMMENTED_BY "This is the state of CA system water requirement. MWD meets CA DCP requirement <br>" DO
     WITH NUMERIC MWDannualECICScreation = "Max"( 0.00000000 "acre-ft", $ "ICSProjectionData.AnnualCreationEC_MWD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] - MWDcurrentECICStoDCPconversion ) DO
      WITH NUMERIC MWD_ECICS = $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year ECICS into Bank"( MWDannualECICScreation, $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"], "California" ) - $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
       WITH NUMERIC MWD_DCPICS = $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + ( $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] + MWDcurrentECICStoDCPconversion * "SystemTaxAdjustment_DCP"(  ) ) - $ "ICS Credits.AnnualDeliveryDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryDCP_Coachella" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
        WITH NUMERIC MWD_TotalICS = MWD_ECICS + MWD_SysEffICS + MWD_BiNatICS + MWD_DCPICS DO
         WITH NUMERIC MWD_ICSBank = MWD_ECICS + MWD_BiNatICS + MWD_DCPICS DO
          { MWD_SysEffICS , MWD_BiNatICS , MWDcurrentECICStoDCPconversion * "SystemTaxAdjustment_DCP"(  ) , MWDannualECICScreation , MWD_DCPICS , MWDsyswaterDCPcontribution , MWD_ECICS , MWD_TotalICS , MWD_ICSBank }
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH COMMENTED_BY "Since MWD's DCP contribution is meeting the state of CA full amount, this covers MWD and <br>CVWD's DCP contribution.<br><br>DCP Contributions will be made by converting EC ICS, then simultaneous creation, then system <br>water  <br>"
  ENDWITH COMMENTED_BY "BiNat Calculation <br>"
 ENDWITH COMMENTED_BY "CVWD DCP ICS accounting takes place under ICS Accounting for MWD. This is because CVWD is <br>storing their ICS under MWD's account. MWD meets the state of CA contribution<br><br>AP 11/19/19<br><br>Sys Eff Calculation   <br>";

    END
    UUID "{fb667623-0553-452e-af24-8afa189a5714}";;

    BREAKPOINT AFTER_EXEC TRUE;
    FUNCTION       "ICSAccountingForNV" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the ICS categories Tributary, Imported, Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat), Tributary DSS (Developed Shortage Supply), Imported DSS and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total Nevada ICS Volume. The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>For the delivery of NV ICS: <br>The delivery values of NV ICS are all input and if logic is needed to determine the delivery of NV ICS, then the logic would go into this function. <br><br>RETURNS: List of lists of the form &lcub;&lcub;Creation Trib ICS, Creation Trib DSS, SE ICS, EC ICS, NV Trib DSS ICS, NV Imp DSS ICS, NV BiNat ICS, NV Total ICS, Delivery of NV Trib DSS, Delivery of NV Imp DSS, Creation NV Imp ICS, Creation NV Imp DSS, NV Imp ICS, NV Trib ICS, Delivery of Trib ICS, Delivery of Imp ICS&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014<br><br>AP, 11/29/18: Updated deliveryofImpICS/deliveryofTribICS logic. Changed all system tax references  from *0.95 to the SystemTaxAdjustment function<br><br>AP, 11/30/18: Changed all evap tax references  from *0.97 to the EvapTaxAdjustment function<br><br>A. Pivarnik, 20200713: Integration effort. Added if statement to replace the AnnualDCPContribution slot call in the system water variable. If conditional uses the StartYearDCP contribution function to solve for the DCP contribution needed in YR1 if Lake Mead ends the previous calendar year at a different (lower) DCP elevation. Removed Mead bank check logic at end of rule since it is not needed. EC ICS creation and simultaneous conversion both checked against the bank capacity at different points.<br><br>A. Pivarnik, 20201105: Added logic to just check against the preliminary value if in 24 MS mode when doing simultaneous conversion calculation.";
    BEGIN

      WITH NUMERIC SysEff = $ "ICS Credits.SystemEfficiencyICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliverySysEff_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
  WITH NUMERIC BiNat = $ "ICS Credits.BiNationalICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryBiNat_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
   WITH NUMERIC Imported = $ "ICS Credits.AnnualCreationImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) - $ "ICS Credits.AnnualDeliveryImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
    WITH NUMERIC Tributary = $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) - $ "ICS Credits.AnnualDeliveryTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
     WITH NUMERIC currentECICStoDCPconversion = "Min"( $ "ICS Credits.AnnualRemainingDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"], IF ( "Is24MonthStudy"(  ) OR NOT "IsMRM"(  ) )
     THEN
      $ "ICSProjectionData.AnnualCreationEC_SNWP_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"]
     ELSE
      "Max"( 0.00000000 "acre-ft", ( ( $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Capacity"] - $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December 31, Previous Year"] ) - ( ( BiNat + $ "ICS Credits.DCPICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + ( $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December 31, Previous Year"] - $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) COMMENTED_BY "No need to take into account DCP delivery since it wont happen if Lower basin is operating under <br>DCP, no need to take into account any conversion from EC to DCP ICS because it is just a paper <br>transfer, the water is already accounted for in the EC ICS balance from the previous year. <br><br>AP 11/19/19    <br>" ) ) COMMENTED_BY "Calculation of bank space for additional ICS creation to meet DCP calculation. could possibly be <br>negative depending on tributary conservation ICS and available space  <br>" ) / "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December 31, Previous Year"]
     ENDIF COMMENTED_BY "This decides whether to have the logic check against the bank. This is needed in MTOM mode <br>since everything is done via logic, but not in 24 MS mode since the ICS creation is checked <br>against the bank manually. The 24 MS mode passes the default value calculated by River Ops <br>through the logic as the preliminary value. The default value for SNWA is adjusted via <br>apportionment since the ICS creation/delivery is the NV state apportionment minus the demand. <br>Any current year EC ICS creation converted to DCP ICS in 24 MS mode should use the preliminary <br>value manually calculated.           <br>" ) COMMENTED_BY "This MIN covers part B above. The ruleset has already attempted to convert existing EC ICS to <br>cover the DCP contribution (part A). The MIN below takes the minimum of the remaining DCP <br>contribution after part A, or the bank space in MTOM/manually calculated value of ICS creation in <br>the 24 MS. Any value from this min statement is subtracted from the preliminary ICS value which <br>has already been calculated (see rest of part B further down in the function), thus will give <br>current year EC ICS creation after the DCP contribution is met. If the remaining DCP contribution <br>can not be covered after this statement, the delivery will be reduced further via system water to <br>meet the DCP contribution (part C).             <br>" DO
      WITH NUMERIC syswaterDCPcontribution = ( GET @INDEX 1.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "NV" ) ) - $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - currentECICStoDCPconversion + IF ( "IsStartYear"(  ) )
      THEN
       IF ( $ "ICSProjectionData.AnnualCreationEC_SNWP_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] >= 0.00000000 "acre-ft" )
       THEN
        "Max"( ( GET @INDEX 0.00000000 FROM "Conversion of Excess DCP ICS to ICS Provision"( "NV" ) ) - $ "ICSProjectionData.AnnualCreationEC_SNWP_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"], 0.00000000 "acre-ft" )
       ELSE
        0.00000000 "acre-ft"
       ENDIF
      ELSE
       0.00000000 "acre-ft"
      ENDIF DO
       WITH NUMERIC SNWPannualECICScreation = "Max"( 0.00000000 "acre-ft", $ "ICSProjectionData.AnnualCreationEC_SNWP_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] - currentECICStoDCPconversion ) COMMENTED_BY "This logic helps calculate part B above. This attempts to use the preliminary EC ICS solved in a <br>prior rule to cover the DCP contribution from simultaneous creation solved above. If there is more <br>simultaneous creation than the preliminray calc, it evaulautes to 0.  <br>" DO
        WITH NUMERIC ECICS = $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year ECICS into Bank"( SNWPannualECICScreation, $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Nevada" ) - $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
         WITH NUMERIC DCPICS = $ "ICS Credits.DCPICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] + currentECICStoDCPconversion * "SystemTaxAdjustment_DCP"(  ) DO
          WITH NUMERIC MeadBank = BiNat + ECICS + DCPICS DO
           WITH NUMERIC TotalICS = MeadBank + ( SysEff + Imported + Tributary ) DO
            { SysEff , BiNat , Imported , Tributary , currentECICStoDCPconversion * "SystemTaxAdjustment_DCP"(  ) , SNWPannualECICScreation , syswaterDCPcontribution , ECICS , DCPICS , MeadBank , TotalICS }
           ENDWITH
          ENDWITH COMMENTED_BY "Start of bank logic <br>"
         ENDWITH COMMENTED_BY "BiNational ICS Calculation <br>"
        ENDWITH
       ENDWITH COMMENTED_BY "EC ICS Calculations<br>"
      ENDWITH COMMENTED_BY "This covers part C of the SNWA logic above. Calculates remaining DCP contribution needed if it is <br>not covered through conversion of previous balance or from any simultaneous conversions. This <br>will be made as sys water.<br>"
     ENDWITH COMMENTED_BY "EC ICS and DCP ICS Calculations<br><br>Per SNWA, do the following:<br><br>(A) Convert existing EC ICS to meet DCP contribution (done in previous rule). The value is <br>stored in the AnnualConversionPreviousECtoDCP_NV slot.<br><br>(B) Reduce deliveries to create DCP ICS until bank is filled (simultaneous creation). Since the <br>model  already has current year EC ICS creation, it attempts to use this first prior to reducing <br>the delivery further (below)<br><br>(C) Create system water if there is no bank space (below)                     <br>"
    ENDWITH
   ENDWITH COMMENTED_BY "Imported and Tributary ICS is not carried over from the previous year so the equation format is <br>just: [EOY ICS] =  [ICS created this year] - [ICS delivered this year]<br><br>EOY ICS becomes ECICS the following year.  <br><br>Imported and Tributary ICS Calculation    <br>"
  ENDWITH COMMENTED_BY "BiNational ICS Calculation  <br>"
 ENDWITH COMMENTED_BY "System Efficiency Calculation   <br>";

    END
    UUID "{76f7c0fe-0981-49aa-8181-fe2aa2636d54}";;

    FUNCTION       "ICSAccountingForIID" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation and delivery of the IID Extraordinary Conservation (EC) and Bi-National (BiNat) ICS to determine the annual balance of each category of ICS and the resulting total of IID ICS storage volume. The function returns a list of each of these values for the Rule to assign to the appropriate slots.  CH 5/10/18<br><br>RETURNS: List of lists of the form &lcub;&lcub;IID EC ICS, IID BiNat ICS, Total IID ICS&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: CH, 5/10/18";
    BEGIN

      WITH NUMERIC AnnualDeliveryBiNat = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "ICSProjectionData.AnnualDeliveryBiNat_IID_Default" [@"24:00:00 December 31, Current Year"]
 ENDIF DO
  WITH NUMERIC AnnualDeliveryEC = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" [@"24:00:00 December 31, Current Year"]
  ENDIF DO
   WITH NUMERIC AnnualCreationEC = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR "IsQuantifiedOrFloodControl"(  ) OR AnnualDeliveryEC > 0.00000000 "acre-ft" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    ( $ "ICS Credits.MeadBankParameters" ["IID", "Max Capacity"] - $ "ICS Credits.ExtraordinaryConservationICS_IID" [@"24:00:00 December 31, Previous Year"] * "EvapTaxAdjustment"(  ) ) / "SystemTaxAdjustment"(  )
   ENDIF DO
    WITH NUMERIC ECICSIID = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
    THEN
     $ "ICS Credits.ExtraordinaryConservationICS_IID" [@"24:00:00 December Max DayOfMonth, Previous Year"] + AnnualCreationEC * "SystemTaxAdjustment"(  )
    ELSE
     ( $ "ICS Credits.ExtraordinaryConservationICS_IID" [@"24:00:00 December Max DayOfMonth, Previous Year"] - AnnualDeliveryEC ) * "EvapTaxAdjustment"(  ) + AnnualCreationEC * "SystemTaxAdjustment"(  )
    ENDIF COMMENTED_BY "Current year's EC ICS balance - no delivery in shortage condition <br>" DO
     WITH NUMERIC BiNatICSIID = ( $ "ICS Credits.BiNationalICS_IID" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_IID" [@"24:00:00 December Max DayOfMonth, Current Year"] - AnnualDeliveryBiNat ) COMMENTED_BY "Current year's BiNat ICS balance <br>" DO
      WITH NUMERIC totalICSIID = ECICSIID + BiNatICSIID DO
       { AnnualDeliveryBiNat , AnnualDeliveryEC , AnnualCreationEC , ECICSIID , BiNatICSIID , totalICSIID }
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "IID has not signed onto DCP. Still operates under 2007 IG <br>";

    END
    UUID "{8a8100cf-a319-4039-8a3f-0b6fdeabd7ef}";;

    FUNCTION       "ICSDeliveryReduction_DCP" ( NUMERIC AnnualDelivery, STRING State, STRING Volume, NUMERIC ECtoDCP )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] < $ "DCP.IGMinTakeElevation" [] AND $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] >= $ "DCP.ReducedTakeElevation" [] )
 THEN
  "Min"( AnnualDelivery, $ "ICS Credits.MeadBankParameters" [State, Volume] )
 ELSE
  AnnualDelivery
 ENDIF
 ELSEIF_COND ( $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] < $ "DCP.ReducedTakeElevation" [] AND $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] >= $ "DCP.MinTakeElevation" [] )
 ELSEIF_CLAUSE ( "Min"( AnnualDelivery, $ "ICS Credits.MeadBankParameters" [State, Volume] - ECtoDCP ) )
 END_ELSEIF
 ELSEIF_COND ( $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] < $ "DCP.MinTakeElevation" [] )
 ELSEIF_CLAUSE ( 0.00000000 "acre-ft" )
 END_ELSEIF COMMENTED_BY "Section IV.D.1-3 of the LB OPs section of the DCP limits the amount of ICS that can be delivered to each state <br>based on Mead's elevation and the max annual delivery allowed for each state.<br>";

    END
    UUID "{10b946b7-c450-49b2-a03b-8c9e1969ab58}";;

    FUNCTION       "SumAnnualCAPDivRequest" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total annual CAP diversion requested for the current calendar year<br><br>RETURNS: Total annual diversion volume requested [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  "FlowToVolume"( $ "CAPDiversion.Total Diversion Requested" [date], date )
 ENDFOR;

    END
    UUID "{f554f75a-9bf0-4233-ba05-a2dc987c6c5d}";;

    FUNCTION       "SumAnnualSNWADivRequest" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Sums the annual diversion request for SNWP Pumping from Lake Mead TP 7/27/2015<br><br>RETURNS: Diversion requested volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/27/2015";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  "FlowToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date], date )
 ENDFOR;

    END
    UUID "{8a3b7f0e-1fe4-4bd2-917a-e096d488e98f}";;

    FUNCTION       "SumAnnualMWDDivRequest" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total volume of the MWDDiversion:MWD.Diversion Requested slot for the current model year<br><br>RETURNS: Diversion volume requested for current year<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  ( "FlowToVolume"( $ "MWDDiversion:MWD.Diversion Requested" [date], date ) - $ "California_CU_Schedules.MWDReturns" [date] )
 ENDFOR;

    END
    UUID "{346c57d6-0f42-4c6f-a0e4-8c8c102b9029}";;

    FUNCTION       "SystemTaxAdjustment" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Used to calculate the &quot;tax&quot; charged to ICS water<br><br>RETURNS: Coefficient to multiply ICS volume by to assess tax [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 20171204<br><br>MC, 20171204: Copied from Aug2017 CRSS model during modifications to switch CA ICS creation and delivery from Powell inflow basis to Sacramento Water Year basis";
    BEGIN

      1.00000000 - $ "ICS Credits.SystemTaxPercent" [];

    END
    UUID "{38272efc-f8cb-4edd-ab61-31919244d66c}";;

    FUNCTION       "SystemTaxAdjustment_DCP" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Used to calculate the &quot;tax&quot; charged to ICS water<br><br>RETURNS: Coefficient to multiply ICS volume by to assess tax [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 20171204<br><br>MC, 20171204: Copied from Aug2017 CRSS model during modifications to switch CA ICS creation and delivery from Powell inflow basis to Sacramento Water Year basis";
    BEGIN

      1.00000000 - $ "ICS Credits.SystemTaxPercent_DCP" [];

    END
    UUID "{7365bf1d-7ddb-4f36-ad1d-4e37235a7996}";;

    FUNCTION       "EvapTaxAdjustment" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Used to calculate the &quot;evap tax&quot; charged to ICS water<br><br>RETURNS: Coefficient to multiply ICS volume by to assess tax [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: AP 20181130<br><br>Created to get rid of hardcoded evap tax percent in ruleset. Similar to SystemTaxAdjustment Function";
    BEGIN

      1.00000000 - $ "ICS Credits.EvapTaxPercent" [];

    END
    UUID "{e8ee2616-dae9-48dd-bb6d-11a94fb7a144}";;

    FUNCTION       "MWD_ICSDeliveryCharged" ( NUMERIC totalDeliveryOfMWDICS, NUMERIC creationOfMWDECICS )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "S.Baker, 20200310: Added function IsMeadBelowDCPRecoveryElevation() to replace frequently used boolean. ";
    BEGIN

      WITH NUMERIC AnnualDelivery = totalDeliveryOfMWDICS DO
  WITH LIST DeliveryChargedList = FOR ( NUMERIC CategoryBalance IN { $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December 31, Previous Year"] , "Min"( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December 31, Previous Year"] - NaNToZero ( $ "ICS Credits.AnnualConversionECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) + "Current Year ECICS into Bank"( creationOfMWDECICS + $ "ICS Credits.AnnualSysWaterforDCP_Coachella" [@"24:00:00 December 31, Current Year"], $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December 31, Previous Year"], "California" ), $ "ICS Credits.MeadBankParameters" ["California", "Max Delivery"] ) , $ "ICS Credits.SystemEfficiencyICS_MWD" [@"24:00:00 December 31, Previous Year"] , $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December 31, Previous Year"] } ) WITH LIST result = {  } DO
   WITH NUMERIC RemainingBalance = IF ( ( LENGTH result ) == 0.00000000 )
   THEN
    AnnualDelivery
   ELSE
    AnnualDelivery - "Sum"( result )
   ENDIF DO
    WITH NUMERIC DeliveryAmount = IF ( ( LENGTH result ) == 0.00000000 AND "IsMeadBelowDCPRecoveryElevation"( @"24:00:00 December Max DayOfMonth, Previous Year" ) )
    THEN
     0.00000000 "acre-ft"
    ELSE
     "Min"( RemainingBalance, CategoryBalance )
    ENDIF DO
     APPEND DeliveryAmount ONTO result
    ENDWITH
   ENDWITH
  ENDFOR DO
   { GET @INDEX 0.00000000 FROM DeliveryChargedList , GET @INDEX 1.00000000 FROM DeliveryChargedList , GET @INDEX 2.00000000 FROM DeliveryChargedList , GET @INDEX 3.00000000 FROM DeliveryChargedList } COMMENTED_BY "0 = DCP, 1 = EC, 2 = SysEff, 3 = BiNat<br>"
  ENDWITH
 ENDWITH;

    END
    UUID "{3755aaf4-0c63-41bf-8b7a-1ada5368c65b}";;

    FUNCTION       "MWD_ICS_Balances" ( NUMERIC creationOfMWDECICS, NUMERIC deliveryChargedToEC, NUMERIC creationMWDSE, NUMERIC deliveryChargedToSE, NUMERIC creationMWDBiNat, NUMERIC deliveryChargedToBiNat, NUMERIC creationMWDDCPICS, NUMERIC deliveryChargedToDCPICS )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC DCPICSMWD = $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationMWDDCPICS - deliveryChargedToDCPICS DO
  WITH NUMERIC ECICSMWD = ( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year ECICS into Bank"( creationOfMWDECICS, $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"], "California" ) - deliveryChargedToEC ) COMMENTED_BY "Resulting ExtraOrdinaryConservation ICS " DO
   WITH NUMERIC SEICSMWD = ( $ "ICS Credits.SystemEfficiencyICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationMWDSE - deliveryChargedToSE ) COMMENTED_BY "Resulting System Efficiency ICS " DO
    WITH NUMERIC BiNatICSMWD = ( $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationMWDBiNat - deliveryChargedToBiNat ) COMMENTED_BY "Resulting Bi National ICS " DO
     WITH NUMERIC totalICSMWD = ( DCPICSMWD + ECICSMWD + SEICSMWD + BiNatICSMWD ) COMMENTED_BY "Total ICS" DO
      { ECICSMWD , SEICSMWD , BiNatICSMWD , totalICSMWD , DCPICSMWD }
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{7c3ee56a-3c8c-43d2-8f3f-01a1e85f16ab}";;

    FUNCTION       "AZ Firming Agreement" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC FirmingDeliveryAZ = "Min"( $ "ICS Credits.FirmingAgreementDelivery_AZ" [], $ "ICS Credits.FirmingAgreementBalance_AZ" [@"24:00:00 December 31, Previous Year"] ) DO
  WITH NUMERIC FirmingDeliveryUS = "Min"( $ "ICS Credits.FirmingAgreementDelivery_US" [], $ "ICS Credits.FirmingAgreementBalance_US" [@"24:00:00 December 31, Previous Year"] ) DO
   WITH NUMERIC TotalFirmingDelivery = FirmingDeliveryAZ + FirmingDeliveryUS DO
    IF ( "GetYear"( @"t" ) >= 2026.00000000 )
    THEN
     IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) <= $ "DCP.AZFirmingAgreementElevation" [] )
     THEN
      { TotalFirmingDelivery , FirmingDeliveryAZ , FirmingDeliveryUS }
     ELSE
      { 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" }
     ENDIF
    ELSE
     { 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" }
    ENDIF
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Function calculates AZ and US firming obligations starting in year 2026. Solves for the yearly <br>obligation <br>";

    END
    UUID "{479cfcd2-8edb-46b2-a0fc-51c02a170b6d}";;

    FUNCTION       "CAWCD Post 2026 ICS Delivery" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "GetYear"( @"t" ) >= 2026.00000000 )
 THEN
  IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) > $ "DCP.MinTakeElevation" [] )
  THEN
   $ "ICS Credits.TotalICS_CAWCD" [@"24:00:00 December 31, Previous Year"] / ( 2036.00000000 - "GetYear"( @"t" ) )
  ELSE
   0.00000000 "acre-ft"
  ENDIF
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

    END
    UUID "{7127bed7-0e2a-4fe7-9eeb-889a754cbf33}";;

    FUNCTION       "FitDefaultECICSIntoBank" ( NUMERIC DefaultECCreation, NUMERIC PreviousYearECDelivery, STRING State, NUMERIC PreviousYearBankBalance, NUMERIC OtherUserECCreationCurrentYear )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Min"( DefaultECCreation - PreviousYearECDelivery, ( $ "ICS Credits.MeadBankParameters" [State, "Max Capacity"] - PreviousYearBankBalance - PreviousYearECDelivery - OtherUserECCreationCurrentYear ) / IF ( DefaultECCreation > PreviousYearECDelivery )
 THEN
  "SystemTaxAdjustment_DCP"(  )
 ELSE
  1.00000000
 ENDIF ) + PreviousYearECDelivery;

    END
    UUID "{1a3e4610-8be5-49ab-be80-e550c1dce302}";;

    FUNCTION       "IsMeadBelowDCPRecoveryElevation" ( DATETIME date )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Check if Mead projected pool elevation is below the DCP Recovery Elevation.<br><br>RETURNS: Boolean<br><br>ARGUMENTS:<br>1. NUMERIC date - date to check Mead pool elevation";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author: S.Baker 20200310";
    BEGIN

      "GetProjectedPoolElevation"( "Mead", date ) <= $ "DCP.RecoveryElevation" [];

    END
    UUID "{5e3eebab-0e9e-473e-abe9-528fe3a1372a}";;

    FUNCTION       "IsMeadAboveDCPRecoveryElevation" ( DATETIME date )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Check if Mead projected pool elevation is above the DCP Recovery Elevation.<br><br>RETURNS: Boolean<br><br>ARGUMENTS:<br>1. NUMERIC date - date to check Mead pool elevation";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author: S.Baker 20200310";
    BEGIN

      "GetProjectedPoolElevation"( "Mead", date ) > $ "DCP.RecoveryElevation" [];

    END
    UUID "{4f9d5209-c72a-40f3-bb66-53276980799c}";;

      BREAKPOINT BEFORE_EXEC TRUE;
    BREAKPOINT AFTER_EXEC TRUE;
    FUNCTION       "Conversion of Excess DCP ICS to ICS Provision" ( STRING user )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "IsStartYear"(  ) )
 THEN
  WITH SLOT slot = IF ( user == "MX" )
  THEN
   $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings_AnnualContribution"
  ELSE
   % "ICS Credits" & "AnnualDCPContribution_" CONCAT user
  ENDIF DO
   WITH NUMERIC MandatedNonDCPcontribution = "Max"( slot [@"24:00:00 December Max DayOfMonth, Current Year"] - "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, "GetColumnIndex"( $ "DCP.Contributions", user ), $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"], @"t", FALSE ), 0.00000000 "acre-ft" ) DO
    WITH NUMERIC DCPContribution = IF ( "GetRowIndex"( $ "DCP.Contributions", STRINGIFY "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, 0.00000000, $ "PowellToMeadData.AugEOYMeadPEProjection" [@"24:00:00 December Max DayOfMonth, Previous Year"], @"t", FALSE ) ) >= "GetRowIndex"( $ "DCP.Contributions", STRINGIFY "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, 0.00000000, $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"], @"t", FALSE ) ) )
    THEN
     "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, "GetColumnIndex"( $ "DCP.Contributions", user ), $ "PowellToMeadData.AugEOYMeadPEProjection" [@"24:00:00 December Max DayOfMonth, Previous Year"], @"t", FALSE )
    ELSE
     "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, "GetColumnIndex"( $ "DCP.Contributions", user ), $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"], @"t", FALSE )
    ENDIF DO
     { MandatedNonDCPcontribution , DCPContribution }
    ENDWITH
   ENDWITH
  ENDWITH
 ELSE
  { 0.00000000 "acre-ft" , IF ( user == "MX" )
  THEN
   $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings_AnnualContribution" [@"24:00:00 December 31, Current Year"]
  ELSE
   "ICS Credits.AnnualDCPContribution_" CONCAT user [@"24:00:00 December Max DayOfMonth, Current Year"]
  ENDIF }
 ENDIF;

    END
    UUID "{6d9dd8e0-a9dd-47f7-834e-8ca822e7ea3a}";;

  END
  UUID "{dfbd709e-fde0-42ae-a9cd-6ba134319bf4}";;

  UTILITY_GROUP "Surplus Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "SumPreviousYearICScredits" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: Calculates the Lower Basin states' total cumulative ICS credits for the previous calendar year. Created as part of the Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR,DATE: HMG, 8/2/2011";
    BEGIN

      $ "ICS Credits.TotalICS_AZ" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TotalICS_CA" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TotalICS_NV" [@"24:00:00 December 31, Previous Year"];

    END
    UUID "{f4d7b9f5-1d8f-4b27-9774-a2ad68972808}";;

    FUNCTION       "Normal_LBDemands - Include Mexico" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates Lower Basin water use under Normal Conditions by summing diversion requests, including for Mexico. Created as part of the Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Maximum value of 7.5 MAF<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011<br>MC, 20170522: &quot;Annual Volume&quot; is just a call to SumFlowsToVolume; replace with those calls?";
    BEGIN

      "Min"( 7500000.00000000 "acre-ft" + "Annual Volume"( $ "MexicanTreatyDelivery.Total Diversion Requested" ), "Annual Volume"( $ "PumpingFromLakeMead.Total Diversion Requested" ) + "Annual Volume"( $ "OthersMeadToMohave.Total Diversion Requested" ) + "Annual Volume"( $ "NvDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "CaDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "AzDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "FtMohaveIndRes.Total Diversion Requested" ) + "Annual Volume"( $ "MWDDiversion.Total Diversion Requested" ) + "Annual Volume"( $ "CAPDiversion.Total Diversion Requested" ) + "Annual Volume"( $ "PaloVerde.Total Diversion Requested" ) + "Annual Volume"( $ "CRIR.Total Diversion Requested" ) + "Annual Volume"( $ "CaPkrToImp.Total Diversion Requested" ) + "Annual Volume"( $ "AzPkrToImp.Total Diversion Requested" ) + "Annual Volume"( $ "AAC.Total Diversion Requested" ) + "Annual Volume"( $ "GilaGravityMainCanal.Total Diversion Requested" ) + "Annual Volume"( $ "GilaAndYumaUsers.Total Diversion Requested" ) + "Annual Volume"( $ "MexicanTreatyDelivery.Total Diversion Requested" ) + "Annual Volume"( $ "OthersBlwImp.Total Diversion Requested" ) );

    END
    UUID "{16392f4f-81b0-4e91-93d1-3fafa3504942}";;

    FUNCTION       "QuantifiedSurplusVolume" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the non-negative volume of Quantified Surplus for the current calendar year<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Minimum of 0 acre-feet<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>CH, 4/24/18: Replaced Surplus.MaxStorage (a hardcoded value) with MaxStorage function that calculates this value as specified by Appendix A of CRSS documentation.<br>S.Baker 09/25/2018: Replace storage with ElevationToStorage() with function that determines which projected pool elevation to use (24MS or MTOM). <br>GCAA, 20181030: Replaced reference from ICMA balance to Mexico Water Reserve balance";
    BEGIN

      "Max"( ( "ElevationToStorage"( % "Powell", "GetProjectedPoolElevation"( "Powell", @"24:00:00 December 31, Previous Year" ) ) + "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) ) - "MaxStorage"(  ) - ( "SumPreviousYearICScredits"(  ) + $ "Mexico Shortage and Surplus.Mexico Water Reserve Balance" [@"24:00:00 December 31, Previous Year"] ) ) * ( 1.00000000 + ( $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] + $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) / 2.00000000 ) + $ "Surplus.70RLeesFerryFlow" [] COMMENTED_BY "70th percentile non-exceedance <br>flow" - ( $ "Surplus.UBEvaporation" [] + $ "Surplus.UBDemand" [@"24:00:00 December 31, Current Year"] ) - "SumLBDemands - Include Mexico"(  ), 0.00000000 "acre-ft" );

    END
    UUID "{93faffd9-c4e9-4216-be00-a076a261991f}";;

    FUNCTION       "SumLBDemands - Include Mexico" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: Calculates the Lower Basin demands as defined in the Interim Guidelines ROD. Created as part of the Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011";
    BEGIN

      "Normal_LBDemands - Include Mexico"(  ) + ( $ "Surplus.Average Annual Evaporation" [0.00000000, "Mead"] + $ "Surplus.Average Annual Evaporation" [0.00000000, "Mohave"] + $ "Surplus.Average Annual Evaporation" [0.00000000, "Havasu"] ) - ( "SumAllGainsBelowVolume"( % "Powell", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + "SumAllGainsBelowVolume"( % "Mead", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + "SumAllGainsBelowVolume"( % "Havasu", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) );

    END
    UUID "{c045c37d-e051-4186-b24f-6fd7dd6a15fb}";;

    FUNCTION       "Set Monthly Surplus Schedule" ( DATETIME date, STRING user )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the monthly surplus volume from the annual volume. This function was created as part of the Domestic and Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Monthly surplus volume [L^3]<br><br>ARGUMENTS<br>1. DATETIME date - date to calculate monthly surplus volume<br>2. STRING user - specifies user for which to calculate surplus volume<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR,DATE: HMG, 8/2/2011<br>MC, 20170512: Use of Monthly shortage percents is correct? If so, surplus monthly percentages are taken with the same distribution as shortage";
    BEGIN

      IF ( user == "CAP" )
 THEN
  % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"]
 ELSE
  IF ( user == "SNWA" )
  THEN
   ( % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] + $ "ICS Credits.AnnualNevadaStoredOffstream" [@"24:00:00 December Max DayOfMonth, Current Year"] ) * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"]
  ELSE
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"]
  ENDIF
 ENDIF;

    END
    UUID "{80686dfb-d6eb-4a10-86e6-4c3697172259}";;

    FUNCTION       "Set Monthly Surplus Schedule- FC" ( DATETIME date, STRING user )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the monthly Flood Control Surplus volume from the annual volume. This function varies from the &quot;Set Monthly Surplus Schedule&quot; function in that it can be applied to any starting month instead of being limited to January. This is because a Flood Surplus can be declared at any point within the year. Once a Flood Control Surplus is declared it will continue through to the end of the current calendar year.  <br><br>RETURNS: Monthly volume [L^3]<br><br>ARGUMENTS: <br>1. DATETIME date - date used to calculate the monthly volume<br>2. STRING user - user for whom monthly volume is calculated<br><br>CONSTRAINTS: <NONE><br><br>DEVELOPMENT NOTES<br>AUTHOR,DATE: Unknown";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( user == "CAP" )
 THEN
  % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"]
 ELSE
  IF ( user == "SNWA" )
  THEN
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"]
  ELSE
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"]
  ENDIF
 ENDIF;

    END
    UUID "{3efc5a9e-84df-447a-aead-d30b62a5f0b7}";;

    FUNCTION       "MaxStorage" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the maximum storage defined as the maximum combined storage of Lakes Powell and Mead that will meet the system space requirement at the beginning of the year, assuming 30% of that requirement will be met by the reservoirs upstream of Lake Powell<br><br>RETURNS: Monthly volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CH, 4/24/18: Created to replace a scalar slot value (Surplus.MaxStorage = 47.96) to make this value dynamic. ";
    BEGIN

      "GetLiveCapacity"( % "Mead" ) + "GetLiveCapacity"( % "Powell" ) - 0.70000000 * $ "MeadFloodControlData.Space" [0.00000000, "GetMonthAsString"( @"24:00:00 December Max DayOfMonth, Current Year" )];

    END
    UUID "{38ca20d5-8305-4ce0-8c01-5d2a34174e0e}";;

    FUNCTION       "ShareofMexicoSurplusbyState" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br><br>GCAA, 20181030: Function added per Minute 323";
    BEGIN

      1.00000000 / 3.00000000;

    END
    UUID "{376ec321-31fe-4b2b-888f-60b2114f0251}";;

    FUNCTION       "SurplusUsers_AllTypes" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      { $ "Surplus Total Annual Schedules.MWD" , $ "Surplus Total Annual Schedules.Gila Monster Farms" , $ "Surplus Total Annual Schedules.AzPumpersBlwImp" , $ "Surplus Total Annual Schedules.CAP" , $ "Surplus Total Annual Schedules.SNWA" };

    END
    UUID "{a326f41b-f26c-4037-a906-ee50fa6e4730}";;

    FUNCTION       "SurplusUsers_QSandFC" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      { $ "Surplus Total Annual Schedules.Coachella" , $ "Surplus Total Annual Schedules.IID" , $ "Surplus Total Annual Schedules.City of Parker" , $ "Surplus Total Annual Schedules.CibolaValleyIID" };

    END
    UUID "{f8598064-2a0b-4208-bd90-9c7b41165a41}";;

    FUNCTION       "SurplusUsers_FConly" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      { $ "Surplus Total Annual Schedules.Needles" , $ "Surplus Total Annual Schedules.CaPumpersAbvImp" , $ "Surplus Total Annual Schedules.Mexico" };

    END
    UUID "{4dba9657-bed2-409e-88f4-f097cc336430}";;

  END
  UUID "{aeb7d9d8-30db-4fa7-bc06-816a1da96e7d}";;

  UTILITY_GROUP "Shortage Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetShortageElevationString" ( NUMERIC indextier )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns, as a string, the lower limit of the Mead pool elevation value for the shortage tier specified in the input argument<br><br>RETURNS: Pool elevation value as a string [NONE] <br><br>ARGUMENTS: <br>1. NUMERIC indextier - numeric indicator of Lower Basin shortage level<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( indextier == 0.00000000 )
 THEN
  "1075"
 ELSE
  IF ( indextier == 1.00000000 )
  THEN
   "1050"
  ELSE
   "1025"
  ENDIF
 ENDIF;

    END
    UUID "{e793d762-a33a-4f07-a61b-4fea6130f5f9}";;

    FUNCTION       "Arizona Shortage Depletion" ( STRING user, NUMERIC indextier, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function calculates the specified AZ user's depletion allowed under a Shortage condition<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <br>1. STRING user - specifies the user for which the shortage depletion is desired<br>2. NUMERIC indextier - specifies the index of the shortage tier<br>3. DATETIME date - specifies the date for which the depletion is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR,DATE: Unknown";
    BEGIN

      WITH STRING short_elev = "GetShortageElevationString"( indextier ) DO
  "VolumeToFlow"( % "Arizona_CU_Schedules" & user [date] - "GetObject"( ( "Arizona_Shortage" CONCAT short_elev ) CONCAT "_Schedules" ) & user ["Dec31ofYear"( date )] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"], date )
 ENDWITH;

    END
    UUID "{59061bef-9dff-4573-84da-9dcb7c4dbd36}";;

    FUNCTION       "CAP Shortage Depletion" ( NUMERIC indextier, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculate the monthly forecast CAP diversion under Shortage condition<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. NUMERIC indextier - Shortage tier<br>2. DATETIME date - date for which to calculate the monthly volume<br><br>CONSTRAINTS: Minimum of 0.00 acre-feet/month<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "Max"( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"] - "GetAnnualCAPShortage"( indextier ) * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"], date ), 0.00000000 "acre-ft/month" );

    END
    UUID "{f31d3de0-8f70-417f-b161-deadf0f6427b}";;

    FUNCTION       "GetAnnualCAPShortage" ( NUMERIC indextier )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: The annual CAP shortage amount is the Arizona shortage amount minus the sum of the non-CAP shortage amounts<br><br>RETURNS: Shortage volume for CAP [L^3]<br><br>ARGUMENTS: <br>1. NUMERIC indextier - the index for a Lower Basin shortage tier<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown ";
    BEGIN

      WITH STRING short_elev = "GetShortageElevationString"( indextier ) DO
  $ "Shortage.State Shortage Volumes" [indextier, "Arizona"] - "SumSlotListDates"( "GetObject"( ( "Arizona_Shortage" CONCAT short_elev ) CONCAT "_Schedules" ), @"24:00:00 December 31, Current Year" )
 ENDWITH;

    END
    UUID "{5db09af8-19f2-48ba-a5a9-62fbca86f648}";;

  END
  UUID "{5674b93c-45b0-44c7-bfa4-0a2b069675db}";;

  UTILITY_GROUP "Flood Control Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AvailableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the available storage in a reservoir as the difference between the live capacity of the reservoir and the storage value at the end of the previous timestep<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the available space is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: The upstream UC reservoirs use this same calculation in the rule Set Forecast Data, but do not call the function";
    BEGIN

      "GetLiveCapacity"( reservoir ) - reservoir & "Storage" [@"t - 1"];

    END
    UUID "{8392acfd-323b-4cc2-8d6d-ad5f1b91ee3e}";;

    FUNCTION       "ComputeMinimumSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the space available in &quot;reservoir&quot; given the minimum required space<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the space is desired (see Development Notes)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170518: As of now, the only reservoir with data in the MeadFloodControlData.MinSpace slot (which is referenced by the GetMinimumSpace function) is Mead, so the only successful call to this function will be with reservoir as &quot;Mead&quot;";
    BEGIN

      "GetLiveCapacity"( reservoir ) - "GetMininumSpace"( reservoir );

    END
    UUID "{eacdb4a8-8555-4340-a092-7b88c7394d98}";;

    FUNCTION       "ComputeTargetStorageRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "DESCRIPTION: This function calculates the outflow required to reach the target elevation specified by the SpaceBuilding function with an upper bound of the maximum space building release (28,000 cfs).<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: 0 acre-feet/month (minimum), MeadFloodControlData.MaxRelease (maximum)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170518: The function ComputeOutflowAtGivenStorageForSpaceBuilding uses the SolveOutflow function, which includes both Release and Spill; however, the first condition restricts the outflow to the maximum release value; also, the ComputeOutflowAtGivenStorageForSpaceBuilding function does not constrain releases to a MinRelease and MaxRelease like ComputeOutflowAtGivenStorage does<br>MC, 20170518: Instead of using the IF conditional, could add Post-Exec Checks that limit outflow to [0 acre-feet/month, MaxRelease]; or, should the 0 acre-feet actually be a MinRelease value (UBRuleCurveData.ReservoirData slot has a min release value of 3,000 cfs for Mead)";
    BEGIN

      IF ( ( "ComputeOutflowAtGivenStorageForSpaceBuilding"( % "Mead", "SpaceBuilding"(  ) ) > $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000] ) COMMENTED_BY "Outflow to reach target > Max flood control release, use Max flood control release" )
 THEN
  $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000]
 ELSE
  "Max"( "ComputeOutflowAtGivenStorageForSpaceBuilding"( % "Mead", "SpaceBuilding"(  ) ), 0.00000000 "acre-feet/month" ) COMMENTED_BY "Use non-negative release to reach target"
 ENDIF;

    END
    UUID "{4c43ee10-592a-4ce6-ba52-32458ac876a9}";;

    FUNCTION       "ComputeTargetStorage" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates a target storage volume for Mead based on either the volume calculated by the SpaceBuilding function, or the volume achievable by the MaxRelease outflow<br><br>RETURNS: Storage Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "ComputeOutflowAtGivenStorage"( % "Mead", "SpaceBuilding"(  ) ) > $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000] )
 THEN
  "ComputeStorageWithGivenOutflow"( % "Mead", $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000] )
 ELSE
  "SpaceBuilding"(  )
 ENDIF COMMENTED_BY "If the outflow to reach the SpaceBuilding storage target exceeds the MaxRelease outflow, <br>calculate the storage achieved at the MaxRelease; otherwise use the SpaceBuilding storage";

    END
    UUID "{b7650f1a-0b1f-4962-ace8-302fcdff2ce1}";;

    FUNCTION       "CurrentAvailableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the storage space available at the current timestep for the specified reservoir<br><br>RETURNS: Available volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the available space is desired<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "GetLiveCapacity"( reservoir ) - reservoir & "Storage" [];

    END
    UUID "{d1dfab7a-fbac-40ec-97e4-dd5bf45e0edd}";;

    FUNCTION       "FloodControlEvap" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the evaporation incurred during flood control operations using a storage value halfway between the storage at the previous timestep and the live capacity of the reservoir<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the evaporation is calculated<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "StorageToArea"( reservoir, "GetLiveCapacity"( reservoir ) - "AvailableSpace"( reservoir ) / 2.00000000 ) * "SumEvapCoeff"( reservoir );

    END
    UUID "{b41e7153-5833-416c-b40d-d8e767e7af98}";;

    FUNCTION       "DeltaBankStorage" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the total change in bank storage of Mead and Powell that occurs by using the space available in each<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] * ( "AvailableSpace"( % "Mead" ) - $ "MeadFloodControlData.MinSpace" [0.00000000, 0.00000000] ) + $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] * "AvailableSpace"( % "Powell" );

    END
    UUID "{76445aa9-2a10-4245-a431-4f3e7ad1819d}";;

    FUNCTION       "ForecastMeadInflow" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function computes the inflow forecast through July for Mead for use in the flood control release determination.<br><br>RETURNS: Forecast inflow volume to Mead [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumSlotVolume"( $ "PowellInflow.Unregulated", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) + "SumAllGainsBelowVolume"( % "Powell", @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) + $ "MeadFloodControlData.Forcmax" ["Forcmax", "GetMonthAsString"( @"t" )] - $ "FloodControlOutput.UBEffective" [];

    END
    UUID "{d6f1568e-8fe1-4743-8858-c3c7d8038340}";;

    FUNCTION       "SouthernNevConsumed" ( LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the total diversion volume requested by SNWP over the date range passed as an argument<br><br>RETURNS: Diversion volume requested [L^3]<br><br>ARGUMENTS:<br>1. LIST dates - a list of dates over which the diversion is summed<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: This function is unnecessary since its functionality can be replaced by using the predefined function SumFlowsToVolume";
    BEGIN

      "SumSlotVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", dates );

    END
    UUID "{33e33e65-22d3-4c7c-a532-348da4c0b5ed}";;

    FUNCTION       "ForecastRunoffSeason " (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the release level required to pass excess inflow from Mead. This level corresponds to the flood control release steps in Table 1 in Exhibit A of the Flood Control Manual and is used in determining Mead flood control releases January 1 - July 31.<br><br>RETURNS: List of lists of the form &lcub;&lcub;Flow, Release level index&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Non-negative minimum release flow<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170906: Changed ?<=? to ?<? in the Boolean ?(results<1>) < 5.00000? in the WHILE conditional statement";
    BEGIN

      WHILE ( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) ), @"t" ) COMMENTED_BY "Remaining excess volume at current release level as flow rate" > $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] COMMENTED_BY "Currently considered release level" AND ( GET @INDEX 1.00000000 FROM results ) < 5.00000000 ) WITH LIST results = { "Max"( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( 0.00000000 ), @"t" ) COMMENTED_BY "Volume at lowest release level", 0.00000000 "acre-feet/month" ) , 0.00000000 } DO
  IF ( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ), @"t" ) COMMENTED_BY "Remaining excess volume at next higher release level as flow rate" <= $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] COMMENTED_BY "Currently considered release level" )
  THEN
   INSERT $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] INTO INSERT ( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ) * "DebuggerStop"(  ) INTO results
  ELSE
   INSERT "Max"( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ), @"t" ), 0.00000000 "acre-feet/month" ) INTO INSERT ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 INTO results
  ENDIF
 ENDWHILE;

    END
    UUID "{a73142e2-f397-47a5-8ff3-78d860d5ea98}";;

    FUNCTION       "ComputeMinMeadFloodRelease" ( NUMERIC index )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the difference between the Mead inflow volume in excess of the available space in Mead and Powell and the volume released between the next timestep and the end of July of the current year at the release level specified by the input argument &quot;index&quot;<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. NUMERIC index - index that specifies a release level for Mead<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "FloodControlOutput.Withoutrel" [] - "FloodControlLevelVolume"( "GetMonthlyDatelist"( @"t + 1", @"24:00:00 July Max DayOfMonth, Current Year" ), index );

    END
    UUID "{e99d3911-925a-43a6-aafb-83e981897363}";;

    FUNCTION       "FloodControlLevelVolume" ( LIST dateList, NUMERIC index )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the volume released from Mead at the release level specified by the input argument &quot;index&quot;<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. LIST dateList - list of dates over which the release volume should be calculated<br>2. NUMERIC index - index specifying a release level<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN dateList ) WITH NUMERIC result = 0.00000000 "acre-feet" DO
  result + "FlowToVolume"( $ "MeadFloodControlData.Levels" [0.00000000, index], date )
 ENDFOR;

    END
    UUID "{64924c39-a663-49a4-b33e-7048741ccb38}";;

    FUNCTION       "ComputeDeltaTargetStorage" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function computes the difference between the previous timestep's storage and the target storage at the current timestep for the Lower Basin reservoir specified as an input argument<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - LB reservoir for which storage difference is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "GetTargetStorage"( reservoir, @"t" ) - reservoir & "Storage" [@"t - 1"];

    END
    UUID "{18d439a9-307f-4489-bc1f-314ecf69a6d1}";;

    FUNCTION       "UBCreditableSpace" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function sums the space available in upper basin reservoirs for flood control, up to the maximum creditable space, for Powell, Flaming Gorge (including Fontenelle), Navajo, and Blue Mesa. The maximum creditable space for each reservoir is specified in the Hoover Flood Control Manual for the space building months of August through December.<br><br>RETURNS: Available UB storage [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( OBJECT reservoir IN "ListSubbasin"( "UBFloodControlReservoirs" ) ) WITH NUMERIC sum = 0.00000000 "acre-feet" DO
  IF ( ( STRINGIFY reservoir ) == "FlamingGorge" )
  THEN
   sum + "Min"( "CurrentAvailableSpace"( % "FlamingGorge" ) + "CurrentAvailableSpace"( % "Fontenelle" ), "GetMaxCreditableSpace"( % "FlamingGorge" ) )
  ELSE
   sum + "Min"( "CurrentAvailableSpace"( reservoir ), "GetMaxCreditableSpace"( reservoir ) )
  ENDIF
 ENDFOR;

    END
    UUID "{2dcc52d2-d29c-48c2-a870-d845185aa9e8}";;

    FUNCTION       "SpaceBuilding" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function is used to determine if space building releases from Hoover are necessary. It compares the minimum required available flood control storage space at a given month (using the SystemSpace function and the MeadFloodControlData.Space table) to the available space in Mead plus the creditable space in upper basin reservoirs. If there is not sufficient flood control space available, it computes the target storage required to create the minimum flood control space in Mead, and returns that storage target.<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( ( "CurrentAvailableSpace"( % "Mead" ) + "UBCreditableSpace"(  ) > "SystemSpace"(  ) ) COMMENTED_BY "Current Mead space + UB space > Required space for current month" )
 THEN
  "ComputeMinimumSpace"( % "Mead" ) COMMENTED_BY "Calculate max space available in Mead"
 ELSE
  ( "GetLiveCapacity"( % "Mead" ) - "SystemSpace"(  ) + "UBCreditableSpace"(  ) ) COMMENTED_BY "Calculate max space available in Mead + UB"
 ENDIF;

    END
    UUID "{7b3a042a-3720-4427-86ba-449c8e2809fa}";;

    FUNCTION       "SumEvapCoeff" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the sum of all the evaporation coefficients for the specified reservoir until July. During the sum, the coefficient values are adjusted to deal with the unit conversion issue between the current month and the months for which the values were entered, and converted into 31 day months. <br><br>RETURNS: Evaporation depth [L]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir whose coefficients are to be summed<br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: Powell uses the Periodic Net evaporation method, and does not have a slot named &quot;Evaporation Coefficients&quot;.  For that reason, I'm doubtful this function has been called since that method has been in use, as it seems likely the function would fail.";
    BEGIN

      FOR ( DATETIME date IN "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) WITH NUMERIC result = 0.00000000 "ft" DO
  result + reservoir & "Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000] * 1.00000000 "month"
 ENDFOR;

    END
    UUID "{24a88c69-bb2a-44d1-9642-18cf4a9d0db3}";;

  END
  UUID "{5606f0cd-858b-449a-b01e-b44c7bcb931e}";;

  UTILITY_GROUP "Midterm Model General Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "CurrentYear" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the date that represents the current year for annual slots<br><br>RETURNS: Dec 31, Current Year [DATETIME]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      @"24:00:00 December Max DayOfMonth, Current Year";

    END
    UUID "{791b3125-6f27-4a19-95c5-d10417435538}";;

    FUNCTION       "DateToCheckEOWYElevation" ( DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the appropriate end of water year date on which to check the pool elevation<br><br>RETURNS: 24:00:00 September 30 of appropriate year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies which water year to check<br>2. BOOLEAN startYear - logical argument that specifies whether &quot;date&quot; is in the Start Year [TRUE] or an out year [FALSE]<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( date >= @"October 31" OR ( date == @"August 31" AND NOT startYear ) OR ( date == @"September 30" AND NOT startYear ) )
 THEN
  @"24:00:00 September 30, Next Year"
 ELSE
  @"24:00:00 September 30, Current Year"
 ENDIF;

    END
    UUID "{553411db-6b0b-451d-a658-af2bcce308c4}";;

    FUNCTION       "DateToCheckJan1Elevation" ( DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date of Dec 31 for the appropriate calendar year to represent a Jan 1 pool elevation (i.e., the Dec 31 pool elevation represents the Jan 1 pool elevation). The function assumes if &quot;date&quot; is October or later, or is August and not in the first year of the model run, that Jan 1 of the calendar year following the one containing &quot;date&quot; is desired; otherwise, Jan 1 of the current calendar year is desired. <br><br>RETURNS: Dec 31 of the year containing &quot;date&quot; [DATETIME]<br><br>ARGUMENTS: <br>1. DATETIME date - date for which the Jan 1 elevation should be checked<br>2. BOOLEAN startYear - Boolean variable designating if the year is the first year of the model run (TRUE) or not (FALSE)<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: I think the assumptions made in the function may be unnecessary and complicating. It might be easier to make adjustments in the &quot;date&quot; argument rather than sending in the additional Boolean argument; that is, if in August and want Jan 1 of next year, just pass @&quot;t+2&quot; instead of requiring the separate Boolean argument";
    BEGIN

      IF ( date >= @"October 31" OR ( date == @"August 31" AND NOT startYear ) )
 THEN
  "Dec31ofYear"( date )
 ELSE
  "Dec31ofYear"( date - 1.00000000 "year" )
 ENDIF;

    END
    UUID "{bd0d490c-8439-4cc8-9ffb-b577e30046ac}";;

    FUNCTION       "EnsureReleaseLimits" ( NUMERIC release, NUMERIC lowerLimit, NUMERIC upperLimit )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function ensures the release volume specified as an argument lies between the minimum and maximum values specifed as arguments<br><br>RETURNS: Release volume [L^3]<br><br>ARGUMENTS:<br>1. NUMERIC release - release volume to check<br>2. NUMERIC lowerLimit - minimum release volume<br>3. NUMERIC upperLimit - maximum release volume<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT lowerLimit;
    MAX_CONSTRAINT upperLimit;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      release;

    END
    UUID "{4664d315-d8eb-4da7-b54a-4f31e76989fc}";;

    FUNCTION       "EqLevel" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "DESCRIPTION: This function returns the value for the year containing &quot;date&quot; from the slot PowellData.EqualizationElevationTable (i.e., the Equalization pool elevation specified for the year)<br><br>RETURNS: Pool elevation [L]<br><br>ARGUMENTS: <br>1. DATETIME date - date that specifies the water year to check<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH STRING waterYear = IF ( date >= @"October 31" )
 THEN
  "GetYearAsString"( "OffsetDate"( date, 1.00000000, "1 years" ) )
 ELSE
  "GetYearAsString"( date )
 ENDIF DO
  $ "PowellData.EqualizationElevationTable" [waterYear, 0.00000000]
 ENDWITH;

    END
    UUID "{55df81ce-c902-4c9b-a1f4-ecda0f77b399}";;

    FUNCTION       "EstimateEvaporation" ( OBJECT reservoir, NUMERIC startStorage, NUMERIC endStorage, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns an estimate of the evaporation volume occurring on the specified reservoir between the specified dates and storages<br><br>RETURNS: Evaporation volume [L^3]<br><br>ARGUMENTS<br>1. OBJECT reservoir - reservoir for which evaporation volume is desired<br>2. NUMERIC startStorage - beginning storage volume<br>3. NUMERIC endStorage - ending storage volume<br>4. DATETIME startDate - date of beginning storage volume<br>5. DATETIME endDate - date of ending storage volume<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "FlowToVolume"( ( "StorageToArea"( reservoir, startStorage ) + "StorageToArea"( reservoir, endStorage ) ) / 2.00000000 * "SumEvapCoeffCRSS"( reservoir, "GetMonth"( startDate ) - 1.00000000, "GetMonth"( endDate ) - 1.00000000 ), endDate );

    END
    UUID "{e9e36ad9-f7b0-40eb-830f-b397db47e796}";;

    FUNCTION       "GetElement" ( LIST list, NUMERIC i )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the value (numeric) of the list item at index i<br><br>RETURNS: Numeric value [Variable]<br><br>ARGUMENTS:<br>1. LIST list - list of items<br>2. NUMERIC i - index value into list<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      GET @INDEX i FROM list;

    END
    UUID "{7afa3e2d-b200-4355-9f2d-6648421c1357}";;

    FUNCTION       "HasAnyRuleFired" ( LIST rules )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines if any rule in the input list &quot;rules&quot; has fired successfully<br><br>RETURNS: TRUE if any rule in the list has fired successfully; otherwise FALSE [BOOLEAN]<br><br>ARGUMENTS:<br>1. LIST rules - a list of rule names<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( STRING rule IN rules ) WITH BOOLEAN fired = FALSE DO
  IF ( "HasRuleFiredSuccessfully"( rule ) AND NOT fired )
  THEN
   TRUE
  ELSE
   fired
  ENDIF
 ENDFOR;

    END
    UUID "{e3c9b5c7-d8c3-4fb9-90b8-11cdec853030}";;

    FUNCTION       "Interpolate" ( NUMERIC x, NUMERIC x0, NUMERIC x1, NUMERIC y0, NUMERIC y1 )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function does a linear interpolation of values in a table<br><br>RETURNS: Interpolated value of y [Units of y]<br><br>ARGUMENTS<br>1. NUMERIC x - value of X variable whose corresponding value in Y column of table is desired<br>2. NUMERIC x0 - highest value in X column that is less than x<br>3. NUMERIC x1 - lowest value in X column that is greater than x<br>4. NUMERIC y0 - value in Y vector corresponding to x0 value in X column<br>5. NUMERIC y1 - value in Y vector corresponding to x1 value in X column<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE 6/12/13";
    BEGIN

      y0 + ( x - x0 ) / ( x1 - x0 ) * ( y1 - y0 );

    END
    UUID "{c20f1089-d128-47d6-b5b8-0c89f82a30f7}";;

    FUNCTION       "MeadPumpingDemandVariabilityFactor" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function checks the lower basin demand threshhold for the Local Inflows above Hoover and applies the changes to Mead pumping where necessary.  If the local inflows above Hoover Dam are greater than the 90% historic local inflow volume then the pumping is reduced by 5%.  In the case that the local inflows are less than the 10% exceedence historic local inflow volume then the pumping is increased by 5%. The function returns a factor which is applied to the monthly pumping requests and set by the rule that calls this function (Reset Monthly Forecast SNWP LC Demand Variability).  TP 3/12/2013<br><br>RETURNS: Number representing the current pumping rate relative to a normal year [NONE]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies the year for which the pumping factor is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 3/12/2013<br><br>S.Baker 20200331: Added MTOM run type to if statement.<br>S.Baker, 20200421: Added LBDV_OnOff slot instead of RunType check. We need the LBDV to be able to be used in hindcast mode. ";
    BEGIN

      IF ( "IsMRM"(  ) AND NOT "IsSurplusOrDCP"(  ) AND ( $ "MTOMRunType.LBDV_OnOff" [] == 1.00000000 ) COMMENTED_BY "In 24 MS, LBDV is off <br>" )
 THEN
  IF ( ( $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowAboveHoover90"] ) COMMENTED_BY "For high inflow year, pumping reduced" )
  THEN
   0.95000000
  ELSE
   IF ( ( $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowAboveHoover10"] ) COMMENTED_BY "For low inflow year, pumping increased" )
   THEN
    1.05000000
   ELSE
    1.00000000
   ENDIF
  ENDIF
 ELSE
  1.00000000
 ENDIF;

    END
    UUID "{213ce28c-0155-4f78-8bc6-b1de573582a4}";;

    FUNCTION       "AgUsersBelowParkerDemandVariabilityFactor" ( DATETIME date, STRING AgUser )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function checks the lower basin demand threshhold for the Local Inflows below Parker and applies the changes to Mead pumping where necessary.  The function takes a date and checks the conditions for the year of that date then returns a factor for increased or decreased pumping from Mead.<br><br>RETURNS: Demand variability factor [NONE]<br><br>ARGUMENTS:<br>1. DATETIME date - date that determines the year to check<br>2. STRING AgUser - user for who the factor is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 3/12/13<br><br>GCAA, 20200330: Added a separate coefficient for IID and CVWD.<br>S.Baker 20200331: Added MTOM run type to if statement.<br>S.Baker, 20200421: Added LBDV_OnOff slot instead of RunType check. We need the LBDV to be able to be used in hindcast mode. ";
    BEGIN

      IF ( "IsMRM"(  ) AND $ "MTOMRunType.LBDV_OnOff" [] == 1.00000000 )
 THEN
  IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker90"] )
  THEN
   IF ( AgUser == "IID" OR AgUser == "CVWD" )
   THEN
    0.95000000
   ELSE
    0.90000000
   ENDIF
  ELSE
   IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker10"] )
   THEN
    IF ( AgUser == "IID" OR AgUser == "CVWD" OR AgUser == "YMIDD" OR AgUser == "WMIDD" )
    THEN
     1.00000000
    ELSE
     1.05000000
    ENDIF
   ELSE
    1.00000000
   ENDIF
  ENDIF
 ELSE
  1.00000000
 ENDIF;

    END
    UUID "{eaf21901-76a3-4f73-804c-152a96ab974f}";;

    FUNCTION       "CAPDemandVariabilityFactor" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function checks the lower basin demand threshhold for the Local Inflows above Hoover and applies the changes to Mead pumping where necessary.  The function takes a date and checks the conditions for the year of that date then returns a factor for increased or decreased pumping from Mead. If local inflows to the system below Parker Dam are greater than the 90% exceedence of historic local inflows a factor of 90% is returned.  If the local inflows are below the 10% exceedence of the historic local inflows, then the diversion requested can be increased in the amount the is equal to the difference in the State Apportionment for the year and the volume of Senior Prority user diversion requests.  This value is added to any ICS delivery if Lake Mead is above 1,100 Ft.  The sum of the remaining state apportionment and the ICS Delivery is what CAP is allowed to divert.  A ratio of the new diversion amount to the old diversion amount is returned and applied to the diversion request slot in the rule calling this function (Reset Monthly Forecast CAP LC Demand Variability). TP 7/27/2015<br><br>RETURNS: Factor to apply to diversion requests [NONE]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies the year considered<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 3/12/2013<br><br>S.Baker 20200331: Added MTOM run type to if statement.<br>S.Baker, 20200421: Added LBDV_OnOff slot instead of RunType check. We need the LBDV to be able to be used in hindcast mode. ";
    BEGIN

      IF ( "IsMRM"(  ) AND NOT "IsSurplusOrDCP"(  ) AND $ "MTOMRunType.LBDV_OnOff" [] == 1.00000000 )
 THEN
  IF ( ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker90"] ) COMMENTED_BY "High local inflows" )
  THEN
   0.90000000
  ELSE
   IF ( ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker10"] ) COMMENTED_BY "Low local inflows" )
   THEN
    WITH NUMERIC volOfAZAgScheduled = FOR ( DATETIME dateSum IN "GetDates"( "OffsetDate"( "Dec31ofYear"( date ), - 11.00000000, "1 Months" ), "Dec31ofYear"( date ), "1 Months" ) ) STAT_SUM
     FOR ( OBJECT azNonCapWaterUser IN "ListSubbasin"( "ArizonaNonCAPWaterUsers" ) ) STAT_SUM
      "FlowToVolume"( azNonCapWaterUser & "Diversion Requested" [dateSum], dateSum )
     ENDFOR
    ENDFOR DO
     WITH NUMERIC diffVolAgDivAZ = $ "AnnualWaterUse.Arizona_Apportionment" ["Dec31ofYear"( date )] - volOfAZAgScheduled DO
      WITH NUMERIC volOfScheduledCAPDiv = "SumAnnualCAPDivRequest"(  ) DO
       WITH NUMERIC ratioFullAllocToAgDiv = ( diffVolAgDivAZ / volOfScheduledCAPDiv ) COMMENTED_BY "Add the difference in the volume available for CAP to divert to the ICS<br> diversion that is available if Lake Mead is above 1,100 Ft." DO
        ratioFullAllocToAgDiv
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "This needs to be changed to take into account All ofthe Ag Diversions for Arizona below Parker Dam so that the total <br>diversion does not exceede 2.8 MAF for the given year. All of the ag diversions are not included here. TP 3/12/2013<br>Added a new Sub Basin called ArizonaNonCAPWaterUsers and now this issue is resolved TP 1/28/2015"
   ELSE
    1.00000000
   ENDIF
  ENDIF
 ELSE
  1.00000000
 ENDIF;

    END
    UUID "{37045e06-5853-45e6-906d-20f1838e6831}";;

    FUNCTION       "MonthIs" ( LIST months )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns True if the current timestep is in the list months and False if it is not. - CE 6/11/13<br><br>RETURNS: Boolean [BOOLEAN]<br><br>ARGUMENTS: <br>1. LIST months - list of months as strings to check for current month<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "GetMonthAsString"( @"t" ) IN months;

    END
    UUID "{1edc6029-2b61-46d4-8335-b9931553680d}";;

    FUNCTION       "RelativeEOWYDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns the datetime at the end of the water year relative the the current timestep. e.g. if the month is June, the function would return @&quot;t+3&quot;<br><br>RETURNS: Date of the end of the water year containing the input argument &quot;date&quot; [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the end of water year is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20161201: Replace use of this function by WaterYearEndDate, which does not rely on the MonthsUntilEOWY user-defined function?";
    BEGIN

      "OffsetDate"( date, "MonthsUntilEOWY"( date ), "1 months" );

    END
    UUID "{ed47b064-324c-4625-9d8f-1d84c44179d7}";;

    FUNCTION       "RuleCurveStorage" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the storage volume target from the UBRuleCurveData.BaseRuleCurves slot for the reservoir and date passed as input<br><br>RETURNS: Storage volume target [L^3]<br><br>ARGUMENTS<br>1. OBJECT res - reservoir for which storage volume is desired<br>2. DATETIME date - timestep for which storage volume is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.BaseRuleCurves" [STRINGIFY res, "GetMonthAsString"( date )];

    END
    UUID "{e508d36d-b205-4515-8f63-52bec548a36c}";;

    FUNCTION       "StartMonthIsSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns TRUE if the timestep is the Start Timestep and the month is September, and returns FALSE otherwise<br><br>RETURNS: Boolean [BOOLEAN]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170511: Function name is somewhat misleading? I thought it meant the Start Timestep occurred in September, regardless of whether the current timestep was the Start Timestep";
    BEGIN

      @"t" == @"Start Timestep" AND "MonthIs"( { "September" } );

    END
    UUID "{41bde287-9ec3-4974-8011-5a3c44fc7ce4}";;

    FUNCTION       "SumEvapCoeffCRSS" ( OBJECT res, NUMERIC startRow, NUMERIC endRow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function sums the values in the Evaporation Coefficients slot of the reservoir specified as an argument for the row specified as arguments<br><br>RETURNS: total evaporation rate for the period determined by the rows specified [L/T]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir for which the total evaporation rate is desired<br>2. NUMERIC startRow - index representing the beginning month of the period desired in the Evaporation Coefficients slot<br>3. NUMERIC endRow - index representing the ending month of the period desired in the Evaporation Coefficients slot<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumTableColumn"( res & "Evaporation Coefficients", 0.00000000, startRow, endRow );

    END
    UUID "{6582072f-82a0-4ed3-9e5c-aac2bc183b19}";;

    FUNCTION       "GetWaterYearEndDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date of the end of the water year containing the date passed as an argument; if the month of the date is September or earlier, use Sep 30 of the same calendar year; otherwise, use Sep 30 of the following calendar year<br><br>RETURNS: 24:00:00 September 30 for the appropriate water year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - datetime for which the end of water year date is desired<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "GetMonth"( date ) <= 9.00000000 )
 THEN
  "CompletePartialDate"( @"24:00:00 September 30", date )
 ELSE
  "CompletePartialDate"( @"24:00:00 September 30", "NumberToYear"( "GetYear"( date ) + 1.00000000 ) )
 ENDIF;

    END
    UUID "{a0e9d994-9204-4e77-86ce-607342560529}";;

    FUNCTION       "GetWaterYearBeginDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date of the beginning of the water year containing the date passed as an argument. Note that the datetime returned represents October 31, not October 1, since the model uses a monthly timestep and timesteps are represented by their end, not beginning.<br><br>RETURNS: 24:00:00 October 31 for the appropriate water year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME tInput - datetime for which the beginning of water year date is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "GetMonth"( date ) <= 9.00000000 )
 THEN
  "CompletePartialDate"( @"24:00:00 October 31", "NumberToYear"( "GetYear"( date ) - 1.00000000 ) )
 ELSE
  "CompletePartialDate"( @"24:00:00 October 31", date )
 ENDIF;

    END
    UUID "{15f3e30b-7f69-4423-857e-f57665a32d49}";;

    FUNCTION       "CheckAndAdjustToCapacity" ( SLOT divSlot, NUMERIC divCap )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function redistributes flows in divSlot that exceed the capacity value divCap<br><br>RETURNS: List of flow rates [L^3/T]<br><br>ARGUMENTS:<br>1. SLOT divSlot - slot with units of flow rate [L^3/T] to check for values meeting capacity provided<br>2. NUMERIC divCap - maximum value to allow for values in divSlot<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: John Roca, Unknown<br>MC, 20170609: This function was written in response to a situation that occurred whereby MWD would take extra available water near the end of a year, but doing so too late in the year resulted in diversions that exceeded the canal capacity";
    BEGIN

      WITH LIST divPairs = FOR ( DATETIME ithDate IN "GetDates"( @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) WITH LIST result = {  } DO
  APPEND { ithDate , "FlowToVolume"( divSlot [ithDate], ithDate ) } ONTO result
 ENDFOR DO
  WITH NUMERIC overCapVol = FOR ( LIST ithVal IN divPairs ) WITH NUMERIC result = 0.00000000 "acre-feet" DO
   result + "Max"( 0.00000000 "acre-feet", ( GET @INDEX 1.00000000 FROM ithVal ) - "FlowToVolume"( divCap, GET @INDEX 0.00000000 FROM ithVal ) )
  ENDFOR DO
   WITH LIST spaceAvailable = FOR ( LIST ithVal IN divPairs ) WITH LIST result = {  } DO
    APPEND "FlowToVolume"( divCap, GET @INDEX 0.00000000 FROM ithVal ) - GET @INDEX 1.00000000 FROM ithVal ONTO result
   ENDFOR DO
    FOR ( LIST ithPair IN "Reverse"( divPairs ) ) WITH LIST output = {  } DO
     INSERT WITH NUMERIC cumulativeSpaceAvailable = FOR ( DATETIME jthT IN "GetDates"( ( GET @INDEX 0.00000000 FROM ithPair ), @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) WITH NUMERIC result = 0.00000000 "acre-feet" DO
      result + "Max"( GET @INDEX "GetMonth"( jthT ) - 1.00000000 FROM spaceAvailable, 0.00000000 "acre-feet" )
     ENDFOR COMMENTED_BY "Get the cumulative space available for the given month" DO
      "VolumeToFlow"( ( ( GET @INDEX 1.00000000 FROM ithPair ) + "MinItem"( { overCapVol , GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable , IF ( cumulativeSpaceAvailable < overCapVol )
      THEN
       GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable
      ELSE
       IF ( cumulativeSpaceAvailable - overCapVol >= GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable )
       THEN
        0.00000000 "acre-ft"
       ELSE
        ( GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable ) - ( cumulativeSpaceAvailable - overCapVol )
       ENDIF
      ENDIF COMMENTED_BY "This logic detemines the incremental change required without going over the annual volume" } ) ) COMMENTED_BY "Add or subtract the required adjustment value to meet the required annual volume or to prevent <br>going over the monthly capacity", GET @INDEX 0.00000000 FROM ithPair )
     ENDWITH INTO output
    ENDFOR COMMENTED_BY "Iterate through the dates from December backwards to January while <br>distributing the over-capacity total volume to months that have space"
   ENDWITH COMMENTED_BY "Figure out the monthly values by which diversions are over or under the capacity"
  ENDWITH COMMENTED_BY "Figure out the total volume that needs to be redistibuted given the monthly diversion values that <br>go over the capacity"
 ENDWITH COMMENTED_BY "Get a list of date and value pairs for the calendar year";

    END
    UUID "{d2f3bb85-1c2a-4100-9b0e-e454d4f6cfa9}";;

    FUNCTION       "IsUEBEqualizingBranchAndRunCycle4" ( DATETIME eoyDate )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns TRUE if the current Run Cycle is 4 and the Powell upper elevation balancing branch is > 1.20 (1.27, 1.29, 1.3, or 1.4), and FALSE otherwise.<br><br>RETURNS: Boolean TRUE or FALSE<br><br>ARGUMENTS:<br>1. DATETIME eoyDate - the end of year date specifying the water year for which the UEB Branch is checked<br><br>CONSTRAINTS: NONE";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: TP, 201801";
    BEGIN

      ( "GetRunCycleIndex"(  ) == 4.00000000 AND $ "PowellData.UpperElevBalBranch" [eoyDate] > 1.20000000 );

    END
    UUID "{9931bbae-5872-4b0d-8b90-9a893d240eb8}";;

    FUNCTION       "SetNegativeToZero" ( NUMERIC in_val )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a value and if it is negative, returns zero.<br><br>RETURNS: non-negative value<br><br>ARGUMENTS:<br>1. NUMERIC in_val - numeric value";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author: S.Baker, 20200310";
    BEGIN

      "Max"( in_val, in_val * 0.00000000 );

    END
    UUID "{c5f217f0-f879-43bc-b280-af69804a5f72}";;

    FUNCTION       "PartialToFull" ( DATETIME MonthDay )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns a fully-specified datetime in the current year of the partially-specified datetime in the input parameter MonthDay<br><br>RETURNS: A full datetime expression [DATETIME]<br><br>ARGUMENTS: <br>1. DATETIME MonthDay - a partially-specified datetime representing a month and day<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown <br>MC, 20160915: Replace calls with calls to predefined function CompletePartialDate (cf. Annual Daily Black Canyon Flow Determination)? ";
    BEGIN

      WHILE ( result < MonthDay ) WITH DATETIME result = @"24:00:00 January 1, Current Year" DO
  result + 1.00000000 "day"
 ENDWHILE;

    END
    UUID "{576c3b51-b941-4fe7-bde4-80f7b2443213}";;

  END
  UUID "{164b480b-be20-42c2-ae67-52b9db261109}";;

  UTILITY_GROUP "Rule Curve Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "ComputeOutflowAtGivenStorage" ( OBJECT reservoir, NUMERIC storage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: Uses the predefined function SolveOutflow to calculate the outflow value that leads to the final storage value provided in the input parameter &quot;storage&quot; bound by Mead min and max releases defined in the UBRuleCurveData object.<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir object for which the outflow value is desired<br>2. NUMERIC storage - the end of timestep storage target<br><br>CONSTRAINTS: Minimum and maximum releases as stored on UBRuleCurveData.ReservoirData<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT "GetMinRelease"( reservoir );
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20160915 - the ComputeOutflowAtGivenStorageForSpaceBuilding user-defined function uses the same calculation but does not contain the Min and Max Release constraints that are in this function";
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [@"t"], storage, reservoir & "Storage" [@"t - 1"], @"t" );

    END
    UUID "{04073ef3-d4e1-45c7-b04a-b1e0bc59b5b5}";;

    FUNCTION       "ComputeOutflowAtGivenStorageForSpaceBuilding" ( OBJECT reservoir, NUMERIC storage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "DESCRIPTION: Uses the predefined function SolveOutflow to calculate the outflow value that leads to the final storage value provided as the input parameter &quot;storage&quot; without outflow constraints<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir object for which the outflow value is desired<br>2. NUMERIC storage - the end of timestep storage target<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20160915: the ComputeOutflowAtGivenStorage user-defined function uses the same calculation but contains Post-Exec Checks that constrain the outflow to Min and Max Release values; remove this one?";
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [], storage, reservoir & "Storage" [@"t - 1"], @"t" );

    END
    UUID "{0c19ef86-9de7-426a-abd9-6bd9e5f41efd}";;

    FUNCTION       "ComputeStorageWithGivenOutflow" ( OBJECT reservoir, NUMERIC outflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Uses the predefined function SolveStorage to calculate the end of timestep storage using the provided outflow value, subject to minimum and maximum storage values from the GetInactiveCapacity and GetLiveCapacity user-defined functions<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir object for which the storage is desired<br>2. NUMERIC outflow - the outflow value used to achieve the end of timestep storage value<br><br>CONSTRAINTS: Inactive (min) and Live (max) capacities of reservoir<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT "GetInactiveCapacity"( reservoir );
    MAX_CONSTRAINT "GetLiveCapacity"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SolveStorage"( reservoir, reservoir & "Inflow" [], outflow, reservoir & "Storage" [@"t - 1"], @"t" );

    END
    UUID "{2ef4b157-2d0e-49f2-8b41-2327156c9d8a}";;

    FUNCTION       "CheckResPhysicalConstraint" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total water available as a flow rate by converting the previous storage volume into a flow rate, adding the inflows for the date specified, and subtracting a fixed flow rate (50,000 acre-ft/month)<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir to check<br>2. DATETIME date - date on which to check the reservoir<br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: Is there a basis for the fixed 50,000 acre-ft/month, and if so, what is it? Move this value to a slot?";
    BEGIN

      WITH DATETIME dateBefore = "OffsetDate"( date, - 1.00000000, "1 months" ) DO
  "VolumeToFlow"( res & "Storage" [dateBefore], date ) + res & "Inflow" [date] - 50000.00000000 "acre-ft/month"
 ENDWITH;

    END
    UUID "{c8f770cc-24ba-4359-b8f5-ea7ab2754ea7}";;

  END
  UUID "{41afa860-b2a0-482e-adaa-4ce529aa0aaf}";;

  UTILITY_GROUP "Orphan Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AlreadyUsedWater" ( OBJECT obj, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "SumFlowsToVolume"( obj & "Total Depletion", @"24:00:00 January Max DayOfMonth, Current Year", @"t - 1" );

    END
    UUID "{a879db7e-6f5d-4355-819c-6911a0e5675a}";;

    FUNCTION       "AnnualRequestedWater" ( STRING user, STRING type, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "SumFlowsToVolume"( "GetSlot"( user CONCAT ".Total " CONCAT type CONCAT " Requested" ), "OffsetDate"( date, - ( "GetMonth"( date ) - 1.00000000 ) COMMENTED_BY "The number to subtract from date to go to January of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to January of the year found in 'date'", "OffsetDate"( date, ( 12.00000000 - "GetMonth"( date ) ) COMMENTED_BY "The number to add to date to go to December of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to December of year found in 'date'" ) COMMENTED_BY "Calculated annual requested water (either depletion or diversion which is <br>specified by 'type') and expects the user to be on the San Juan River";

    END
    UUID "{3f9ec247-8a67-48bc-ae09-04f7b6ffdb82}";;

    FUNCTION       "AnticipatedInflowNavajo" ( DATETIME dateToStart, DATETIME dateToProject )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the inflow to Navajo for the entire run period<br><br>RETURN TYPE: NUMERIC<br><br>ARGUMENTS<br>1. DATETIME dateToStart<br>2. DATETIME dateToProject<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/07/2012<br>MC, 20170502: I turned this rule off and replaced its 2 references in the ruleset by its body. I'm scheduling it for deletion as unnecessary.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "SumFlowsToVolume"( $ "Navajo.Inflow", dateToStart, dateToProject );

    END
    UUID "{0a98244c-a64c-4b37-8dd5-6a862a70ea3f}";;

    FUNCTION       "April30ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the day of the year for April 30 making corrections for leap years if necessary. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "LeapYear"( date ) )
 THEN
  "OffsetDate"( date, "Units NONE"( 121.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ELSE
  "OffsetDate"( date, "Units NONE"( 120.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ENDIF;

    END
    UUID "{4ef9cb8c-81e7-4081-8b0c-eec0269db750}";;

    FUNCTION       "BlueMesaEOMElevationTarget" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "DESCRIPTION: This function takes a date and returns the end-of-month elevation target for Blue Mesa Reservoir.  It does this by reading the appropriate row from the BlueMesaData.BlueMesaGuide slot.  The only exception is that if the reservoir did not fill in June, then in July the function will return the June entry in the table. - sc 12/28/10<br><br>RETURNS: Pool elevation [L]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the target elevation is needed<br><br>CONSTRAINTS: <NONE><br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: No calls to this function so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
 THEN
  IF ( "MaxItem"( "GetSlotVals"( $ "BlueMesa.Pool Elevation", @"t - 2", @"t - 1" ) ) >= $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] )
  THEN
   $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"]
  ELSE
   $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"]
  ENDIF
 ELSE
  $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"]
 ENDIF;

    END
    UUID "{1f010bf6-f720-4811-a078-95b622b5ed37}";;

    FUNCTION       "BlueMesaReleaseMAXConstraintByMonth" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function calculates the maximum constraint (ceiling) for the Blue Mesa release on the passed-in date.  The max constraint will not necessarily be the release, just provide an upper bound for that months release. - sc 12/28/10<br><br>RETURNS: Blue Mesa release ceiling [L^3/T]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the release ceiling is needed<br><br>CONSTRAINTS: <br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: May ceiling is unlimited?; no calls to function so disabled it";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "December" , "January" , "February" , "March" , "April" , "August" , "September" , "October" COMMENTED_BY "Move october and november to 2100 limit, per Paul D. - tv 7.26.12" , "November" } )
 THEN
  "Max"( "SolveBlueMesaReleaseForCrystalReleaseTarget"( 2100.00000000 "cfs", @"t" ), "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" COMMENTED_BY "change to 7516.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date ) )
 ELSE
  IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
  THEN
   "Max"( "SolveBlueMesaReleaseForCrystalReleaseTarget"( 4150.00000000 "cfs" COMMENTED_BY "Max at 4150 cfs, per Paul D. - tv 7.26.12", @"t" ), "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7519.40000000 "ft" COMMENTED_BY "change to 7519.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date ) COMMENTED_BY "Changed from mass balance to SolveOutflow function - tv 7.26.12" )
  ELSE
   9999999.00000000 "cfs"
  ENDIF
 ENDIF;

    END
    UUID "{eb723e96-7b1d-4bd2-a312-44b1da675177}";;

    FUNCTION       "BlueMesaReleaseMINConstraintByMonth" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10<br><br>MC, 20170531: No calls to function so disabled it";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC DownstreamFlowBasedConstraint = "BlueMesaReleaseMINConstraint_DownstreamFlow"( @"t" ) DO
  WITH NUMERIC ReservoirElevationBasedConstraint = "BlueMesaReleaseMINConstraint_ResElevation"( @"t" ) DO
   "Min"( "Max"( DownstreamFlowBasedConstraint, ReservoirElevationBasedConstraint ), "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", 7358.01000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "The maximum that the reservoir can release to the bottom of outlets at 7358 ft. Added 8/1/12 - tv" )
  ENDWITH
 ENDWITH;

    END
    UUID "{ce927da3-924a-41fc-aec8-930ef8a3085a}";;

    FUNCTION       "BlueMesaReleaseMINConstraint_ResElevation" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "January" } )
 THEN
  WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
   WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
    WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
     "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.17000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
    ENDWITH
   ENDWITH
  ENDWITH
 ELSE
  IF ( "GetMonthAsString"( date ) IN { "February" } )
  THEN
   WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
    WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
     WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
      "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.15000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
     ENDWITH
    ENDWITH
   ENDWITH
  ELSE
   IF ( "GetMonthAsString"( date ) IN { "March" } )
   THEN
    WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
     WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
      WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
       "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.15000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
      ENDWITH
     ENDWITH
    ENDWITH
   ELSE
    IF ( "GetMonthAsString"( date ) IN { "April" } )
    THEN
     WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
      WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
       WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
        "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.20000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
       ENDWITH
      ENDWITH
     ENDWITH
    ELSE
     IF ( "GetMonthAsString"( date ) IN { "June" } )
     THEN
      WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
       WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
        WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) DO
         "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.33000000, date ), date )
        ENDWITH
       ENDWITH
      ENDWITH
     ELSE
      IF ( "GetMonthAsString"( date ) IN { "July" } )
      THEN
       "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7519.40000000 "ft" COMMENTED_BY "Changed to 7519.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
      ELSE
       IF ( "GetMonthAsString"( date ) IN { "August" } )
       THEN
        "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" COMMENTED_BY "Changed to 7516.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
       ELSE
        IF ( "GetMonthAsString"( date ) IN { "September" } )
        THEN
         "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
        ELSE
         IF ( "GetMonthAsString"( date ) IN { "October" } )
         THEN
          "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
         ELSE
          IF ( "GetMonthAsString"( date ) IN { "November" } )
          THEN
           "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
          ELSE
           "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF;

    END
    UUID "{dc9fd606-8eb9-48eb-a603-0d3fb9a07356}";;

    FUNCTION       "BlueMesaReleaseMINConstraint_DownstreamFlow" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC flowLevel = $ "BlueMesaData.MayPeakFlowLevel" ["Dec31ofYear"( @"24:00:00 April 1, Current Year" )] DO
  IF ( "GetMonthAsString"( date ) IN { "January" } )
  THEN
   "Min"( "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "TunnelReturnFlow.Inflow" [@"t - 1"] ), @"t" ), $ "BlueMesaData.BaseFlowTarget" [date, flowLevel] )
  ELSE
   IF ( "GetMonthAsString"( date ) IN { "February" } )
   THEN
    "Min"( "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" ), $ "BlueMesaData.BaseFlowTarget" [date, flowLevel] )
   ELSE
    IF ( "GetMonthAsString"( date ) IN { "March" } )
    THEN
     "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
    ELSE
     IF ( "GetMonthAsString"( date ) IN { "April" } )
     THEN
      "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
     ELSE
      IF ( "GetMonthAsString"( date ) IN { "June" } )
      THEN
       "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseFlowTarget" [date, flowLevel] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [@"t"] ), @"t" )
      ELSE
       IF ( "GetMonthAsString"( date ) IN { "July" } )
       THEN
        "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseFlowTarget" [date, flowLevel] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [@"t"] ), @"t" )
       ELSE
        IF ( "GetMonthAsString"( date ) IN { "August" } )
        THEN
         "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
        ELSE
         IF ( "GetMonthAsString"( date ) IN { "September" } )
         THEN
          "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
         ELSE
          IF ( "GetMonthAsString"( date ) IN { "October" } )
          THEN
           "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
          ELSE
           IF ( "GetMonthAsString"( date ) IN { "November" } )
           THEN
            "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
           ELSE
            "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseFlowTarget" [date, flowLevel] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [@"t"] ), @"t" )
           ENDIF
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{9495b11b-b297-4b94-b35b-46ff3c6a9b6c}";;

    FUNCTION       "CalendarYearDatesByGroup" ( NUMERIC inputGroupNumber )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "MC, 20170502: This function is not called in the current ruleset";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH LIST prelimList = FOR ( DATETIME date IN @"Start Timestep + 1" TO @"Finish Timestep" ) WITH LIST result = { { @"Start Timestep" , 1.00000000 } } DO
  WITH NUMERIC groupNumber = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
   IF ( "GetMonthAsString"( date ) == "October" )
   THEN
    APPEND { date , groupNumber + 1.00000000 } ONTO result
   ELSE
    APPEND { date , groupNumber } ONTO result
   ENDIF
  ENDWITH
 ENDFOR DO
  IF ( ( inputGroupNumber == 3.00000000 AND @"Start Timestep" == @"October 31" ) COMMENTED_BY "If the start month is October then there is no third water year in the run window.  Thus we need this function to be <br>non-empty and return a date that will definitely be outside of the run window. - sc 11/03/11" )
  THEN
   { @"24:00:00 December 31, 1900" }
  ELSE
   FOR ( LIST dateGroupNumber IN prelimList ) WITH LIST result = {  } DO
    IF ( ( GET @INDEX 1.00000000 FROM dateGroupNumber ) == inputGroupNumber )
    THEN
     APPEND GET @INDEX 0.00000000 FROM dateGroupNumber ONTO result
    ELSE
     result
    ENDIF
   ENDFOR
  ENDIF
 ENDWITH;

    END
    UUID "{0ccf6b27-5fdb-413a-9c9e-09d038cac148}";;

    FUNCTION       "EqualizationTeirCalculationForRelease_Orig" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC PowellVolumeOverEqLevel = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) ), 0.00000000 "acre-ft" ) DO
  WITH NUMERIC equalizationReleaseVolume = "EqualizationRelease"( EOWYDate ) DO
   WITH NUMERIC preliminaryReleaseVolume = "Min"( PowellVolumeOverEqLevel + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )], equalizationReleaseVolume ) DO
    WITH NUMERIC meadElevationWithPrelimRelease = IF ( $ "Mead.Storage" [EOWYDate] + ( preliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) >= "ElevationToStorage"( % "Mead", 1229.00000000 "feet" ) )
    THEN
     1229.00000000 "feet"
    ELSE
     "StorageToElevation"( % "Mead", $ "Mead.Storage" [EOWYDate] + ( preliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) )
    ENDIF DO
     IF ( meadElevationWithPrelimRelease < 1105.00000000 "ft" )
     THEN
      WITH NUMERIC totalVolumeToRaiseMeadTo1105 = "Max"( "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - $ "Mead.Storage" [EOWYDate], 0.00000000 "acre-ft" ) DO
       WITH NUMERIC PowellVolumeOverEqLevelLess20ft = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ), 0.00000000 "acre-ft" ) DO
        ( "MinItem"( { equalizationReleaseVolume , totalVolumeToRaiseMeadTo1105 , PowellVolumeOverEqLevelLess20ft } ) + 8230.00000000 "1000 acre-feet" ) COMMENTED_BY "Choose the minimum of the equalization release, the release to take Mead to 1105 and the release to take Powell down to the equalization level less 20'"
       ENDWITH COMMENTED_BY "Volume of Powell storage above the equalization level minus 20 feet"
      ENDWITH COMMENTED_BY "Volume needed to release from Powell to raise Mead elevation to 1105'"
     ELSE
      preliminaryReleaseVolume
     ENDIF COMMENTED_BY "Check if the preliminary release volume takes Mead above 1105'.  If so the preliminary volume is chosen, if not continue."
    ENDWITH COMMENTED_BY "EOWY Elevation of Mead with the preliminaryReleaseVolume release from Powell"
   ENDWITH COMMENTED_BY "Preliminary annual volume release before the Mead elevation check."
  ENDWITH COMMENTED_BY "Total volume that would need to be released to equalize storage"
 ENDWITH COMMENTED_BY "Total Volume in Powell above the Current Equalization Level";

    END
    UUID "{1a8f0db2-e957-4c55-acf8-b6aeebd1fe6a}";;

    FUNCTION       "DetermineMonthlyDistribution" ( STRING slot2check, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( "FlowToVolume"( "GetSlot"( slot2check ) [date], date ) / "SumFlowsToVolume"( "GetSlot"( slot2check ), "OffsetDate"( date, - ( "GetMonth"( date ) - 1.00000000 ) COMMENTED_BY "The number to subtract from date to go to January of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to January of the year in date", "OffsetDate"( date, ( 12.00000000 - "GetMonth"( date ) ) COMMENTED_BY "The number to add to date to go to December of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to December of the year in date" ) ) COMMENTED_BY "Determines the monthly distribution of any slot.  Returns the poriton of demand/flow of <br>the date passed to the function for the slot passed to the function";

    END
    UUID "{7b303909-e545-46b0-8f10-217c6d3ac431}";;

    FUNCTION       "DummyTestFunction" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      0.00000000;

    END
    UUID "{f9aa2c8a-f953-47a3-8db2-8a1154556600}";;

    FUNCTION       "ICSAccountingForCA" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the ICS categories Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat) and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total California ICS Volume. The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>RETURNS: List of lists of the form &lcub;&lcub;EC delivery, SE delivery, BiNat delivery, EC ICS created, CA EC ICS, CA SE ICS, CA BiNat ICS, Total CA ICS, MWD diversion reduction&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 9/10/2014";
    BEGIN

      WITH NUMERIC totalDeliveryOfCAICS = IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  GET @INDEX 0.00000000 FROM "DeliveryAndCreationCAICS"(  )
 ENDIF COMMENTED_BY "In shortage years no delivery of ICS is possible" DO
  WITH NUMERIC creationOfCACEICS = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 OR NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   GET @INDEX 1.00000000 FROM "DeliveryAndCreationCAICS"(  )
  ENDIF COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water" DO
   WITH NUMERIC creationSE = $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )] COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water. Investments in long term <br>projects and these would be known and they would be scheduled by a date where they can start getting <br>credits after the completion of those projects, can be created under any condition.  ST 9/11/2015" DO
    WITH NUMERIC creationBiNat = $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )] COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water" DO
     WITH NUMERIC deliveryChargedToEC = "Min"( totalDeliveryOfCAICS, $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfCACEICS ) DO
      WITH NUMERIC deliveryChargedToSE = "Min"( totalDeliveryOfCAICS - deliveryChargedToEC, $ "ICS Credits.SystemEfficiencyICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )] ) DO
       WITH NUMERIC deliveryChargedToBiNat = "Min"( totalDeliveryOfCAICS - deliveryChargedToEC - deliveryChargedToSE, $ "ICS Credits.BiNationalICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )] ) DO
        WITH NUMERIC mwdDiversionReduction = "Max"( totalDeliveryOfCAICS - deliveryChargedToEC - deliveryChargedToSE - deliveryChargedToBiNat, 0.00000000 "acre-ft" ) DO
         WITH NUMERIC ECICSCA = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
         THEN
          $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfCACEICS * "SystemTaxAdjustment"(  ) - deliveryChargedToEC
         ELSE
          ( $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] - deliveryChargedToEC ) * 0.97000000 + creationOfCACEICS * "SystemTaxAdjustment"(  )
         ENDIF COMMENTED_BY "Resulting ExtraOrdinaryConservation ICS " DO
          WITH NUMERIC SEICSCA = ( $ "ICS Credits.SystemEfficiencyICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationSE - deliveryChargedToSE ) COMMENTED_BY "Resulting System Efficiency ICS " DO
           WITH NUMERIC BiNatICSCA = ( $ "ICS Credits.BiNationalICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationBiNat - deliveryChargedToBiNat ) COMMENTED_BY "Resulting Bi National ICS " DO
            WITH NUMERIC totalICSCA = ( ECICSCA + SEICSCA + BiNatICSCA ) COMMENTED_BY "Total ICS" DO
             { deliveryChargedToEC , deliveryChargedToSE , deliveryChargedToBiNat , creationOfCACEICS , ECICSCA , SEICSCA , BiNatICSCA , totalICSCA , mwdDiversionReduction , totalDeliveryOfCAICS }
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{c89f49a2-95a9-4215-8b48-ca925445c8b9}";;

    FUNCTION       "ECDF" ( LIST Data, NUMERIC num )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns the proportion of values in LIST &quot;Data&quot; that are less than value in &quot;num&quot; - MC, 20160527";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC val IN Data ) WITH NUMERIC result = 0.00000000 DO
  IF ( val <= num )
  THEN
   result + 1.00000000
  ELSE
   result
  ENDIF
 ENDFOR / LENGTH Data;

    END
    UUID "{67a186a2-8931-4b66-9bd9-2105265bce4f}";;

    FUNCTION       "EstimateBankStorageChange" ( OBJECT res, NUMERIC startStorage, NUMERIC endStorage, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates an estimate of the change in the bank storage that occurs due to the change in storage from startStorage to endStorage<br><br>RETURNS: Change in bank storage volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir for which storage change occurs<br>2. NUMERIC startStorage - beginning storage volume<br>3. NUMERIC endStorage - ending storage volume<br>4. DATETIME startDate - date on which startStorage occurs<br>5. DATETIME endDate - date on which endStorage occurs<br><br>CONSTRAINTS: <NONE><br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      ( endStorage - "EstimateEvaporation"( res, startStorage, endStorage, startDate, endDate ) - startStorage ) COMMENTED_BY "Available volume to contibute to bank storage" * res & "Bank Storage Coefficient" [0.00000000, 0.00000000] COMMENTED_BY "proportion of volume available for bank storage <br>that actually becomes bank storage";

    END
    UUID "{5f878d8b-3d0c-4ac1-a350-cd24d7a329af}";;

    FUNCTION       "EstimateDeltaStorageEOWY" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "RuleCurveStorage"( res, "RelativeEOWYDate"( @"t" ) ) - "PrevStorage"( res );

    END
    UUID "{75e55c9e-ad20-4dde-9841-533c3328f18f}";;

    FUNCTION       "EstimateDeltaStorageOND" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "RuleCurveStorage"( res, @"24:00:00 December Max DayOfMonth, Current Year" ) - "RuleCurveStorage"( res, @"24:00:00 October Max DayOfMonth, Current Year" );

    END
    UUID "{ae831120-f726-408d-8c8d-044b5eac2042}";;

    FUNCTION       "ForecastComputeDemandsBelow" ( OBJECT reservoir, DATETIME month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function computes the inflow to the subbasin below &quot;reservoir&quot; for the timestep &quot;month&quot; required to satisfy all subbasin diversions while meeting minimum flow requirements (see also documentation for predefined function &quot;NetSubBasinDiversionRequirement&quot;)<br><br>RETURNS: NUMERIC<br><br>ARGUMENTS<br>1. OBJECT reservoir - reservoir that defines downstream subbasin<br>2. DATETIME month - timestep for which calculation is made<br><br>CONSTRAINTS: Maximum release flow rate from specified reservoir<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170503: There are no references to this function in the current ruleset, so I am disabling it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    NOTES          "";
    BEGIN

      IF ( month <= "RunEndDate"(  ) )
 THEN
  "Max"( "NetSubBasinDiversionRequirement"( "ListSubbasin"( "Below" CONCAT STRINGIFY reservoir ), month ), 0.00000000 "acre-feet/month" )
 ELSE
  "Max"( "NetSubBasinDiversionRequirement"( "ListSubbasin"( "Below" CONCAT STRINGIFY reservoir ), "GetDate"( "GetMonthAsString"( month ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ), 0.00000000 "acre-feet/month" )
 ENDIF;

    END
    UUID "{514575ff-ae2c-4822-8bd0-da9d08d32077}";;

    FUNCTION       "FutureFontenelleInflow" ( STRING month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "MC, 20170503: This function has no calls to it in the current ruleset, so it is turned off.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( "MonthlyAverageFlowInModel"( $ "GreenRAboveFontenelle.Inflow", month ) - "SumObjectsAggregatedOverTime"( "UsersAboveCP9", "Total Depletion Requested", "SUM", "ALL", FALSE, "GetDate"( month CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ), "GetDate"( month CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ) ) COMMENTED_BY "Calculates the future (after the model end date) inflow into Fontenelle based on <br>average natural flow above Fontenelle for the particular month, and the demands <br>above Fontenelle from the last year of the model run.";

    END
    UUID "{b909d1c9-a5be-4448-bcd9-234d77ef13d6}";;

    FUNCTION       "GetMeadPowellElevDiff" ( STRING reservoir, DATETIME eowyDate, STRING elevOrStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "MC, 20170501: This function is not referenced in the ruleset.<br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC PowellAnnualVolume = $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( IF ( @"t" == @"Start Timestep" )
 THEN
  @"t"
 ELSE
  @"t + 2"
 ENDIF ) )] DO
  IF ( reservoir == "Powell" )
  THEN
   IF ( elevOrStorage == "elev" )
   THEN
    IF ( PowellAnnualVolume == 8230000.00000000 "acre-ft" )
    THEN
     $ "Powell.Pool Elevation" [eowyDate]
    ELSE
     "StorageToElevation"( % "Powell", $ "Powell.Storage" [eowyDate] + ( PowellAnnualVolume - 8230000.00000000 "acre-ft" ) )
    ENDIF
   ELSE
    $ "Powell.Storage" [eowyDate] + ( PowellAnnualVolume - 8230000.00000000 "acre-ft" )
   ENDIF
  ELSE
   IF ( elevOrStorage == "elev" )
   THEN
    IF ( PowellAnnualVolume == 8230000.00000000 "acre-ft" )
    THEN
     $ "Mead.Pool Elevation" [eowyDate]
    ELSE
     "StorageToElevation"( % "Mead", $ "Mead.Storage" [eowyDate] - ( PowellAnnualVolume - 8230000.00000000 "acre-ft" ) )
    ENDIF
   ELSE
    $ "Mead.Storage" [eowyDate] - ( PowellAnnualVolume - 8230000.00000000 "acre-ft" )
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{fe9d84f4-5352-4e22-a0b3-7d002f3ec1a4}";;

    FUNCTION       "GetPowellMonthlyReleases_pre20170427" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume does a linear interpolation on that table to find releases that sum up exactly to the annual volume set for Powell.  If the passed in set of dates is the first water year in the run (i.e., starts with the run's start timestep), then this function will make an adjustment to the releases that were calculated by doing the linear interpolation to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly- sc 03/25/11<br><br>ARGUMENTS:<br>1. datesToEOWY<br><br>RETURNS: A list either of the form &lcub;Month, Monthly Release, Remaining Volume over Lower Bounds&rcub; (from CalculatePowellMonthlyRelease) OR &lcub;Month, Monthly Release, <br><br>DEVELOPMENT NOTES:<br>MC, 20160907: In calculation of newAdjustedMonthlyRel, moved subRelList<1> (and multiplied by 1 &quot;month&quot;) into call to VolumeToFlow to get desired volume; previous version was not giving correct desired volume (at least in some cases when UserInput_MinimumAnnualRelease sets the TARV) due to conversion associated with monthly flow and time scale (i.e., RW was making an unwanted conversion based on the number of days in a month); Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC annualVolume = "CurrentAnnualVolume"( GET @INDEX 0.00000000 FROM datesToEOWY ) DO
  WITH NUMERIC totalVolumeReleasedPreRun = IF ( "GetMonthAsString"( GET @INDEX 0.00000000 FROM datesToEOWY ) == "October" )
  THEN
   0.00000000 "acre-feet"
  ELSE
   "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), @"Start Timestep - 1" ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] )
  ENDIF DO
   WITH NUMERIC RemainingWYReleaseVolume = annualVolume - totalVolumeReleasedPreRun DO
    WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( annualVolume ) DO
     WITH NUMERIC LowerColumnBound = "FindReleaseLowerBoundColumn"( annualVolume, UpperColumnBound ) DO
      WITH LIST AdjustedMonthlyRel = "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYReleaseVolume ) DO
       IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
       THEN
        WITH NUMERIC sumMonthlyReleases = FOR ( LIST monthlyReleaseVol IN AdjustedMonthlyRel ) STAT_SUM
         "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
        ENDFOR DO
         WITH NUMERIC Tolerance = 5.00000000 "acre-ft" DO
          WITH NUMERIC VolumeDifference = RemainingWYReleaseVolume - sumMonthlyReleases DO
           IF ( "Abs"( VolumeDifference ) < Tolerance )
           THEN
            AdjustedMonthlyRel
           ELSE
            WITH NUMERIC VolumeAdjustment = VolumeDifference / LENGTH AdjustedMonthlyRel DO
             WITH LIST newAdjustedMonthlyRel = FOR ( LIST subRelList IN AdjustedMonthlyRel ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
              WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
               WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - VolumeAdjustment DO
                ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( VolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
               ENDWITH
              ENDWITH
             ENDFOR DO
              REMOVE ITEM @INDEX 0.00000000 FROM newAdjustedMonthlyRel
             ENDWITH
            ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170207: Within the function CalculatePowellMonthlyRelease there is also a check that all required volume was released;<br>	should all volume checking be made more robust & moved to CalculatePowellMonthlyRelease?<br>MC, 20170427: I thnk the check in CalculatePowellMonthlyRelease should be removed and have the adjustment done here, but <br>change the adjustment to be proportional to the monthly release.<br>"
           ENDIF
          ENDWITH
         ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
        ENDWITH COMMENTED_BY "Calculate total remaining releases from AdjustedMonthlyRel"
       ELSE
        AdjustedMonthlyRel
       ENDIF
      ENDWITH COMMENTED_BY "Calculate list of the form &lcub;Month, Adjusted monthly release rate, Remaining volume above lower bound column&rcub;"
     ENDWITH COMMENTED_BY "Detemine index of first column in monthly release table with total annual volume <= annualVolume<br>(Same as UpperColumnBound if annualVolume is equal to a column total)"
    ENDWITH COMMENTED_BY "Calculate index of first column in monthly release table with total annual volume >= annualVolume"
   ENDWITH
  ENDWITH COMMENTED_BY "Determine volume released prior to model run start"
 ENDWITH COMMENTED_BY "Retrieve TargetAnnualReleaseVolume for water year containing datesToEOWY<0>";

    END
    UUID "{0139d5af-9ba4-4668-9723-89c83f0639ea}";;

    FUNCTION       "IsSpringPeakMonth" ( OBJECT res, DATETIME date )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( res == % "Navajo" )
 THEN
  IF ( date >= @"24:00:00 April 31, Current Year" AND date <= @"24:00:00 June 30, Current Year" )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF
 ELSE
  STOP_RUN "Invalid reservoir passed to IsSpringPeakMonth"
 ENDIF;

    END
    UUID "{16ec87ad-8981-4d87-a759-147a876de996}";;

    FUNCTION       "July31ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the day of the year for July 31 making corrections for leap years if necessary. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "LeapYear"( date ) )
 THEN
  "OffsetDate"( date, "Units NONE"( 213.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ELSE
  "OffsetDate"( date, "Units NONE"( 212.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ENDIF;

    END
    UUID "{fed991d0-3caa-429b-aa69-1db2acaeea14}";;

    FUNCTION       "LowerTierEqualizationRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      ( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( $ "Powell.Storage" [EOWYDate] - $ "Mead.Storage" [EOWYDate] ) / 2.00000000 ) COMMENTED_BY "MC, 20160803: This function is the same calculation as the EqualizationRelease function.  I changed the call in the Set Lower Balancing Release Volume and PostLBDV functions to the EqualizationRelease function instead of this one, <br>which should be deleted as redundant orphan.";

    END
    UUID "{3e20e40a-7611-46bd-9aa8-f86921029c54}";;

    FUNCTION       "MonthDayRatio" ( NUMERIC days )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( 31.00000000 "day" / days );

    END
    UUID "{60e3c115-0730-449d-863f-7a9816cfe580}";;

    FUNCTION       "MyGetSlot" ( OBJECT obj, STRING slot )
    RETURN_TYPE    SLOT;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "GetSlot"( ( STRINGIFY obj ) CONCAT ( "." CONCAT slot ) );

    END
    UUID "{1e441ffd-b415-4ded-bac6-8163b1e09555}";;

    FUNCTION       "MyPercentRank" ( LIST Data, NUMERIC num )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      1.00000000;

    END
    UUID "{9d06e054-3fd7-4059-9700-2ca457b64116}";;

    FUNCTION       "NevadaBankingICS" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC unusedNV = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  300000.00000000 "acre-ft" - $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )]
 ENDIF DO
  WITH NUMERIC nvBankedCA = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   unusedNV
  ENDIF DO
   WITH NUMERIC nvBankedAZ = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
   THEN
    0.00000000 "acre-ft"
   ELSE
    0.00000000 "acre-ft"
   ENDIF DO
    WITH NUMERIC CumulativeNVBankedInCA = $ "ICS Credits.CumulativeNVBankedinCA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + nvBankedCA - nvUnbankedCA DO
     WITH NUMERIC AnnualNVRecoverableAZ = "Min"( 40000.00000000 "acre-ft", nvBankedAZ ) DO
      WITH NUMERIC AnnuaNVRecoverableCA = "Min"( 30000.00000000 "acre-ft", CumulativeNVBankedInCA ) DO
       WITH NUMERIC AnnualNVUnbankedFromAZ = "Min"( AnnualNVRecoverableAZ, nvUnbankedAZ ) DO
        WITH NUMERIC AnnualNVUnbankedFromCA = "Min"( AnnualNVRecoverableAZ, nvUnbankedCA ) DO
         ?
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{b51d9cc9-587b-48ff-898f-56c836b8e5fa}";;

    FUNCTION       "OND" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      @"24:00:00 October Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year";

    END
    UUID "{5d5746d1-c614-465d-8956-ff1960c796a2}";;

    FUNCTION       "PrevStorage" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "Returns the storage of the argument object for the previous timestep. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      res & "Storage" [@"t - 1"];

    END
    UUID "{ba9d84f1-1040-4a7c-96cb-b76ba4246e4c}";;

    FUNCTION       "Quantile" ( LIST Data, NUMERIC prob )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      GET @INDEX 1.00000000 FROM Data;

    END
    UUID "{34be8df3-5ff7-4430-a45f-33912dd96e3c}";;

    FUNCTION       "RampUpDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns a list of two-item lists, each sublist of the form &lcub;date, flow target&rcub;.  The function does this by starting at the peak flow date and the peak flow value and then going backward one day at a time and calculating the new flow target until it gets down to the shoulder flow which is already set on the slot by the previous rule (April Through July Daily Canyon Flows).  The liimitations in the ramp up daily rate are no more than 500cfs and no more than 25% of the previous day's flow. - sc 12/22/10<br><br>MC, 20170531: No calls to this function, so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC peakLevel = $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"] DO
  WITH DATETIME peakDate = "PartialToFull"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) ) DO
   WITH NUMERIC peakFlowTarget = "Max"( $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"], $ "BlueMesaData.TargetDailyWhitewaterFlows" [peakDate] ) DO
    WITH NUMERIC daysAtPeak = $ "BlueMesaData.SpringPeakAndDurationCanyonTargets" [peakLevel, "Duration of Half Bank Days"] DO
     WITH DATETIME dateToCheckRamp = peakDate - "Floor"( daysAtPeak / 2.00000000, 1.00000000 "day" ) DO
      WHILE ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) > $ "BlueMesaData.TargetDailyWhitewaterFlows" [GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList] OR ( LENGTH dateFlowList ) == 1.00000000 ) WITH LIST dateFlowList = { { dateToCheckRamp , peakFlowTarget } } DO
       WITH DATETIME previousDaysDate = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 1.00000000 "day" DO
        WITH NUMERIC previousDaysFlow = "Max"( "Min"( ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) * ( 1.00000000 / ( 1.00000000 + 0.25000000 COMMENTED_BY "If Paul says that the ramp up rate needs to be user-controlled, <br>put the slot reference here. - sc 12/22/10" ) ) ), ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 500.00000000 "cfs" ), $ "BlueMesaData.TargetDailyWhitewaterFlows" [previousDaysDate] ) DO
         APPEND { previousDaysDate , previousDaysFlow } ONTO dateFlowList
        ENDWITH
       ENDWITH
      ENDWHILE
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{00a51ab0-f5bb-4405-8e3e-becceb62f132}";;

    FUNCTION       "RampDownDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns a list of two-item lists, each sublist of the form &lcub;date, flow target&rcub;.  The function does this by starting at the peak flow date and the peak flow value and then going forward one day at a time and calculating the new flow target until it gets down to the shoulder flow which is already set on the slot by the previous rule (April Through July Daily Canyon Flows).  The liimitations in the ramp down daily rate are no more than 400cfs and no more than15% of the previous day's flow. - sc 12/22/10<br><br>MC, 20170531: No calls to this function, so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC peakLevel = $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"] DO
  WITH DATETIME peakDate = "PartialToFull"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) ) DO
   WITH NUMERIC peakFlowTarget = "Max"( $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"], $ "BlueMesaData.TargetDailyWhitewaterFlows" [peakDate] ) DO
    WITH NUMERIC daysAtPeak = $ "BlueMesaData.SpringPeakAndDurationCanyonTargets" [peakLevel, "Duration At Peak Flow"] DO
     WITH DATETIME dateToCheckRamp = peakDate + ( "Floor"( daysAtPeak / 2.00000000, 1.00000000 "day" ) - IF ( daysAtPeak == 0.00000000 "day" )
     THEN
      0.00000000 "day"
     ELSE
      1.00000000 "day"
     ENDIF ) DO
      WHILE ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) > $ "BlueMesaData.TargetDailyWhitewaterFlows" [GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList] OR ( LENGTH dateFlowList ) == 1.00000000 ) WITH LIST dateFlowList = { { dateToCheckRamp , peakFlowTarget } } DO
       WITH DATETIME nextDaysDate = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) + 1.00000000 "day" DO
        WITH NUMERIC nextDaysFlow = "Max"( "Min"( ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) * ( 1.00000000 - 0.15000000 COMMENTED_BY "If Paul says that the ramp down rate needs to be user- controlled, <br>put the slot reference here. - sc 12/22/10" ) ), ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 400.00000000 "cfs" ), $ "BlueMesaData.TargetDailyWhitewaterFlows" [nextDaysDate] ) DO
         APPEND { nextDaysDate , nextDaysFlow } ONTO dateFlowList
        ENDWITH
       ENDWITH
      ENDWHILE
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{6fb062e5-5978-4f1b-a5f5-326bf1c476d1}";;

    FUNCTION       "SolveBlueMesaReleaseForBlackCanyonTarget" ( NUMERIC TargetCanyonFlow, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a numeric flow target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target in the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace.  The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa. - sc 12/28/10<br><br>MC, 20170531: This function only called by other disabled Aspinall/Gunnison functions, so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date], $ "BlueMesaData.BlueMesaMinRelease" [] );

    END
    UUID "{57f458e7-095c-4b28-a89a-6ad263dc2926}";;

    FUNCTION       "SolveBlueMesaReleaseForWhitewaterTarget" ( NUMERIC TargetCanyonFlow, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a numeric flow target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target in the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace.  The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( ( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [date] ) COMMENTED_BY "Would set a Blue Mesa Release enough to meet the Whitewater Target and the Gunnison Tunnel <br><br>Diversion while leveraging the gains between Blue Mesa and Grand Junction TP/MC 9/22/2015", ( $ "BlueMesaData.MinimumBlackCanyonFlow" [date] + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] ) COMMENTED_BY "This would set a Blue Mesa Release enough to meet the minimum Black Canyon Flows and the <br><br>Gunnison Tunnel Diversion while leveraging the gains between BM and the Tunnel. TP/MC <br><br>9/22/2105" );

    END
    UUID "{7a186e74-3d02-44d7-bda6-b001d6f25264}";;

    FUNCTION       "SolveBlwBlueMesaInterveningFlows" ( LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a list of dates and sums the intervening flows from Below Blue Mesa.  Usually May has already been solved for so we do not include it in this calculation. <br>TP 2/13/2014<br><br>MC, 201705031: No calls to this function so disabled it.<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN dates ) STAT_SUM
  "FlowToVolume"( $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date], date ) + "FlowToVolume"( $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date], date )
 ENDFOR;

    END
    UUID "{52842b24-88c7-42ae-b92f-68b4903d7907}";;

    FUNCTION       "SolvePoolElevation" ( OBJECT obj, NUMERIC outflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Solves for end of time step storage given an object and its outflow<br><br>RETURN TYPE: NUMERIC<br><br>ARGUMENTS<br>1. OBJECT obj<br>2. NUMERIC outflow<br><br>COMMENTS<br><br>AUTHOR, DATE: Unknown<br><br>UPDATE NOTES<br>1. Standardized description added by MC, 20170323";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "StorageToElevation"( obj, "SolveStorage"( obj, "MyGetSlot"( obj, "Inflow" ) [], outflow, "MyGetSlot"( obj, "Storage" ) [@"t - 1"], @"t" ) );

    END
    UUID "{43609b01-e075-44cf-b3af-62a4366fcef2}";;

    FUNCTION       "SpringDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates a list of the form &lcub;Date, Flow Rate&rcub; for the time period April 30 to August 1, accounting for base flow, ramp up & down days, and days at powerplant capacity<br><br>RETURNS: List of lists of the form &lcub;Date, Flow rate&rcub;<br><br>ARGUMENTS:<NONE><br><br>CONSTRAINTS:<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170503: No listed calls to this function; turned it off";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC HClass = $ "FlamingGorgeData.HClass" ["Dec31ofYear"( @"t" )] DO
  WITH NUMERIC PPC = $ "FlamingGorgeData.PowerPlantCapacity" [] DO
   WITH NUMERIC PreviousBaseflow = $ "FlamingGorge.Outflow" [@"24:00:00 April Max DayOfMonth, Current Year"] COMMENTED_BY "Set By Rule: &quot;Base Flow Operations&quot;" DO
    WITH NUMERIC Baseflow = "GetFGBaseFlowMagnitude"(  ) DO
     WITH NUMERIC BypassCapacity = $ "FlamingGorgeData.BypassCharacteristics" [0.00000000, "Bypass Capacity"] DO
      WITH NUMERIC RampUpRate = $ "FlamingGorgeData.RampUpRate" [] DO
       WITH NUMERIC RampDownRate = $ "FlamingGorgeData.BaseFlowDownrampRate" [HClass, 0.00000000] DO
        WITH NUMERIC DaysAtPPC = "GetNumberOfDaysAtPPC"( HClass ) DO
         WITH NUMERIC DaysToRampUp = "DaysToRampUp"( PPC, PreviousBaseflow, RampUpRate ) DO
          WITH NUMERIC DaysToRampDown = "DaysToDownramp"( PPC, Baseflow, RampDownRate ) DO
           WITH NUMERIC DaysToBypass = "GetDaysAtBypass"( HClass ) DO
            WITH DATETIME RampUpStartDate = "CompletePartialDate"( "NumberToDate"( $ "FlamingGorgeData.RampUpStartDate" [0.00000000, 0.00000000] ), @"t" ) COMMENTED_BY "User Input Ramp Up Start Date, should correspond with the Yampa Peak. -HG 9/13/12" DO
             WITH DATETIME PPCStartDate = RampUpStartDate + DaysToRampUp DO
              WITH DATETIME PPCEndDate = PPCStartDate + ( DaysAtPPC - 1.00000000 "day" ) DO
               WITH DATETIME RampDownEndDate = PPCEndDate + DaysToRampDown DO
                WHILE ( ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) < @"24:00:00 August 1, Current Year" ) WITH LIST dateFlowList = { { @"24:00:00 April 30, Current Year" , PreviousBaseflow } } DO
                 WITH DATETIME date = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) + 1.00000000 "day" DO
                  WITH NUMERIC PreviousDaysFlow = ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) DO
                   IF ( "GetMonth"( date ) == 6.00000000 AND "GetDayOfMonth"( date ) <= DaysToBypass )
                   THEN
                    APPEND { date , BypassCapacity } ONTO dateFlowList
                   ELSE
                    IF ( date < RampUpStartDate )
                    THEN
                     APPEND { date , PreviousBaseflow } ONTO dateFlowList
                    ELSE
                     IF ( date >= RampUpStartDate AND date < PPCStartDate )
                     THEN
                      ( APPEND { date , "Min"( PreviousDaysFlow + RampUpRate, PPC ) } ONTO dateFlowList ) COMMENTED_BY "Limit the Ramp Up to a Maximum of the Power Plant Capacity"
                     ELSE
                      IF ( date >= PPCStartDate AND date <= PPCEndDate )
                      THEN
                       APPEND { date , PPC } ONTO dateFlowList
                      ELSE
                       IF ( date <= RampDownEndDate )
                       THEN
                        APPEND { date , "Max"( PreviousDaysFlow - RampDownRate, Baseflow ) } ONTO dateFlowList
                       ELSE
                        APPEND { date , Baseflow } ONTO dateFlowList
                       ENDIF
                      ENDIF
                     ENDIF
                    ENDIF
                   ENDIF COMMENTED_BY "Set Daily Outflows"
                  ENDWITH
                 ENDWITH
                ENDWHILE COMMENTED_BY "Set Daily Outflows"
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH COMMENTED_BY "Define Dates"
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH COMMENTED_BY "Determine Days At Each Rate"
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "This is a problem. <br>We do not know what the baseflow is going to be at the end of the spring release operations. <br>The baseflow is calculated based upon the Previous Pool Elevation and we do not know that when projecting forward. -HG 9/13/12"
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Define Flow Rates";

    END
    UUID "{d925d665-ce76-4ffb-bd92-26a7244a2c3d}";;

    FUNCTION       "SumAnnualDivRequest" ( OBJECT object, STRING wateruser )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  "FlowToVolume"( object & wateruser [date], date )
 ENDFOR;

    END
    UUID "{2ded6bf9-3545-4932-9012-d6860f6985ec}";;

    FUNCTION       "TotalCreationOfArizonaICS" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Sums the user input creation values of ICS for Arizona TP 7/27/2015";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "ICS Credits.AnnualCreationBiNat_AZ" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationSysEff_AZ" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )];

    END
    UUID "{e238926d-1f58-4f8f-9056-f37aa646d7d9}";;

    FUNCTION       "TotalCreationOfNevadaICS" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Sums the user input creation values of ICS for Nevada TP 7/27/2015";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "ICS Credits.AnnualCreationBiNat_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationSysEff_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationEC_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationImp_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationTrib_NV" ["Dec31ofYear"( @"t" )];

    END
    UUID "{7ff76393-a126-4510-a857-443d981e01e7}";;

    FUNCTION       "VallecitoMaxBankReleaseConstraint" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This is the max bank flow for the Pinos River below Vallacito. The value is 2000 cfs and is the recommended max flow from Vallacito by the USBR operations guidelines to prevent damage downstream of Vallacito in Normal Operations.  - TP 10/8/2012<br><br>MC, 20170531: There are no calls to this function, so I disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      $ "VallecitoData.NoDamageMaxBankFlow" [];

    END
    UUID "{2914e4b0-e8c9-479e-9877-e1fa2d904d4a}";;

    FUNCTION       "DeliveryAndCreationCAICS" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the volumes of ICS delivered and EC ICS created for California, taking into account Lower Basin Demand Variability <br><br>RETURNS: List of lists of the form &lcub;&lcub;ICS delivered, EC ICS created&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20180125: Removed SystemTaxAdjustment from Annual Max in MinItem for creationOfCACEICS local variable based on USBR changes to ruleset<br>CH, 4/27/18: Changed totaldeliveryofCAICS assignment so that the available ICS water was was referencing total CA ICS, not just CA EC ICS<br>GCAA, 20181030: Changed reference from MWDDiversionData.MWDMaximumAnnualDelivery to AnnualWaterUse.MWDCanal_AnnualCapacity slot<br>S. Baker, 20200311: Add function IsDomesticSurplus() to replace boolean statement to improve readability. ";
    BEGIN

      WITH NUMERIC creationOfCACEICS = IF ( ( ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NaNToZero ( $ "Surplus.Quantified Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NaNToZero ( $ "Surplus.Flood Control Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR NOT "IsMRM"(  ) ) COMMENTED_BY "If the year is a Shortage Year, a Quantified Surplus Year, a Flood Control Year, <br>or if the run is a deterministic Min, Max or Most run, do not Create any ICS TP <br>12/18/2017 <br>" )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "MinItem"( { $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Put Step 1"] COMMENTED_BY "Annual Max <br>" , "Max"( ( $ "ICS Credits.MeadBankParameters" ["California", "Max Capacity"] - $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December 31, Previous Year"] ), 0.00000000 "acre-ft" ) COMMENTED_BY "Account Space <br>" , $ "ICS Credits.MeadBankParameters" ["California", "Max Put"] COMMENTED_BY "Maximum Creation of MWD ICS <br>" , "Max"( "SumFlowsToVolume"( $ "MWDDiversion:MWD.Diversion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) - $ "AnnualWaterUse.MWDMinimumAnnualDelivery" [], 0.00000000 "acre-ft" ) COMMENTED_BY "Difference between Diversion Requests and Minimum Required MWD Delivery <br>" } )
 ENDIF DO
  WITH NUMERIC totalDeliveryOfCAICS = "MinItem"( { IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NOT "IsMRM"(  ) )
  THEN
   0.00000000 "acre-ft" COMMENTED_BY "Shortage Years <br>"
  ELSE
   IF ( "IsDomesticSurplus"(  ) COMMENTED_BY "If the year has domestic surplus, reduce the ICS Delivery by the amount of <br>Domestic surplus entitlement for MWD. TP 12/18/2017 <br>" )
   THEN
    "Max"( ( $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] - $ "Surplus Volume Entitlements.MWD Domestic" ["Dec31ofYear"( @"t" )] ), 0.00000000 "acre-ft" )
   ELSE
    $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] COMMENTED_BY "Not Surplus or Shortage <br>"
   ENDIF
  ENDIF , ( $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - "SumFlowsToVolume"( $ "MWDDiversion:MWD.Depletion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) ) COMMENTED_BY "MWD at full ditch (Conveyance Capacity)<br>" , "Min"( $ "ICS Credits.MeadBankParameters" ["California", "Max Take"], $ "ICS Credits.TotalICS_CA" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "Make sure the amount of Delivery taken is within the system or below the <br>Maximum Take that MWD can have. TP 12/18/2017 <br>" + creationOfCACEICS ) COMMENTED_BY "Available ICS Water <br>" } ) DO
   { totalDeliveryOfCAICS , creationOfCACEICS }
  ENDWITH
 ENDWITH;

    END
    UUID "{8e328bf2-db24-41b0-8f6d-0641a3084a6f}";;

  END
  UUID "{c60f59a8-c699-40bb-8912-ec47288b9729}";;

  PREDEFINED_GROUP "Numeric / Math";
  DESCRIPTION   "Predefined functions which perform generic numerical computations.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "Max" ( NUMERIC arg1, NUMERIC arg2 )
    SCALE_UNITS    "1000 acre-ft/month";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{fb47de5c-c213-4821-9ce3-61fe6cb0bacf}";
;

    PREDEFINED_FUNCTION "Min" ( NUMERIC arg1, NUMERIC arg2 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{d4f764e3-cb7b-44f8-9171-67ada2679fb4}";
;

    PREDEFINED_FUNCTION "MinItem" ( LIST arg1 )
    SCALE_UNITS    "acre-ft";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    UUID "{22ba6a5f-771e-47ff-9887-3fdcfeeae0d6}";
;

    PREDEFINED_FUNCTION "Sum" ( LIST arg1 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{5dde12be-591c-4480-ac6d-f28d325ae4bd}";
;

  END
  UUID "{2f8eab01-2380-41f6-8526-70e46cc78fd4}";;

  PREDEFINED_GROUP "Date / Time";
  DESCRIPTION   "Predefined functions which access and manipulate date/times.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "OffsetDate" ( DATETIME arg1, NUMERIC arg2, STRING arg3 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{e93f47ba-38a8-4d32-8fb2-dc365ec4ac97}";
;

  END
  UUID "{6186895f-9737-4bac-8761-02cd8abdfdf3}";;

  PREDEFINED_GROUP "Engineering";
  DESCRIPTION   "Predefined functions similar to methods on objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "SolveOutflow" ( OBJECT arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4, DATETIME arg5 )
    SCALE_UNITS    "acre-ft/month";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{e79963fd-a771-4db6-8058-8ea93d163621}";
;

  END
  UUID "{7031996b-6ca4-463b-8651-6de4d75a195e}";;

  PREDEFINED_GROUP "Workspace";
  DESCRIPTION   "Predefined functions which access information on slots and objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "TableInterpolation" ( SLOT arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4, DATETIME arg5 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{61efda6b-bd40-4c40-9015-eec4ff36e1d0}";
;

  END
  UUID "{2e0cdbfc-831f-4455-a940-f257f4c169b0}";;

  REPORT_GROUP "Report Group";
  DESCRIPTION  "";
  NOTES  "";
  BEGIN
  END
  UUID "{82213d73-dfc6-4866-a9c2-9ce4d699edd4}";;

END
UUID "{ab281990-c627-4d76-b0b9-e4f3661ac5ff}";
